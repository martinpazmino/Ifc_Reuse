var Ec = Object.defineProperty;
var gc = (l, t, e) => t in l ? Ec(l, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : l[t] = e;
var w = (l, t, e) => (gc(l, typeof t != "symbol" ? t + "" : t, e), e);
import * as A from "three";
import { Vector3 as q, Vector2 as Be, Plane as Jr, Line3 as dt, Box3 as qe, Mesh as oe, Triangle as xs, Raycaster as Cc, Quaternion as Ft, Euler as Tc, Matrix4 as Ce, Sphere as Un, Controls as yc, Object3D as In, MeshBasicMaterial as ka, LineBasicMaterial as Ga, CylinderGeometry as je, BoxGeometry as He, BufferGeometry as En, Float32BufferAttribute as Us, OctahedronGeometry as Ni, Line as kt, SphereGeometry as Rc, TorusGeometry as Ws, PlaneGeometry as Sc, DoubleSide as Ya, BufferAttribute as Bn, FrontSide as Eo, Ray as Ac, BackSide as Fc, InstancedBufferGeometry as wc, InstancedInterleavedBuffer as Fr, InterleavedBufferAttribute as Ls, WireframeGeometry as vc, UniformsLib as hn, ShaderLib as un, UniformsUtils as $r, ShaderMaterial as nt, Vector4 as Fi, MathUtils as Oc, OrthographicCamera as Ha, WebGLRenderTarget as wt, HalfFloatType as ns, NoBlending as Pc, Clock as Nc, Color as ai, LinearFilter as Et, NearestFilter as gt, RGBAFormat as Gt, DepthTexture as Kn, UnsignedInt248Type as xc, UnsignedIntType as qn, DepthStencilFormat as Lc, DepthFormat as go, DataTexture as Mc, NoColorSpace as bc, RepeatWrapping as Co, REVISION as Wa, RedFormat as Dc, FloatType as _c } from "three";
import * as Pe from "@thatopen/fragments";
import { FragmentsGroup as Jn, Serializer as Uc, FragmentMesh as Bc } from "@thatopen/fragments";
import * as W from "web-ifc";
var Vc = Object.defineProperty, zc = (l, t, e) => t in l ? Vc(l, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : l[t] = e, y = (l, t, e) => (zc(l, typeof t != "symbol" ? t + "" : t, e), e);
const Xa = 0, kc = 1, Gc = 2, To = 2, $n = 1.25, yo = 1, fn = 6 * 4 + 4 + 4, Vn = 65535, Yc = Math.pow(2, -24), er = Symbol("SKIP_GENERATION");
function Hc(l) {
  return l.index ? l.index.count : l.attributes.position.count;
}
function Vs(l) {
  return Hc(l) / 3;
}
function Wc(l, t = ArrayBuffer) {
  return l > 65535 ? new Uint32Array(new t(4 * l)) : new Uint16Array(new t(2 * l));
}
function Xc(l, t) {
  if (!l.index) {
    const e = l.attributes.position.count, s = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = Wc(e, s);
    l.setIndex(new Bn(i, 1));
    for (let n = 0; n < e; n++)
      i[n] = n;
  }
}
function Za(l) {
  const t = Vs(l), e = l.drawRange, s = e.start / 3, i = (e.start + e.count) / 3, n = Math.max(0, s), r = Math.min(t, i) - n;
  return [{
    offset: Math.floor(n),
    count: Math.floor(r)
  }];
}
function ja(l) {
  if (!l.groups || !l.groups.length)
    return Za(l);
  const t = [], e = /* @__PURE__ */ new Set(), s = l.drawRange, i = s.start / 3, n = (s.start + s.count) / 3;
  for (const o of l.groups) {
    const a = o.start / 3, c = (o.start + o.count) / 3;
    e.add(Math.max(i, a)), e.add(Math.min(n, c));
  }
  const r = Array.from(e.values()).sort((o, a) => o - a);
  for (let o = 0; o < r.length - 1; o++) {
    const a = r[o], c = r[o + 1];
    t.push({
      offset: Math.floor(a),
      count: Math.floor(c - a)
    });
  }
  return t;
}
function Zc(l) {
  if (l.groups.length === 0)
    return !1;
  const t = Vs(l), e = ja(l).sort((n, r) => n.offset - r.offset), s = e[e.length - 1];
  s.count = Math.min(t - s.offset, s.count);
  let i = 0;
  return e.forEach(({ count: n }) => i += n), t !== i;
}
function Oe(l, t, e) {
  return e.min.x = t[l], e.min.y = t[l + 1], e.min.z = t[l + 2], e.max.x = t[l + 3], e.max.y = t[l + 4], e.max.z = t[l + 5], e;
}
function jc(l) {
  l[0] = l[1] = l[2] = 1 / 0, l[3] = l[4] = l[5] = -1 / 0;
}
function Ro(l) {
  let t = -1, e = -1 / 0;
  for (let s = 0; s < 3; s++) {
    const i = l[s + 3] - l[s];
    i > e && (e = i, t = s);
  }
  return t;
}
function So(l, t) {
  t.set(l);
}
function Ao(l, t, e) {
  let s, i;
  for (let n = 0; n < 3; n++) {
    const r = n + 3;
    s = l[n], i = t[n], e[n] = s < i ? s : i, s = l[r], i = t[r], e[r] = s > i ? s : i;
  }
}
function xi(l, t, e) {
  for (let s = 0; s < 3; s++) {
    const i = t[l + 2 * s], n = t[l + 2 * s + 1], r = i - n, o = i + n;
    r < e[s] && (e[s] = r), o > e[s + 3] && (e[s + 3] = o);
  }
}
function Xs(l) {
  const t = l[3] - l[0], e = l[4] - l[1], s = l[5] - l[2];
  return 2 * (t * e + e * s + s * t);
}
function tr(l, t, e, s, i = null) {
  let n = 1 / 0, r = 1 / 0, o = 1 / 0, a = -1 / 0, c = -1 / 0, h = -1 / 0, f = 1 / 0, u = 1 / 0, d = 1 / 0, p = -1 / 0, m = -1 / 0, E = -1 / 0;
  const I = i !== null;
  for (let g = t * 6, T = (t + e) * 6; g < T; g += 6) {
    const C = l[g + 0], F = l[g + 1], O = C - F, P = C + F;
    O < n && (n = O), P > a && (a = P), I && C < f && (f = C), I && C > p && (p = C);
    const M = l[g + 2], L = l[g + 3], b = M - L, B = M + L;
    b < r && (r = b), B > c && (c = B), I && M < u && (u = M), I && M > m && (m = M);
    const v = l[g + 4], D = l[g + 5], R = v - D, _ = v + D;
    R < o && (o = R), _ > h && (h = _), I && v < d && (d = v), I && v > E && (E = v);
  }
  s[0] = n, s[1] = r, s[2] = o, s[3] = a, s[4] = c, s[5] = h, I && (i[0] = f, i[1] = u, i[2] = d, i[3] = p, i[4] = m, i[5] = E);
}
function Qc(l, t, e, s) {
  let i = 1 / 0, n = 1 / 0, r = 1 / 0, o = -1 / 0, a = -1 / 0, c = -1 / 0;
  for (let h = t * 6, f = (t + e) * 6; h < f; h += 6) {
    const u = l[h + 0];
    u < i && (i = u), u > o && (o = u);
    const d = l[h + 2];
    d < n && (n = d), d > a && (a = d);
    const p = l[h + 4];
    p < r && (r = p), p > c && (c = p);
  }
  s[0] = i, s[1] = n, s[2] = r, s[3] = o, s[4] = a, s[5] = c;
}
function Kc(l, t) {
  jc(t);
  const e = l.attributes.position, s = l.index ? l.index.array : null, i = Vs(l), n = new Float32Array(i * 6), r = e.normalized, o = e.array, a = e.offset || 0;
  let c = 3;
  e.isInterleavedBufferAttribute && (c = e.data.stride);
  const h = ["getX", "getY", "getZ"];
  for (let f = 0; f < i; f++) {
    const u = f * 3, d = f * 6;
    let p = u + 0, m = u + 1, E = u + 2;
    s && (p = s[p], m = s[m], E = s[E]), r || (p = p * c + a, m = m * c + a, E = E * c + a);
    for (let I = 0; I < 3; I++) {
      let g, T, C;
      r ? (g = e[h[I]](p), T = e[h[I]](m), C = e[h[I]](E)) : (g = o[p + I], T = o[m + I], C = o[E + I]);
      let F = g;
      T < F && (F = T), C < F && (F = C);
      let O = g;
      T > O && (O = T), C > O && (O = C);
      const P = (O - F) / 2, M = I * 2;
      n[d + M + 0] = F + P, n[d + M + 1] = P + (Math.abs(F) + P) * Yc, F < t[I] && (t[I] = F), O > t[I + 3] && (t[I + 3] = O);
    }
  }
  return n;
}
const Nt = 32, qc = (l, t) => l.candidate - t.candidate, Yt = new Array(Nt).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
})), Li = new Float32Array(6);
function Jc(l, t, e, s, i, n) {
  let r = -1, o = 0;
  if (n === Xa)
    r = Ro(t), r !== -1 && (o = (t[r] + t[r + 3]) / 2);
  else if (n === kc)
    r = Ro(l), r !== -1 && (o = $c(e, s, i, r));
  else if (n === Gc) {
    const a = Xs(l);
    let c = $n * i;
    const h = s * 6, f = (s + i) * 6;
    for (let u = 0; u < 3; u++) {
      const d = t[u], E = (t[u + 3] - d) / Nt;
      if (i < Nt / 4) {
        const I = [...Yt];
        I.length = i;
        let g = 0;
        for (let C = h; C < f; C += 6, g++) {
          const F = I[g];
          F.candidate = e[C + 2 * u], F.count = 0;
          const {
            bounds: O,
            leftCacheBounds: P,
            rightCacheBounds: M
          } = F;
          for (let L = 0; L < 3; L++)
            M[L] = 1 / 0, M[L + 3] = -1 / 0, P[L] = 1 / 0, P[L + 3] = -1 / 0, O[L] = 1 / 0, O[L + 3] = -1 / 0;
          xi(C, e, O);
        }
        I.sort(qc);
        let T = i;
        for (let C = 0; C < T; C++) {
          const F = I[C];
          for (; C + 1 < T && I[C + 1].candidate === F.candidate; )
            I.splice(C + 1, 1), T--;
        }
        for (let C = h; C < f; C += 6) {
          const F = e[C + 2 * u];
          for (let O = 0; O < T; O++) {
            const P = I[O];
            F >= P.candidate ? xi(C, e, P.rightCacheBounds) : (xi(C, e, P.leftCacheBounds), P.count++);
          }
        }
        for (let C = 0; C < T; C++) {
          const F = I[C], O = F.count, P = i - F.count, M = F.leftCacheBounds, L = F.rightCacheBounds;
          let b = 0;
          O !== 0 && (b = Xs(M) / a);
          let B = 0;
          P !== 0 && (B = Xs(L) / a);
          const v = yo + $n * (b * O + B * P);
          v < c && (r = u, c = v, o = F.candidate);
        }
      } else {
        for (let T = 0; T < Nt; T++) {
          const C = Yt[T];
          C.count = 0, C.candidate = d + E + T * E;
          const F = C.bounds;
          for (let O = 0; O < 3; O++)
            F[O] = 1 / 0, F[O + 3] = -1 / 0;
        }
        for (let T = h; T < f; T += 6) {
          let O = ~~((e[T + 2 * u] - d) / E);
          O >= Nt && (O = Nt - 1);
          const P = Yt[O];
          P.count++, xi(T, e, P.bounds);
        }
        const I = Yt[Nt - 1];
        So(I.bounds, I.rightCacheBounds);
        for (let T = Nt - 2; T >= 0; T--) {
          const C = Yt[T], F = Yt[T + 1];
          Ao(C.bounds, F.rightCacheBounds, C.rightCacheBounds);
        }
        let g = 0;
        for (let T = 0; T < Nt - 1; T++) {
          const C = Yt[T], F = C.count, O = C.bounds, M = Yt[T + 1].rightCacheBounds;
          F !== 0 && (g === 0 ? So(O, Li) : Ao(O, Li, Li)), g += F;
          let L = 0, b = 0;
          g !== 0 && (L = Xs(Li) / a);
          const B = i - g;
          B !== 0 && (b = Xs(M) / a);
          const v = yo + $n * (L * g + b * B);
          v < c && (r = u, c = v, o = C.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);
  return { axis: r, pos: o };
}
function $c(l, t, e, s) {
  let i = 0;
  for (let n = t, r = t + e; n < r; n++)
    i += l[n * 6 + s * 2];
  return i / e;
}
class Mi {
  constructor() {
  }
}
function eh(l, t, e, s, i, n) {
  let r = s, o = s + i - 1;
  const a = n.pos, c = n.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + c] < a; )
      r++;
    for (; r <= o && e[o * 6 + c] >= a; )
      o--;
    if (r < o) {
      for (let h = 0; h < 3; h++) {
        let f = t[r * 3 + h];
        t[r * 3 + h] = t[o * 3 + h], t[o * 3 + h] = f;
      }
      for (let h = 0; h < 6; h++) {
        let f = e[r * 6 + h];
        e[r * 6 + h] = e[o * 6 + h], e[o * 6 + h] = f;
      }
      r++, o--;
    } else
      return r;
  }
}
function th(l, t, e, s, i, n) {
  let r = s, o = s + i - 1;
  const a = n.pos, c = n.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + c] < a; )
      r++;
    for (; r <= o && e[o * 6 + c] >= a; )
      o--;
    if (r < o) {
      let h = l[r];
      l[r] = l[o], l[o] = h;
      for (let f = 0; f < 6; f++) {
        let u = e[r * 6 + f];
        e[r * 6 + f] = e[o * 6 + f], e[o * 6 + f] = u;
      }
      r++, o--;
    } else
      return r;
  }
}
function sh(l, t) {
  const e = (l.index ? l.index.count : l.attributes.position.count) / 3, s = e > 2 ** 16, i = s ? 4 : 2, n = t ? new SharedArrayBuffer(e * i) : new ArrayBuffer(e * i), r = s ? new Uint32Array(n) : new Uint16Array(n);
  for (let o = 0, a = r.length; o < a; o++)
    r[o] = o;
  return r;
}
function ih(l, t) {
  const e = l.geometry, s = e.index ? e.index.array : null, i = t.maxDepth, n = t.verbose, r = t.maxLeafTris, o = t.strategy, a = t.onProgress, c = Vs(e), h = l._indirectBuffer;
  let f = !1;
  const u = new Float32Array(6), d = new Float32Array(6), p = Kc(e, u), m = t.indirect ? th : eh, E = [], I = t.indirect ? Za(e) : ja(e);
  if (I.length === 1) {
    const C = I[0], F = new Mi();
    F.boundingData = u, Qc(p, C.offset, C.count, d), T(F, C.offset, C.count, d), E.push(F);
  } else
    for (let C of I) {
      const F = new Mi();
      F.boundingData = new Float32Array(6), tr(p, C.offset, C.count, F.boundingData, d), T(F, C.offset, C.count, d), E.push(F);
    }
  return E;
  function g(C) {
    a && a(C / c);
  }
  function T(C, F, O, P = null, M = 0) {
    if (!f && M >= i && (f = !0, n && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e))), O <= r || M >= i)
      return g(F + O), C.offset = F, C.count = O, C;
    const L = Jc(C.boundingData, P, p, F, O, o);
    if (L.axis === -1)
      return g(F + O), C.offset = F, C.count = O, C;
    const b = m(h, s, p, F, O, L);
    if (b === F || b === F + O)
      g(F + O), C.offset = F, C.count = O;
    else {
      C.splitAxis = L.axis;
      const B = new Mi(), v = F, D = b - F;
      C.left = B, B.boundingData = new Float32Array(6), tr(p, v, D, B.boundingData, d), T(B, v, D, d, M + 1);
      const R = new Mi(), _ = b, K = O - D;
      C.right = R, R.boundingData = new Float32Array(6), tr(p, _, K, R.boundingData, d), T(R, _, K, d, M + 1);
    }
    return C;
  }
}
function nh(l, t) {
  const e = l.geometry;
  t.indirect && (l._indirectBuffer = sh(e, t.useSharedArrayBuffer), Zc(e) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), l._indirectBuffer || Xc(e, t);
  const s = ih(l, t);
  let i, n, r;
  const o = [], a = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let f = 0; f < s.length; f++) {
    const u = s[f];
    let d = c(u);
    const p = new a(fn * d);
    i = new Float32Array(p), n = new Uint32Array(p), r = new Uint16Array(p), h(0, u), o.push(p);
  }
  l._roots = o;
  return;
  function c(f) {
    return f.count ? 1 : 1 + c(f.left) + c(f.right);
  }
  function h(f, u) {
    const d = f / 4, p = f / 2, m = !!u.count, E = u.boundingData;
    for (let I = 0; I < 6; I++)
      i[d + I] = E[I];
    if (m) {
      const I = u.offset, g = u.count;
      return n[d + 6] = I, r[p + 14] = g, r[p + 15] = Vn, f + fn;
    } else {
      const I = u.left, g = u.right, T = u.splitAxis;
      let C;
      if (C = h(f + fn, I), C / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return n[d + 6] = C / 4, C = h(C, g), n[d + 7] = T, C;
    }
  }
}
class Vt {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let s = 1 / 0, i = -1 / 0;
    for (let n = 0, r = t.length; n < r; n++) {
      const a = t[n][e];
      s = a < s ? a : s, i = a > i ? a : i;
    }
    this.min = s, this.max = i;
  }
  setFromPoints(t, e) {
    let s = 1 / 0, i = -1 / 0;
    for (let n = 0, r = e.length; n < r; n++) {
      const o = e[n], a = t.dot(o);
      s = a < s ? a : s, i = a > i ? a : i;
    }
    this.min = s, this.max = i;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
}
Vt.prototype.setFromBox = function() {
  const l = new q();
  return function(e, s) {
    const i = s.min, n = s.max;
    let r = 1 / 0, o = -1 / 0;
    for (let a = 0; a <= 1; a++)
      for (let c = 0; c <= 1; c++)
        for (let h = 0; h <= 1; h++) {
          l.x = i.x * a + n.x * (1 - a), l.y = i.y * c + n.y * (1 - c), l.z = i.z * h + n.z * (1 - h);
          const f = e.dot(l);
          r = Math.min(f, r), o = Math.max(f, o);
        }
    this.min = r, this.max = o;
  };
}();
const rh = function() {
  const l = new q(), t = new q(), e = new q();
  return function(i, n, r) {
    const o = i.start, a = l, c = n.start, h = t;
    e.subVectors(o, c), l.subVectors(i.end, i.start), t.subVectors(n.end, n.start);
    const f = e.dot(h), u = h.dot(a), d = h.dot(h), p = e.dot(a), E = a.dot(a) * d - u * u;
    let I, g;
    E !== 0 ? I = (f * u - p * d) / E : I = 0, g = (f + I * u) / d, r.x = I, r.y = g;
  };
}(), eo = function() {
  const l = new Be(), t = new q(), e = new q();
  return function(i, n, r, o) {
    rh(i, n, l);
    let a = l.x, c = l.y;
    if (a >= 0 && a <= 1 && c >= 0 && c <= 1) {
      i.at(a, r), n.at(c, o);
      return;
    } else if (a >= 0 && a <= 1) {
      c < 0 ? n.at(0, o) : n.at(1, o), i.closestPointToPoint(o, !0, r);
      return;
    } else if (c >= 0 && c <= 1) {
      a < 0 ? i.at(0, r) : i.at(1, r), n.closestPointToPoint(r, !0, o);
      return;
    } else {
      let h;
      a < 0 ? h = i.start : h = i.end;
      let f;
      c < 0 ? f = n.start : f = n.end;
      const u = t, d = e;
      if (i.closestPointToPoint(f, !0, t), n.closestPointToPoint(h, !0, e), u.distanceToSquared(f) <= d.distanceToSquared(h)) {
        r.copy(u), o.copy(f);
        return;
      } else {
        r.copy(h), o.copy(d);
        return;
      }
    }
  };
}(), oh = function() {
  const l = new q(), t = new q(), e = new Jr(), s = new dt();
  return function(n, r) {
    const { radius: o, center: a } = n, { a: c, b: h, c: f } = r;
    if (s.start = c, s.end = h, s.closestPointToPoint(a, !0, l).distanceTo(a) <= o || (s.start = c, s.end = f, s.closestPointToPoint(a, !0, l).distanceTo(a) <= o) || (s.start = h, s.end = f, s.closestPointToPoint(a, !0, l).distanceTo(a) <= o))
      return !0;
    const m = r.getPlane(e);
    if (Math.abs(m.distanceToPoint(a)) <= o) {
      const I = m.projectPoint(a, t);
      if (r.containsPoint(I))
        return !0;
    }
    return !1;
  };
}(), ah = 1e-15;
function sr(l) {
  return Math.abs(l) < ah;
}
class pt extends xs {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new q()), this.satBounds = new Array(4).fill().map(() => new Vt()), this.points = [this.a, this.b, this.c], this.sphere = new Un(), this.plane = new Jr(), this.needsUpdate = !0;
  }
  intersectsSphere(t) {
    return oh(t, this);
  }
  update() {
    const t = this.a, e = this.b, s = this.c, i = this.points, n = this.satAxes, r = this.satBounds, o = n[0], a = r[0];
    this.getNormal(o), a.setFromPoints(o, i);
    const c = n[1], h = r[1];
    c.subVectors(t, e), h.setFromPoints(c, i);
    const f = n[2], u = r[2];
    f.subVectors(e, s), u.setFromPoints(f, i);
    const d = n[3], p = r[3];
    d.subVectors(s, t), p.setFromPoints(d, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, t), this.needsUpdate = !1;
  }
}
pt.prototype.closestPointToSegment = function() {
  const l = new q(), t = new q(), e = new dt();
  return function(i, n = null, r = null) {
    const { start: o, end: a } = i, c = this.points;
    let h, f = 1 / 0;
    for (let u = 0; u < 3; u++) {
      const d = (u + 1) % 3;
      e.start.copy(c[u]), e.end.copy(c[d]), eo(e, i, l, t), h = l.distanceToSquared(t), h < f && (f = h, n && n.copy(l), r && r.copy(t));
    }
    return this.closestPointToPoint(o, l), h = o.distanceToSquared(l), h < f && (f = h, n && n.copy(l), r && r.copy(o)), this.closestPointToPoint(a, l), h = a.distanceToSquared(l), h < f && (f = h, n && n.copy(l), r && r.copy(a)), Math.sqrt(f);
  };
}();
pt.prototype.intersectsTriangle = function() {
  const l = new pt(), t = new Array(3), e = new Array(3), s = new Vt(), i = new Vt(), n = new q(), r = new q(), o = new q(), a = new q(), c = new q(), h = new dt(), f = new dt(), u = new dt(), d = new q();
  function p(m, E, I) {
    const g = m.points;
    let T = 0, C = -1;
    for (let F = 0; F < 3; F++) {
      const { start: O, end: P } = h;
      O.copy(g[F]), P.copy(g[(F + 1) % 3]), h.delta(r);
      const M = sr(E.distanceToPoint(O));
      if (sr(E.normal.dot(r)) && M) {
        I.copy(h), T = 2;
        break;
      }
      const L = E.intersectLine(h, d);
      if (!L && M && d.copy(O), (L || M) && !sr(d.distanceTo(P))) {
        if (T <= 1)
          (T === 1 ? I.start : I.end).copy(d), M && (C = T);
        else if (T >= 2) {
          (C === 1 ? I.start : I.end).copy(d), T = 2;
          break;
        }
        if (T++, T === 2 && C === -1)
          break;
      }
    }
    return T;
  }
  return function(E, I = null, g = !1) {
    this.needsUpdate && this.update(), E.isExtendedTriangle ? E.needsUpdate && E.update() : (l.copy(E), l.update(), E = l);
    const T = this.plane, C = E.plane;
    if (Math.abs(T.normal.dot(C.normal)) > 1 - 1e-10) {
      const F = this.satBounds, O = this.satAxes;
      e[0] = E.a, e[1] = E.b, e[2] = E.c;
      for (let L = 0; L < 4; L++) {
        const b = F[L], B = O[L];
        if (s.setFromPoints(B, e), b.isSeparated(s))
          return !1;
      }
      const P = E.satBounds, M = E.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let L = 0; L < 4; L++) {
        const b = P[L], B = M[L];
        if (s.setFromPoints(B, t), b.isSeparated(s))
          return !1;
      }
      for (let L = 0; L < 4; L++) {
        const b = O[L];
        for (let B = 0; B < 4; B++) {
          const v = M[B];
          if (n.crossVectors(b, v), s.setFromPoints(n, t), i.setFromPoints(n, e), s.isSeparated(i))
            return !1;
        }
      }
      return I && (g || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), I.start.set(0, 0, 0), I.end.set(0, 0, 0)), !0;
    } else {
      const F = p(this, C, f);
      if (F === 1 && E.containsPoint(f.end))
        return I && (I.start.copy(f.end), I.end.copy(f.end)), !0;
      if (F !== 2)
        return !1;
      const O = p(E, T, u);
      if (O === 1 && this.containsPoint(u.end))
        return I && (I.start.copy(u.end), I.end.copy(u.end)), !0;
      if (O !== 2)
        return !1;
      if (f.delta(o), u.delta(a), o.dot(a) < 0) {
        let D = u.start;
        u.start = u.end, u.end = D;
      }
      const P = f.start.dot(o), M = f.end.dot(o), L = u.start.dot(o), b = u.end.dot(o), B = M < L, v = P < b;
      return P !== b && L !== M && B === v ? !1 : (I && (c.subVectors(f.start, u.start), c.dot(o) > 0 ? I.start.copy(f.start) : I.start.copy(u.start), c.subVectors(f.end, u.end), c.dot(o) < 0 ? I.end.copy(f.end) : I.end.copy(u.end)), !0);
    }
  };
}();
pt.prototype.distanceToPoint = function() {
  const l = new q();
  return function(e) {
    return this.closestPointToPoint(e, l), e.distanceTo(l);
  };
}();
pt.prototype.distanceToTriangle = function() {
  const l = new q(), t = new q(), e = ["a", "b", "c"], s = new dt(), i = new dt();
  return function(r, o = null, a = null) {
    const c = o || a ? s : null;
    if (this.intersectsTriangle(r, c))
      return (o || a) && (o && c.getCenter(o), a && c.getCenter(a)), 0;
    let h = 1 / 0;
    for (let f = 0; f < 3; f++) {
      let u;
      const d = e[f], p = r[d];
      this.closestPointToPoint(p, l), u = p.distanceToSquared(l), u < h && (h = u, o && o.copy(l), a && a.copy(p));
      const m = this[d];
      r.closestPointToPoint(m, l), u = m.distanceToSquared(l), u < h && (h = u, o && o.copy(m), a && a.copy(l));
    }
    for (let f = 0; f < 3; f++) {
      const u = e[f], d = e[(f + 1) % 3];
      s.set(this[u], this[d]);
      for (let p = 0; p < 3; p++) {
        const m = e[p], E = e[(p + 1) % 3];
        i.set(r[m], r[E]), eo(s, i, l, t);
        const I = l.distanceToSquared(t);
        I < h && (h = I, o && o.copy(l), a && a.copy(t));
      }
    }
    return Math.sqrt(h);
  };
}();
class Ze {
  constructor(t, e, s) {
    this.isOrientedBox = !0, this.min = new q(), this.max = new q(), this.matrix = new Ce(), this.invMatrix = new Ce(), this.points = new Array(8).fill().map(() => new q()), this.satAxes = new Array(3).fill().map(() => new q()), this.satBounds = new Array(3).fill().map(() => new Vt()), this.alignedSatBounds = new Array(3).fill().map(() => new Vt()), this.needsUpdate = !1, t && this.min.copy(t), e && this.max.copy(e), s && this.matrix.copy(s);
  }
  set(t, e, s) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(s), this.needsUpdate = !0;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = !0;
  }
}
Ze.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const t = this.matrix, e = this.min, s = this.max, i = this.points;
    for (let c = 0; c <= 1; c++)
      for (let h = 0; h <= 1; h++)
        for (let f = 0; f <= 1; f++) {
          const u = 1 * c | 2 * h | 4 * f, d = i[u];
          d.x = c ? s.x : e.x, d.y = h ? s.y : e.y, d.z = f ? s.z : e.z, d.applyMatrix4(t);
        }
    const n = this.satBounds, r = this.satAxes, o = i[0];
    for (let c = 0; c < 3; c++) {
      const h = r[c], f = n[c], u = 1 << c, d = i[u];
      h.subVectors(o, d), f.setFromPoints(h, i);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  };
}();
Ze.prototype.intersectsBox = function() {
  const l = new Vt();
  return function(e) {
    this.needsUpdate && this.update();
    const s = e.min, i = e.max, n = this.satBounds, r = this.satAxes, o = this.alignedSatBounds;
    if (l.min = s.x, l.max = i.x, o[0].isSeparated(l) || (l.min = s.y, l.max = i.y, o[1].isSeparated(l)) || (l.min = s.z, l.max = i.z, o[2].isSeparated(l)))
      return !1;
    for (let a = 0; a < 3; a++) {
      const c = r[a], h = n[a];
      if (l.setFromBox(c, e), h.isSeparated(l))
        return !1;
    }
    return !0;
  };
}();
Ze.prototype.intersectsTriangle = function() {
  const l = new pt(), t = new Array(3), e = new Vt(), s = new Vt(), i = new q();
  return function(r) {
    this.needsUpdate && this.update(), r.isExtendedTriangle ? r.needsUpdate && r.update() : (l.copy(r), l.update(), r = l);
    const o = this.satBounds, a = this.satAxes;
    t[0] = r.a, t[1] = r.b, t[2] = r.c;
    for (let u = 0; u < 3; u++) {
      const d = o[u], p = a[u];
      if (e.setFromPoints(p, t), d.isSeparated(e))
        return !1;
    }
    const c = r.satBounds, h = r.satAxes, f = this.points;
    for (let u = 0; u < 3; u++) {
      const d = c[u], p = h[u];
      if (e.setFromPoints(p, f), d.isSeparated(e))
        return !1;
    }
    for (let u = 0; u < 3; u++) {
      const d = a[u];
      for (let p = 0; p < 4; p++) {
        const m = h[p];
        if (i.crossVectors(d, m), e.setFromPoints(i, t), s.setFromPoints(i, f), e.isSeparated(s))
          return !1;
      }
    }
    return !0;
  };
}();
Ze.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(t, e) {
    return this.needsUpdate && this.update(), e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), e;
  };
}();
Ze.prototype.distanceToPoint = function() {
  const l = new q();
  return function(e) {
    return this.closestPointToPoint(e, l), e.distanceTo(l);
  };
}();
Ze.prototype.distanceToBox = function() {
  const l = ["x", "y", "z"], t = new Array(12).fill().map(() => new dt()), e = new Array(12).fill().map(() => new dt()), s = new q(), i = new q();
  return function(r, o = 0, a = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(r))
      return (a || c) && (r.getCenter(i), this.closestPointToPoint(i, s), r.closestPointToPoint(s, i), a && a.copy(s), c && c.copy(i)), 0;
    const h = o * o, f = r.min, u = r.max, d = this.points;
    let p = 1 / 0;
    for (let E = 0; E < 8; E++) {
      const I = d[E];
      i.copy(I).clamp(f, u);
      const g = I.distanceToSquared(i);
      if (g < p && (p = g, a && a.copy(I), c && c.copy(i), g < h))
        return Math.sqrt(g);
    }
    let m = 0;
    for (let E = 0; E < 3; E++)
      for (let I = 0; I <= 1; I++)
        for (let g = 0; g <= 1; g++) {
          const T = (E + 1) % 3, C = (E + 2) % 3, F = I << T | g << C, O = 1 << E | I << T | g << C, P = d[F], M = d[O];
          t[m].set(P, M);
          const b = l[E], B = l[T], v = l[C], D = e[m], R = D.start, _ = D.end;
          R[b] = f[b], R[B] = I ? f[B] : u[B], R[v] = g ? f[v] : u[B], _[b] = u[b], _[B] = I ? f[B] : u[B], _[v] = g ? f[v] : u[B], m++;
        }
    for (let E = 0; E <= 1; E++)
      for (let I = 0; I <= 1; I++)
        for (let g = 0; g <= 1; g++) {
          i.x = E ? u.x : f.x, i.y = I ? u.y : f.y, i.z = g ? u.z : f.z, this.closestPointToPoint(i, s);
          const T = i.distanceToSquared(s);
          if (T < p && (p = T, a && a.copy(s), c && c.copy(i), T < h))
            return Math.sqrt(T);
        }
    for (let E = 0; E < 12; E++) {
      const I = t[E];
      for (let g = 0; g < 12; g++) {
        const T = e[g];
        eo(I, T, s, i);
        const C = s.distanceToSquared(i);
        if (C < p && (p = C, a && a.copy(s), c && c.copy(i), C < h))
          return Math.sqrt(C);
      }
    }
    return Math.sqrt(p);
  };
}();
class to {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
}
class lh extends to {
  constructor() {
    super(() => new pt());
  }
}
const rt = /* @__PURE__ */ new lh();
function Je(l, t) {
  return t[l + 15] === 65535;
}
function $e(l, t) {
  return t[l + 6];
}
function ot(l, t) {
  return t[l + 14];
}
function at(l) {
  return l + 8;
}
function lt(l, t) {
  return t[l + 6];
}
function Qa(l, t) {
  return t[l + 7];
}
class ch {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let e = null;
    this.setBuffer = (s) => {
      e && t.push(e), e = s, this.float32Array = new Float32Array(s), this.uint16Array = new Uint16Array(s), this.uint32Array = new Uint32Array(s);
    }, this.clearBuffer = () => {
      e = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
}
const Ae = new ch();
let Kt, Ms;
const ms = [], bi = /* @__PURE__ */ new to(() => new qe());
function hh(l, t, e, s, i, n) {
  Kt = bi.getPrimitive(), Ms = bi.getPrimitive(), ms.push(Kt, Ms), Ae.setBuffer(l._roots[t]);
  const r = wr(0, l.geometry, e, s, i, n);
  Ae.clearBuffer(), bi.releasePrimitive(Kt), bi.releasePrimitive(Ms), ms.pop(), ms.pop();
  const o = ms.length;
  return o > 0 && (Ms = ms[o - 1], Kt = ms[o - 2]), r;
}
function wr(l, t, e, s, i = null, n = 0, r = 0) {
  const { float32Array: o, uint16Array: a, uint32Array: c } = Ae;
  let h = l * 2;
  if (Je(h, a)) {
    const u = $e(l, c), d = ot(h, a);
    return Oe(l, o, Kt), s(u, d, !1, r, n + l, Kt);
  } else {
    let u = function(v) {
      const { uint16Array: D, uint32Array: R } = Ae;
      let _ = v * 2;
      for (; !Je(_, D); )
        v = at(v), _ = v * 2;
      return $e(v, R);
    }, d = function(v) {
      const { uint16Array: D, uint32Array: R } = Ae;
      let _ = v * 2;
      for (; !Je(_, D); )
        v = lt(v, R), _ = v * 2;
      return $e(v, R) + ot(_, D);
    };
    const p = at(l), m = lt(l, c);
    let E = p, I = m, g, T, C, F;
    if (i && (C = Kt, F = Ms, Oe(E, o, C), Oe(I, o, F), g = i(C), T = i(F), T < g)) {
      E = m, I = p;
      const v = g;
      g = T, T = v, C = F;
    }
    C || (C = Kt, Oe(E, o, C));
    const O = Je(E * 2, a), P = e(C, O, g, r + 1, n + E);
    let M;
    if (P === To) {
      const v = u(E), R = d(E) - v;
      M = s(v, R, !0, r + 1, n + E, C);
    } else
      M = P && wr(
        E,
        t,
        e,
        s,
        i,
        n,
        r + 1
      );
    if (M)
      return !0;
    F = Ms, Oe(I, o, F);
    const L = Je(I * 2, a), b = e(F, L, T, r + 1, n + I);
    let B;
    if (b === To) {
      const v = u(I), R = d(I) - v;
      B = s(v, R, !0, r + 1, n + I, F);
    } else
      B = b && wr(
        I,
        t,
        e,
        s,
        i,
        n,
        r + 1
      );
    return !!B;
  }
}
const Zs = /* @__PURE__ */ new q(), ir = /* @__PURE__ */ new q();
function uh(l, t, e = {}, s = 0, i = 1 / 0) {
  const n = s * s, r = i * i;
  let o = 1 / 0, a = null;
  if (l.shapecast(
    {
      boundsTraverseOrder: (h) => (Zs.copy(t).clamp(h.min, h.max), Zs.distanceToSquared(t)),
      intersectsBounds: (h, f, u) => u < o && u < r,
      intersectsTriangle: (h, f) => {
        h.closestPointToPoint(t, Zs);
        const u = t.distanceToSquared(Zs);
        return u < o && (ir.copy(Zs), o = u, a = f), u < n;
      }
    }
  ), o === 1 / 0)
    return null;
  const c = Math.sqrt(o);
  return e.point ? e.point.copy(ir) : e.point = ir.clone(), e.distance = c, e.faceIndex = a, e;
}
const Is = /* @__PURE__ */ new q(), Es = /* @__PURE__ */ new q(), gs = /* @__PURE__ */ new q(), Di = /* @__PURE__ */ new Be(), _i = /* @__PURE__ */ new Be(), Ui = /* @__PURE__ */ new Be(), Fo = /* @__PURE__ */ new q(), wo = /* @__PURE__ */ new q(), vo = /* @__PURE__ */ new q(), Bi = /* @__PURE__ */ new q();
function fh(l, t, e, s, i, n) {
  let r;
  return n === Fc ? r = l.intersectTriangle(s, e, t, !0, i) : r = l.intersectTriangle(t, e, s, n !== Ya, i), r === null ? null : {
    distance: l.origin.distanceTo(i),
    point: i.clone()
  };
}
function dh(l, t, e, s, i, n, r, o, a) {
  Is.fromBufferAttribute(t, n), Es.fromBufferAttribute(t, r), gs.fromBufferAttribute(t, o);
  const c = fh(l, Is, Es, gs, Bi, a);
  if (c) {
    s && (Di.fromBufferAttribute(s, n), _i.fromBufferAttribute(s, r), Ui.fromBufferAttribute(s, o), c.uv = xs.getInterpolation(Bi, Is, Es, gs, Di, _i, Ui, new Be())), i && (Di.fromBufferAttribute(i, n), _i.fromBufferAttribute(i, r), Ui.fromBufferAttribute(i, o), c.uv1 = xs.getInterpolation(Bi, Is, Es, gs, Di, _i, Ui, new Be())), e && (Fo.fromBufferAttribute(e, n), wo.fromBufferAttribute(e, r), vo.fromBufferAttribute(e, o), c.normal = xs.getInterpolation(Bi, Is, Es, gs, Fo, wo, vo, new q()), c.normal.dot(l.direction) > 0 && c.normal.multiplyScalar(-1));
    const h = {
      a: n,
      b: r,
      c: o,
      normal: new q(),
      materialIndex: 0
    };
    xs.getNormal(Is, Es, gs, h.normal), c.face = h, c.faceIndex = n;
  }
  return c;
}
function zn(l, t, e, s, i) {
  const n = s * 3;
  let r = n + 0, o = n + 1, a = n + 2;
  const c = l.index;
  l.index && (r = c.getX(r), o = c.getX(o), a = c.getX(a));
  const { position: h, normal: f, uv: u, uv1: d } = l.attributes, p = dh(e, h, f, u, d, r, o, a, t);
  return p ? (p.faceIndex = s, i && i.push(p), p) : null;
}
function _e(l, t, e, s) {
  const i = l.a, n = l.b, r = l.c;
  let o = t, a = t + 1, c = t + 2;
  e && (o = e.getX(o), a = e.getX(a), c = e.getX(c)), i.x = s.getX(o), i.y = s.getY(o), i.z = s.getZ(o), n.x = s.getX(a), n.y = s.getY(a), n.z = s.getZ(a), r.x = s.getX(c), r.y = s.getY(c), r.z = s.getZ(c);
}
function ph(l, t, e, s, i, n) {
  const { geometry: r, _indirectBuffer: o } = l;
  for (let a = s, c = s + i; a < c; a++)
    zn(r, t, e, a, n);
}
function mh(l, t, e, s, i) {
  const { geometry: n, _indirectBuffer: r } = l;
  let o = 1 / 0, a = null;
  for (let c = s, h = s + i; c < h; c++) {
    let f;
    f = zn(n, t, e, c), f && f.distance < o && (a = f, o = f.distance);
  }
  return a;
}
function Ih(l, t, e, s, i, n, r) {
  const { geometry: o } = e, { index: a } = o, c = o.attributes.position;
  for (let h = l, f = t + l; h < f; h++) {
    let u;
    if (u = h, _e(r, u * 3, a, c), r.needsUpdate = !0, s(r, u, i, n))
      return !0;
  }
  return !1;
}
function Eh(l, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = l.geometry, s = e.index ? e.index.array : null, i = e.attributes.position;
  let n, r, o, a, c = 0;
  const h = l._roots;
  for (let u = 0, d = h.length; u < d; u++)
    n = h[u], r = new Uint32Array(n), o = new Uint16Array(n), a = new Float32Array(n), f(0, c), c += n.byteLength;
  function f(u, d, p = !1) {
    const m = u * 2;
    if (o[m + 15] === Vn) {
      const I = r[u + 6], g = o[m + 14];
      let T = 1 / 0, C = 1 / 0, F = 1 / 0, O = -1 / 0, P = -1 / 0, M = -1 / 0;
      for (let L = 3 * I, b = 3 * (I + g); L < b; L++) {
        let B = s[L];
        const v = i.getX(B), D = i.getY(B), R = i.getZ(B);
        v < T && (T = v), v > O && (O = v), D < C && (C = D), D > P && (P = D), R < F && (F = R), R > M && (M = R);
      }
      return a[u + 0] !== T || a[u + 1] !== C || a[u + 2] !== F || a[u + 3] !== O || a[u + 4] !== P || a[u + 5] !== M ? (a[u + 0] = T, a[u + 1] = C, a[u + 2] = F, a[u + 3] = O, a[u + 4] = P, a[u + 5] = M, !0) : !1;
    } else {
      const I = u + 8, g = r[u + 6], T = I + d, C = g + d;
      let F = p, O = !1, P = !1;
      t ? F || (O = t.has(T), P = t.has(C), F = !O && !P) : (O = !0, P = !0);
      const M = F || O, L = F || P;
      let b = !1;
      M && (b = f(I, d, F));
      let B = !1;
      L && (B = f(g, d, F));
      const v = b || B;
      if (v)
        for (let D = 0; D < 3; D++) {
          const R = I + D, _ = g + D, K = a[R], U = a[R + 3], Z = a[_], H = a[_ + 3];
          a[u + D] = K < Z ? K : Z, a[u + D + 3] = U > H ? U : H;
        }
      return v;
    }
  }
}
const Oo = /* @__PURE__ */ new qe();
function Jt(l, t, e, s) {
  return Oe(l, t, Oo), e.intersectBox(Oo, s);
}
function gh(l, t, e, s, i, n) {
  const { geometry: r, _indirectBuffer: o } = l;
  for (let a = s, c = s + i; a < c; a++) {
    let h = o ? o[a] : a;
    zn(r, t, e, h, n);
  }
}
function Ch(l, t, e, s, i) {
  const { geometry: n, _indirectBuffer: r } = l;
  let o = 1 / 0, a = null;
  for (let c = s, h = s + i; c < h; c++) {
    let f;
    f = zn(n, t, e, r ? r[c] : c), f && f.distance < o && (a = f, o = f.distance);
  }
  return a;
}
function Th(l, t, e, s, i, n, r) {
  const { geometry: o } = e, { index: a } = o, c = o.attributes.position;
  for (let h = l, f = t + l; h < f; h++) {
    let u;
    if (u = e.resolveTriangleIndex(h), _e(r, u * 3, a, c), r.needsUpdate = !0, s(r, u, i, n))
      return !0;
  }
  return !1;
}
const Po = /* @__PURE__ */ new q();
function yh(l, t, e, s, i) {
  Ae.setBuffer(l._roots[t]), vr(0, l, e, s, i), Ae.clearBuffer();
}
function vr(l, t, e, s, i) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Ae, a = l * 2;
  if (Je(a, r)) {
    const h = $e(l, o), f = ot(a, r);
    ph(t, e, s, h, f, i);
  } else {
    const h = at(l);
    Jt(h, n, s, Po) && vr(h, t, e, s, i);
    const f = lt(l, o);
    Jt(f, n, s, Po) && vr(f, t, e, s, i);
  }
}
const No = /* @__PURE__ */ new q(), Rh = ["x", "y", "z"];
function Sh(l, t, e, s) {
  Ae.setBuffer(l._roots[t]);
  const i = Or(0, l, e, s);
  return Ae.clearBuffer(), i;
}
function Or(l, t, e, s) {
  const { float32Array: i, uint16Array: n, uint32Array: r } = Ae;
  let o = l * 2;
  if (Je(o, n)) {
    const c = $e(l, r), h = ot(o, n);
    return mh(t, e, s, c, h);
  } else {
    const c = Qa(l, r), h = Rh[c], u = s.direction[h] >= 0;
    let d, p;
    u ? (d = at(l), p = lt(l, r)) : (d = lt(l, r), p = at(l));
    const E = Jt(d, i, s, No) ? Or(d, t, e, s) : null;
    if (E) {
      const T = E.point[h];
      if (u ? T <= i[p + c] : (
        // min bounding data
        T >= i[p + c + 3]
      ))
        return E;
    }
    const g = Jt(p, i, s, No) ? Or(p, t, e, s) : null;
    return E && g ? E.distance <= g.distance ? E : g : E || g || null;
  }
}
const Vi = /* @__PURE__ */ new qe(), Cs = /* @__PURE__ */ new pt(), Ts = /* @__PURE__ */ new pt(), js = /* @__PURE__ */ new Ce(), xo = /* @__PURE__ */ new Ze(), zi = /* @__PURE__ */ new Ze();
function Ah(l, t, e, s) {
  Ae.setBuffer(l._roots[t]);
  const i = Pr(0, l, e, s);
  return Ae.clearBuffer(), i;
}
function Pr(l, t, e, s, i = null) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Ae;
  let a = l * 2;
  if (i === null && (e.boundingBox || e.computeBoundingBox(), xo.set(e.boundingBox.min, e.boundingBox.max, s), i = xo), Je(a, r)) {
    const h = t.geometry, f = h.index, u = h.attributes.position, d = e.index, p = e.attributes.position, m = $e(l, o), E = ot(a, r);
    if (js.copy(s).invert(), e.boundsTree)
      return Oe(l, n, zi), zi.matrix.copy(js), zi.needsUpdate = !0, e.boundsTree.shapecast({
        intersectsBounds: (g) => zi.intersectsBox(g),
        intersectsTriangle: (g) => {
          g.a.applyMatrix4(s), g.b.applyMatrix4(s), g.c.applyMatrix4(s), g.needsUpdate = !0;
          for (let T = m * 3, C = (E + m) * 3; T < C; T += 3)
            if (_e(Ts, T, f, u), Ts.needsUpdate = !0, g.intersectsTriangle(Ts))
              return !0;
          return !1;
        }
      });
    for (let I = m * 3, g = (E + m) * 3; I < g; I += 3) {
      _e(Cs, I, f, u), Cs.a.applyMatrix4(js), Cs.b.applyMatrix4(js), Cs.c.applyMatrix4(js), Cs.needsUpdate = !0;
      for (let T = 0, C = d.count; T < C; T += 3)
        if (_e(Ts, T, d, p), Ts.needsUpdate = !0, Cs.intersectsTriangle(Ts))
          return !0;
    }
  } else {
    const h = l + 8, f = o[l + 6];
    return Oe(h, n, Vi), !!(i.intersectsBox(Vi) && Pr(h, t, e, s, i) || (Oe(f, n, Vi), i.intersectsBox(Vi) && Pr(f, t, e, s, i)));
  }
}
const ki = /* @__PURE__ */ new Ce(), nr = /* @__PURE__ */ new Ze(), Qs = /* @__PURE__ */ new Ze(), Fh = /* @__PURE__ */ new q(), wh = /* @__PURE__ */ new q(), vh = /* @__PURE__ */ new q(), Oh = /* @__PURE__ */ new q();
function Ph(l, t, e, s = {}, i = {}, n = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), nr.set(t.boundingBox.min, t.boundingBox.max, e), nr.needsUpdate = !0;
  const o = l.geometry, a = o.attributes.position, c = o.index, h = t.attributes.position, f = t.index, u = rt.getPrimitive(), d = rt.getPrimitive();
  let p = Fh, m = wh, E = null, I = null;
  i && (E = vh, I = Oh);
  let g = 1 / 0, T = null, C = null;
  return ki.copy(e).invert(), Qs.matrix.copy(ki), l.shapecast(
    {
      boundsTraverseOrder: (F) => nr.distanceToBox(F),
      intersectsBounds: (F, O, P) => P < g && P < r ? (O && (Qs.min.copy(F.min), Qs.max.copy(F.max), Qs.needsUpdate = !0), !0) : !1,
      intersectsRange: (F, O) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (M) => Qs.distanceToBox(M),
            intersectsBounds: (M, L, b) => b < g && b < r,
            intersectsRange: (M, L) => {
              for (let b = M, B = M + L; b < B; b++) {
                _e(d, 3 * b, f, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
                for (let v = F, D = F + O; v < D; v++) {
                  _e(u, 3 * v, c, a), u.needsUpdate = !0;
                  const R = u.distanceToTriangle(d, p, E);
                  if (R < g && (m.copy(p), I && I.copy(E), g = R, T = v, C = b), R < n)
                    return !0;
                }
              }
            }
          });
        {
          const P = Vs(t);
          for (let M = 0, L = P; M < L; M++) {
            _e(d, 3 * M, f, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
            for (let b = F, B = F + O; b < B; b++) {
              _e(u, 3 * b, c, a), u.needsUpdate = !0;
              const v = u.distanceToTriangle(d, p, E);
              if (v < g && (m.copy(p), I && I.copy(E), g = v, T = b, C = M), v < n)
                return !0;
            }
          }
        }
      }
    }
  ), rt.releasePrimitive(u), rt.releasePrimitive(d), g === 1 / 0 ? null : (s.point ? s.point.copy(m) : s.point = m.clone(), s.distance = g, s.faceIndex = T, i && (i.point ? i.point.copy(I) : i.point = I.clone(), i.point.applyMatrix4(ki), m.applyMatrix4(ki), i.distance = m.sub(i.point).length(), i.faceIndex = C), s);
}
function Nh(l, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = l.geometry, s = e.index ? e.index.array : null, i = e.attributes.position;
  let n, r, o, a, c = 0;
  const h = l._roots;
  for (let u = 0, d = h.length; u < d; u++)
    n = h[u], r = new Uint32Array(n), o = new Uint16Array(n), a = new Float32Array(n), f(0, c), c += n.byteLength;
  function f(u, d, p = !1) {
    const m = u * 2;
    if (o[m + 15] === Vn) {
      const I = r[u + 6], g = o[m + 14];
      let T = 1 / 0, C = 1 / 0, F = 1 / 0, O = -1 / 0, P = -1 / 0, M = -1 / 0;
      for (let L = I, b = I + g; L < b; L++) {
        const B = 3 * l.resolveTriangleIndex(L);
        for (let v = 0; v < 3; v++) {
          let D = B + v;
          D = s ? s[D] : D;
          const R = i.getX(D), _ = i.getY(D), K = i.getZ(D);
          R < T && (T = R), R > O && (O = R), _ < C && (C = _), _ > P && (P = _), K < F && (F = K), K > M && (M = K);
        }
      }
      return a[u + 0] !== T || a[u + 1] !== C || a[u + 2] !== F || a[u + 3] !== O || a[u + 4] !== P || a[u + 5] !== M ? (a[u + 0] = T, a[u + 1] = C, a[u + 2] = F, a[u + 3] = O, a[u + 4] = P, a[u + 5] = M, !0) : !1;
    } else {
      const I = u + 8, g = r[u + 6], T = I + d, C = g + d;
      let F = p, O = !1, P = !1;
      t ? F || (O = t.has(T), P = t.has(C), F = !O && !P) : (O = !0, P = !0);
      const M = F || O, L = F || P;
      let b = !1;
      M && (b = f(I, d, F));
      let B = !1;
      L && (B = f(g, d, F));
      const v = b || B;
      if (v)
        for (let D = 0; D < 3; D++) {
          const R = I + D, _ = g + D, K = a[R], U = a[R + 3], Z = a[_], H = a[_ + 3];
          a[u + D] = K < Z ? K : Z, a[u + D + 3] = U > H ? U : H;
        }
      return v;
    }
  }
}
const Lo = /* @__PURE__ */ new q();
function xh(l, t, e, s, i) {
  Ae.setBuffer(l._roots[t]), Nr(0, l, e, s, i), Ae.clearBuffer();
}
function Nr(l, t, e, s, i) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Ae, a = l * 2;
  if (Je(a, r)) {
    const h = $e(l, o), f = ot(a, r);
    gh(t, e, s, h, f, i);
  } else {
    const h = at(l);
    Jt(h, n, s, Lo) && Nr(h, t, e, s, i);
    const f = lt(l, o);
    Jt(f, n, s, Lo) && Nr(f, t, e, s, i);
  }
}
const Mo = /* @__PURE__ */ new q(), Lh = ["x", "y", "z"];
function Mh(l, t, e, s) {
  Ae.setBuffer(l._roots[t]);
  const i = xr(0, l, e, s);
  return Ae.clearBuffer(), i;
}
function xr(l, t, e, s) {
  const { float32Array: i, uint16Array: n, uint32Array: r } = Ae;
  let o = l * 2;
  if (Je(o, n)) {
    const c = $e(l, r), h = ot(o, n);
    return Ch(t, e, s, c, h);
  } else {
    const c = Qa(l, r), h = Lh[c], u = s.direction[h] >= 0;
    let d, p;
    u ? (d = at(l), p = lt(l, r)) : (d = lt(l, r), p = at(l));
    const E = Jt(d, i, s, Mo) ? xr(d, t, e, s) : null;
    if (E) {
      const T = E.point[h];
      if (u ? T <= i[p + c] : (
        // min bounding data
        T >= i[p + c + 3]
      ))
        return E;
    }
    const g = Jt(p, i, s, Mo) ? xr(p, t, e, s) : null;
    return E && g ? E.distance <= g.distance ? E : g : E || g || null;
  }
}
const Gi = /* @__PURE__ */ new qe(), ys = /* @__PURE__ */ new pt(), Rs = /* @__PURE__ */ new pt(), Ks = /* @__PURE__ */ new Ce(), bo = /* @__PURE__ */ new Ze(), Yi = /* @__PURE__ */ new Ze();
function bh(l, t, e, s) {
  Ae.setBuffer(l._roots[t]);
  const i = Lr(0, l, e, s);
  return Ae.clearBuffer(), i;
}
function Lr(l, t, e, s, i = null) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Ae;
  let a = l * 2;
  if (i === null && (e.boundingBox || e.computeBoundingBox(), bo.set(e.boundingBox.min, e.boundingBox.max, s), i = bo), Je(a, r)) {
    const h = t.geometry, f = h.index, u = h.attributes.position, d = e.index, p = e.attributes.position, m = $e(l, o), E = ot(a, r);
    if (Ks.copy(s).invert(), e.boundsTree)
      return Oe(l, n, Yi), Yi.matrix.copy(Ks), Yi.needsUpdate = !0, e.boundsTree.shapecast({
        intersectsBounds: (g) => Yi.intersectsBox(g),
        intersectsTriangle: (g) => {
          g.a.applyMatrix4(s), g.b.applyMatrix4(s), g.c.applyMatrix4(s), g.needsUpdate = !0;
          for (let T = m, C = E + m; T < C; T++)
            if (_e(Rs, 3 * t.resolveTriangleIndex(T), f, u), Rs.needsUpdate = !0, g.intersectsTriangle(Rs))
              return !0;
          return !1;
        }
      });
    for (let I = m, g = E + m; I < g; I++) {
      const T = t.resolveTriangleIndex(I);
      _e(ys, 3 * T, f, u), ys.a.applyMatrix4(Ks), ys.b.applyMatrix4(Ks), ys.c.applyMatrix4(Ks), ys.needsUpdate = !0;
      for (let C = 0, F = d.count; C < F; C += 3)
        if (_e(Rs, C, d, p), Rs.needsUpdate = !0, ys.intersectsTriangle(Rs))
          return !0;
    }
  } else {
    const h = l + 8, f = o[l + 6];
    return Oe(h, n, Gi), !!(i.intersectsBox(Gi) && Lr(h, t, e, s, i) || (Oe(f, n, Gi), i.intersectsBox(Gi) && Lr(f, t, e, s, i)));
  }
}
const Hi = /* @__PURE__ */ new Ce(), rr = /* @__PURE__ */ new Ze(), qs = /* @__PURE__ */ new Ze(), Dh = /* @__PURE__ */ new q(), _h = /* @__PURE__ */ new q(), Uh = /* @__PURE__ */ new q(), Bh = /* @__PURE__ */ new q();
function Vh(l, t, e, s = {}, i = {}, n = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), rr.set(t.boundingBox.min, t.boundingBox.max, e), rr.needsUpdate = !0;
  const o = l.geometry, a = o.attributes.position, c = o.index, h = t.attributes.position, f = t.index, u = rt.getPrimitive(), d = rt.getPrimitive();
  let p = Dh, m = _h, E = null, I = null;
  i && (E = Uh, I = Bh);
  let g = 1 / 0, T = null, C = null;
  return Hi.copy(e).invert(), qs.matrix.copy(Hi), l.shapecast(
    {
      boundsTraverseOrder: (F) => rr.distanceToBox(F),
      intersectsBounds: (F, O, P) => P < g && P < r ? (O && (qs.min.copy(F.min), qs.max.copy(F.max), qs.needsUpdate = !0), !0) : !1,
      intersectsRange: (F, O) => {
        if (t.boundsTree) {
          const P = t.boundsTree;
          return P.shapecast({
            boundsTraverseOrder: (M) => qs.distanceToBox(M),
            intersectsBounds: (M, L, b) => b < g && b < r,
            intersectsRange: (M, L) => {
              for (let b = M, B = M + L; b < B; b++) {
                const v = P.resolveTriangleIndex(b);
                _e(d, 3 * v, f, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
                for (let D = F, R = F + O; D < R; D++) {
                  const _ = l.resolveTriangleIndex(D);
                  _e(u, 3 * _, c, a), u.needsUpdate = !0;
                  const K = u.distanceToTriangle(d, p, E);
                  if (K < g && (m.copy(p), I && I.copy(E), g = K, T = D, C = b), K < n)
                    return !0;
                }
              }
            }
          });
        } else {
          const P = Vs(t);
          for (let M = 0, L = P; M < L; M++) {
            _e(d, 3 * M, f, h), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = !0;
            for (let b = F, B = F + O; b < B; b++) {
              const v = l.resolveTriangleIndex(b);
              _e(u, 3 * v, c, a), u.needsUpdate = !0;
              const D = u.distanceToTriangle(d, p, E);
              if (D < g && (m.copy(p), I && I.copy(E), g = D, T = b, C = M), D < n)
                return !0;
            }
          }
        }
      }
    }
  ), rt.releasePrimitive(u), rt.releasePrimitive(d), g === 1 / 0 ? null : (s.point ? s.point.copy(m) : s.point = m.clone(), s.distance = g, s.faceIndex = T, i && (i.point ? i.point.copy(I) : i.point = I.clone(), i.point.applyMatrix4(Hi), m.applyMatrix4(Hi), i.distance = m.sub(i.point).length(), i.faceIndex = C), s);
}
function zh() {
  return typeof SharedArrayBuffer < "u";
}
const ui = new Ae.constructor(), gn = new Ae.constructor(), Zt = new to(() => new qe()), Ss = new qe(), As = new qe(), or = new qe(), ar = new qe();
let lr = !1;
function kh(l, t, e, s) {
  if (lr)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  lr = !0;
  const i = l._roots, n = t._roots;
  let r, o = 0, a = 0;
  const c = new Ce().copy(e).invert();
  for (let h = 0, f = i.length; h < f; h++) {
    ui.setBuffer(i[h]), a = 0;
    const u = Zt.getPrimitive();
    Oe(0, ui.float32Array, u), u.applyMatrix4(c);
    for (let d = 0, p = n.length; d < p && (gn.setBuffer(n[h]), r = ht(
      0,
      0,
      e,
      c,
      s,
      o,
      a,
      0,
      0,
      u
    ), gn.clearBuffer(), a += n[d].length, !r); d++)
      ;
    if (Zt.releasePrimitive(u), ui.clearBuffer(), o += i[h].length, r)
      break;
  }
  return lr = !1, r;
}
function ht(l, t, e, s, i, n = 0, r = 0, o = 0, a = 0, c = null, h = !1) {
  let f, u;
  h ? (f = gn, u = ui) : (f = ui, u = gn);
  const d = f.float32Array, p = f.uint32Array, m = f.uint16Array, E = u.float32Array, I = u.uint32Array, g = u.uint16Array, T = l * 2, C = t * 2, F = Je(T, m), O = Je(C, g);
  let P = !1;
  if (O && F)
    h ? P = i(
      $e(t, I),
      ot(t * 2, g),
      $e(l, p),
      ot(l * 2, m),
      a,
      r + t,
      o,
      n + l
    ) : P = i(
      $e(l, p),
      ot(l * 2, m),
      $e(t, I),
      ot(t * 2, g),
      o,
      n + l,
      a,
      r + t
    );
  else if (O) {
    const M = Zt.getPrimitive();
    Oe(t, E, M), M.applyMatrix4(e);
    const L = at(l), b = lt(l, p);
    Oe(L, d, Ss), Oe(b, d, As);
    const B = M.intersectsBox(Ss), v = M.intersectsBox(As);
    P = B && ht(
      t,
      L,
      s,
      e,
      i,
      r,
      n,
      a,
      o + 1,
      M,
      !h
    ) || v && ht(
      t,
      b,
      s,
      e,
      i,
      r,
      n,
      a,
      o + 1,
      M,
      !h
    ), Zt.releasePrimitive(M);
  } else {
    const M = at(t), L = lt(t, I);
    Oe(M, E, or), Oe(L, E, ar);
    const b = c.intersectsBox(or), B = c.intersectsBox(ar);
    if (b && B)
      P = ht(
        l,
        M,
        e,
        s,
        i,
        n,
        r,
        o,
        a + 1,
        c,
        h
      ) || ht(
        l,
        L,
        e,
        s,
        i,
        n,
        r,
        o,
        a + 1,
        c,
        h
      );
    else if (b)
      if (F)
        P = ht(
          l,
          M,
          e,
          s,
          i,
          n,
          r,
          o,
          a + 1,
          c,
          h
        );
      else {
        const v = Zt.getPrimitive();
        v.copy(or).applyMatrix4(e);
        const D = at(l), R = lt(l, p);
        Oe(D, d, Ss), Oe(R, d, As);
        const _ = v.intersectsBox(Ss), K = v.intersectsBox(As);
        P = _ && ht(
          M,
          D,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          v,
          !h
        ) || K && ht(
          M,
          R,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          v,
          !h
        ), Zt.releasePrimitive(v);
      }
    else if (B)
      if (F)
        P = ht(
          l,
          L,
          e,
          s,
          i,
          n,
          r,
          o,
          a + 1,
          c,
          h
        );
      else {
        const v = Zt.getPrimitive();
        v.copy(ar).applyMatrix4(e);
        const D = at(l), R = lt(l, p);
        Oe(D, d, Ss), Oe(R, d, As);
        const _ = v.intersectsBox(Ss), K = v.intersectsBox(As);
        P = _ && ht(
          L,
          D,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          v,
          !h
        ) || K && ht(
          L,
          R,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          v,
          !h
        ), Zt.releasePrimitive(v);
      }
  }
  return P;
}
const Wi = /* @__PURE__ */ new Ze(), Do = /* @__PURE__ */ new qe();
class so {
  static serialize(t, e = {}) {
    e = {
      cloneBuffers: !0,
      ...e
    };
    const s = t.geometry, i = t._roots, n = t._indirectBuffer, r = s.getIndex();
    let o;
    return e.cloneBuffers ? o = {
      roots: i.map((a) => a.slice()),
      index: r.array.slice(),
      indirectBuffer: n ? n.slice() : null
    } : o = {
      roots: i,
      index: r.array,
      indirectBuffer: n
    }, o;
  }
  static deserialize(t, e, s = {}) {
    s = {
      setIndex: !0,
      indirect: !!t.indirectBuffer,
      ...s
    };
    const { index: i, roots: n, indirectBuffer: r } = t, o = new so(e, { ...s, [er]: !0 });
    if (o._roots = n, o._indirectBuffer = r || null, s.setIndex) {
      const a = e.getIndex();
      if (a === null) {
        const c = new Bn(t.index, 1, !1);
        e.setIndex(c);
      } else
        a.array !== i && (a.array.set(i), a.needsUpdate = !0);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, e = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e = Object.assign({
      strategy: Xa,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: !0,
      useSharedArrayBuffer: !1,
      setBoundingBox: !0,
      onProgress: null,
      indirect: !1,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [er]: !1
    }, e), e.useSharedArrayBuffer && !zh())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, e[er] || (nh(this, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new qe())));
    const { _indirectBuffer: s } = this;
    this.resolveTriangleIndex = e.indirect ? (i) => s[i] : (i) => i;
  }
  refit(t = null) {
    return (this.indirect ? Nh : Eh)(this, t);
  }
  traverse(t, e = 0) {
    const s = this._roots[e], i = new Uint32Array(s), n = new Uint16Array(s);
    r(0);
    function r(o, a = 0) {
      const c = o * 2, h = n[c + 15] === Vn;
      if (h) {
        const f = i[o + 6], u = n[c + 14];
        t(a, h, new Float32Array(s, o * 4, 6), f, u);
      } else {
        const f = o + fn / 4, u = i[o + 6], d = i[o + 7];
        t(a, h, new Float32Array(s, o * 4, 6), d) || (r(f, a + 1), r(u, a + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, e = Eo) {
    const s = this._roots, i = this.geometry, n = [], r = e.isMaterial, o = Array.isArray(e), a = i.groups, c = r ? e.side : e, h = this.indirect ? xh : yh;
    for (let f = 0, u = s.length; f < u; f++) {
      const d = o ? e[a[f].materialIndex].side : c, p = n.length;
      if (h(this, f, d, t, n), o) {
        const m = a[f].materialIndex;
        for (let E = p, I = n.length; E < I; E++)
          n[E].face.materialIndex = m;
      }
    }
    return n;
  }
  raycastFirst(t, e = Eo) {
    const s = this._roots, i = this.geometry, n = e.isMaterial, r = Array.isArray(e);
    let o = null;
    const a = i.groups, c = n ? e.side : e, h = this.indirect ? Mh : Sh;
    for (let f = 0, u = s.length; f < u; f++) {
      const d = r ? e[a[f].materialIndex].side : c, p = h(this, f, d, t);
      p != null && (o == null || p.distance < o.distance) && (o = p, r && (p.face.materialIndex = a[f].materialIndex));
    }
    return o;
  }
  intersectsGeometry(t, e) {
    let s = !1;
    const i = this._roots, n = this.indirect ? bh : Ah;
    for (let r = 0, o = i.length; r < o && (s = n(this, r, t, e), !s); r++)
      ;
    return s;
  }
  shapecast(t) {
    const e = rt.getPrimitive(), s = this.indirect ? Th : Ih;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: n,
      intersectsRange: r,
      intersectsTriangle: o
    } = t;
    if (r && o) {
      const f = r;
      r = (u, d, p, m, E) => f(u, d, p, m, E) ? !0 : s(u, d, this, o, p, m, e);
    } else
      r || (o ? r = (f, u, d, p) => s(f, u, this, o, d, p, e) : r = (f, u, d) => d);
    let a = !1, c = 0;
    const h = this._roots;
    for (let f = 0, u = h.length; f < u; f++) {
      const d = h[f];
      if (a = hh(this, f, n, r, i, c), a)
        break;
      c += d.byteLength;
    }
    return rt.releasePrimitive(e), a;
  }
  bvhcast(t, e, s) {
    let {
      intersectsRanges: i,
      intersectsTriangles: n
    } = s;
    const r = rt.getPrimitive(), o = this.geometry.index, a = this.geometry.attributes.position, c = this.indirect ? (p) => {
      const m = this.resolveTriangleIndex(p);
      _e(r, m * 3, o, a);
    } : (p) => {
      _e(r, p * 3, o, a);
    }, h = rt.getPrimitive(), f = t.geometry.index, u = t.geometry.attributes.position, d = t.indirect ? (p) => {
      const m = t.resolveTriangleIndex(p);
      _e(h, m * 3, f, u);
    } : (p) => {
      _e(h, p * 3, f, u);
    };
    if (n) {
      const p = (m, E, I, g, T, C, F, O) => {
        for (let P = I, M = I + g; P < M; P++) {
          d(P), h.a.applyMatrix4(e), h.b.applyMatrix4(e), h.c.applyMatrix4(e), h.needsUpdate = !0;
          for (let L = m, b = m + E; L < b; L++)
            if (c(L), r.needsUpdate = !0, n(r, h, L, P, T, C, F, O))
              return !0;
        }
        return !1;
      };
      if (i) {
        const m = i;
        i = function(E, I, g, T, C, F, O, P) {
          return m(E, I, g, T, C, F, O, P) ? !0 : p(E, I, g, T, C, F, O, P);
        };
      } else
        i = p;
    }
    return kh(this, t, e, i);
  }
  /* Derived Cast Functions */
  intersectsBox(t, e) {
    return Wi.set(t.min, t.max, e), Wi.needsUpdate = !0, this.shapecast(
      {
        intersectsBounds: (s) => Wi.intersectsBox(s),
        intersectsTriangle: (s) => Wi.intersectsTriangle(s)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (e) => t.intersectsBox(e),
        intersectsTriangle: (e) => e.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, e, s = {}, i = {}, n = 0, r = 1 / 0) {
    return (this.indirect ? Vh : Ph)(
      this,
      t,
      e,
      s,
      i,
      n,
      r
    );
  }
  closestPointToPoint(t, e = {}, s = 0, i = 1 / 0) {
    return uh(
      this,
      t,
      e,
      s,
      i
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((s) => {
      Oe(0, new Float32Array(s), Do), t.union(Do);
    }), t;
  }
}
function _o(l, t, e) {
  return l === null || (l.point.applyMatrix4(t.matrixWorld), l.distance = l.point.distanceTo(e.ray.origin), l.object = t, l.distance < e.near || l.distance > e.far) ? null : l;
}
const cr = /* @__PURE__ */ new Ac(), Uo = /* @__PURE__ */ new Ce(), Gh = oe.prototype.raycast;
function Yh(l, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    Uo.copy(this.matrixWorld).invert(), cr.copy(l.ray).applyMatrix4(Uo);
    const e = this.geometry.boundsTree;
    if (l.firstHitOnly === !0) {
      const s = _o(e.raycastFirst(cr, this.material), this, l);
      s && t.push(s);
    } else {
      const s = e.raycast(cr, this.material);
      for (let i = 0, n = s.length; i < n; i++) {
        const r = _o(s[i], this, l);
        r && t.push(r);
      }
    }
  } else
    Gh.call(this, l, t);
}
function Hh(l) {
  return this.boundsTree = new so(this, l), this.boundsTree;
}
function Wh() {
  this.boundsTree = null;
}
let Y = class {
  constructor() {
    y(this, "enabled", !0), y(this, "trigger", (t) => {
      if (!this.enabled)
        return;
      const e = this.handlers.slice(0);
      for (const s of e)
        s(t);
    }), y(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
class bt {
  constructor() {
    y(this, "enabled", !0), y(this, "trigger", async (t) => {
      if (!this.enabled)
        return;
      const e = this.handlers.slice(0);
      for (const s of e)
        await s(t);
    }), y(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
}
class io {
  constructor(t) {
    y(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this), y(this, "isResizeable", () => "resize" in this && "getSize" in this), y(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this), y(this, "isHideable", () => "visible" in this), y(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this), this.components = t;
  }
}
class ue extends io {
}
class Ka extends io {
  constructor(t) {
    super(t), y(this, "worlds", /* @__PURE__ */ new Map()), y(this, "onWorldChanged", new Y()), y(this, "currentWorld", null), this.onWorldChanged.add(({ world: e, action: s }) => {
      s === "removed" && this.worlds.delete(e.uuid);
    });
  }
}
class Xh extends Ka {
  constructor() {
    super(...arguments), y(this, "hasCameraControls", () => "controls" in this);
  }
}
class Zh extends Ka {
  constructor() {
    super(...arguments), y(this, "onAfterUpdate", new Y()), y(this, "onBeforeUpdate", new Y()), y(this, "onDisposed", new Y()), y(this, "onResize", new Y()), y(this, "onClippingPlanesUpdated", new Y()), y(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(t, e, s) {
    e.isLocal = s;
    const i = this.clippingPlanes.indexOf(e);
    t && i === -1 ? this.clippingPlanes.push(e) : !t && i > -1 && this.clippingPlanes.splice(i, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (n) => !n.isLocal
    );
  }
}
const qa = class Mr extends ue {
  constructor(t) {
    super(t), y(this, "_disposedComponents", /* @__PURE__ */ new Set()), y(this, "enabled", !0), t.add(Mr.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = !0, s = !0) {
    t.removeFromParent();
    const i = t;
    i.dispose && i.dispose(), this.disposeGeometryAndMaterials(t, e), s && i.children && i.children.length && this.disposeChildren(i), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    t.boundsTree && t.disposeBoundsTree && t.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const s = t;
    s.geometry && this.disposeGeometry(s.geometry), e && s.material && Mr.disposeMaterial(s), s.material = [], s.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
y(qa, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
let Ot = qa;
class qt extends Set {
  /**
   * Constructs a new instance of the DataSet class.
   *
   * @param iterable - An optional iterable object to initialize the set with.
   */
  constructor(t) {
    super(t), y(this, "onItemAdded", new Y()), y(this, "onItemDeleted", new Y()), y(this, "onCleared", new Y()), y(this, "guard", () => !0);
  }
  /**
   * Clears the set and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Adds one or multiple values to the set and triggers the onItemAdded event per each.
   *
   * @param value - The value to add to the set.
   * @returns - The set instance.
   */
  add(...t) {
    for (const e of t)
      this.has(e) || !this.guard(e) || (super.add(e), this.onItemAdded || (this.onItemAdded = new Y()), this.onItemAdded.trigger(e));
    return this;
  }
  /**
   * Deletes a value from the set and triggers the onItemDeleted event.
   *
   * @param value - The value to delete from the set.
   * @returns - True if the value was successfully deleted, false otherwise.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(), e;
  }
  /**
   * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
   */
  dispose() {
    this.clear(), this.onItemAdded.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
}
class mt extends Map {
  /**
   * Constructs a new DataMap instance.
   *
   * @param iterable - An iterable object containing key-value pairs to populate the map.
   */
  constructor(t) {
    super(t), y(this, "onItemSet", new Y()), y(this, "onItemUpdated", new Y()), y(this, "onItemDeleted", new Y()), y(this, "onCleared", new Y()), y(this, "guard", () => !0);
  }
  /**
   * Clears the map and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Sets the value for the specified key in the map.
   * If the item is new, then onItemSet is triggered.
   * If the item is already in the map, then onItemUpdated is triggered.
   *
   * @param key - The key of the item to set.
   * @param value - The value of the item to set.
   * @returns The DataMap instance.
   */
  set(t, e) {
    const s = this.has(t);
    if (!(this.guard ?? (() => !0))(t, e))
      return this;
    const r = super.set(t, e);
    return s ? (this.onItemUpdated || (this.onItemUpdated = new Y()), this.onItemUpdated.trigger({ key: t, value: e })) : (this.onItemSet || (this.onItemSet = new Y()), this.onItemSet.trigger({ key: t, value: e })), r;
  }
  /**
   * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
   *
   * @param key - The key of the item to delete.
   * @returns True if the key was found and deleted; otherwise, false.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(t), e;
  }
  /**
   * Clears the map and resets the events.
   */
  dispose() {
    this.clear(), this.onItemSet.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
}
class hr {
  static isEntry(t) {
    return (/* @__PURE__ */ new Set([
      "Boolean",
      "Color",
      "Text",
      "Number",
      "Select",
      "Vector3",
      "TextSet",
      "None"
    ])).has(t.type);
  }
  static copySchema(t, e = {}) {
    for (const s in t) {
      const i = t[s];
      this.isEntry(i) ? e[s] = this.copyEntry(i) : (e[s] = {}, this.copySchema(i, e[s]));
    }
    return e;
  }
  static copyEntry(t) {
    if (t.type === "Boolean") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    if (t.type === "Color") {
      const e = t;
      return {
        type: e.type,
        value: e.value.clone()
      };
    }
    if (t.type === "Text") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    if (t.type === "Number") {
      const e = t;
      return {
        type: e.type,
        value: e.value,
        min: e.min,
        max: e.max,
        interpolable: e.interpolable
      };
    }
    if (t.type === "Select") {
      const e = t;
      return {
        type: e.type,
        value: e.value,
        multiple: e.multiple,
        options: new Set(e.options)
      };
    }
    if (t.type === "Vector3") {
      const e = t;
      return {
        type: e.type,
        value: e.value.clone()
      };
    }
    if (t.type === "TextSet") {
      const e = t;
      return {
        type: e.type,
        value: new Set(e.value)
      };
    }
    if (t.type === "None") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    throw new Error("Invalid entry!");
  }
}
class jh {
  constructor() {
    y(this, "list", /* @__PURE__ */ new Set());
  }
  /**
   * Adds events to this manager.
   * @param events the events to add.
   */
  add(t) {
    for (const e of t)
      this.list.add(e);
  }
  /**
   * Removes events from this manager.
   * @param events the events to remove.
   */
  remove(t) {
    for (const e of t)
      this.list.delete(e);
  }
  /**
   * Sets all the events managed by this instance as enabled or disabled.
   * @param active whether to turn on or off the events.
   */
  set(t) {
    for (const e of this.list)
      e.enabled = t;
  }
  /**
   * Resets all the events managed by this instance.
   */
  reset() {
    for (const t of this.list)
      t.reset();
  }
}
const dn = 0, Qh = 1, Kh = new q(), Bo = new dt(), ur = new Jr(), Vo = new q(), Xi = new xs();
class qh {
  /**
   * Constructs a new convex hull.
   */
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new zo(), this.unassigned = new zo(), this.vertices = [];
  }
  /**
   * Computes to convex hull for the given array of points.
   *
   * @param {Array<Vector3>} points - The array of points in 3D space.
   * @return {ConvexHull} A reference to this convex hull.
   */
  setFromPoints(t) {
    if (t.length >= 4) {
      this.makeEmpty();
      for (let e = 0, s = t.length; e < s; e++)
        this.vertices.push(new Jh(t[e]));
      this._compute();
    }
    return this;
  }
  /**
   * Computes the convex hull of the given 3D object (including its descendants),
   * accounting for the world transforms of both the 3D object and its descendants.
   *
   * @param {Object3D} object - The 3D object to compute the convex hull for.
   * @return {ConvexHull} A reference to this convex hull.
   */
  setFromObject(t) {
    const e = [];
    return t.updateMatrixWorld(!0), t.traverse(function(s) {
      const i = s.geometry;
      if (i !== void 0) {
        const n = i.attributes.position;
        if (n !== void 0)
          for (let r = 0, o = n.count; r < o; r++) {
            const a = new q();
            a.fromBufferAttribute(n, r).applyMatrix4(s.matrixWorld), e.push(a);
          }
      }
    }), this.setFromPoints(e);
  }
  /**
   * Returns `true` if the given point lies in the convex hull.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the given point lies in the convex hull or not.
   */
  containsPoint(t) {
    const e = this.faces;
    for (let s = 0, i = e.length; s < i; s++)
      if (e[s].distanceToPoint(t) > this.tolerance)
        return !1;
    return !0;
  }
  /**
   * Computes the intersections point of the given ray and this convex hull.
   *
   * @param {Ray} ray - The ray to test.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3|null} The intersection point. Returns `null` if not intersection was detected.
   */
  intersectRay(t, e) {
    const s = this.faces;
    let i = -1 / 0, n = 1 / 0;
    for (let r = 0, o = s.length; r < o; r++) {
      const a = s[r], c = a.distanceToPoint(t.origin), h = a.normal.dot(t.direction);
      if (c > 0 && h >= 0)
        return null;
      const f = h !== 0 ? -c / h : 0;
      if (!(f <= 0) && (h > 0 ? n = Math.min(f, n) : i = Math.max(f, i), i > n))
        return null;
    }
    return i !== -1 / 0 ? t.at(i, e) : t.at(n, e), e;
  }
  /**
   * Returns `true` if the given ray intersects with this convex hull.
   *
   * @param {Ray} ray - The ray to test.
   * @return {boolean} Whether the given ray intersects with this convex hull or not.
   */
  intersectsRay(t) {
    return this.intersectRay(t, Kh) !== null;
  }
  /**
   * Makes the convex hull empty.
   *
   * @return {ConvexHull} A reference to this convex hull.
   */
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  // private
  /**
   * Adds a vertex to the 'assigned' list of vertices and assigns it to the given face.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to add.
   * @param {Face} face - The target face.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _addVertexToFace(t, e) {
    return t.face = e, e.outside === null ? this.assigned.append(t) : this.assigned.insertBefore(e.outside, t), e.outside = t, this;
  }
  /**
   * Removes a vertex from the 'assigned' list of vertices and from the given face.
   * It also makes sure that the link from 'face' to the first vertex it sees in 'assigned'
   * is linked correctly after the removal.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to remove.
   * @param {Face} face - The target face.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _removeVertexFromFace(t, e) {
    return t === e.outside && (t.next !== null && t.next.face === e ? e.outside = t.next : e.outside = null), this.assigned.remove(t), this;
  }
  /**
   * Removes all the visible vertices that a given face is able to see which are stored in
   * the 'assigned' vertex list.
   *
   * @private
   * @param {Face} face - The target face.
   * @return {VertexNode|undefined} A reference to this convex hull.
   */
  _removeAllVerticesFromFace(t) {
    if (t.outside !== null) {
      const e = t.outside;
      let s = t.outside;
      for (; s.next !== null && s.next.face === t; )
        s = s.next;
      return this.assigned.removeSubList(e, s), e.prev = s.next = null, t.outside = null, e;
    }
  }
  /**
   * Removes all the visible vertices that `face` is able to see.
   *
   * - If `absorbingFace` doesn't exist, then all the removed vertices will be added to the 'unassigned' vertex list.
   * - If `absorbingFace` exists, then this method will assign all the vertices of 'face' that can see 'absorbingFace'.
   * - If a vertex cannot see `absorbingFace`, it's added to the 'unassigned' vertex list.
   *
   * @private
   * @param {Face} face - The given face.
   * @param {Face} [absorbingFace] - An optional face that tries to absorb the vertices of the first face.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _deleteFaceVertices(t, e) {
    const s = this._removeAllVerticesFromFace(t);
    if (s !== void 0)
      if (e === void 0)
        this.unassigned.appendChain(s);
      else {
        let i = s;
        do {
          const n = i.next;
          e.distanceToPoint(i.point) > this.tolerance ? this._addVertexToFace(i, e) : this.unassigned.append(i), i = n;
        } while (i !== null);
      }
    return this;
  }
  /**
   * Reassigns as many vertices as possible from the unassigned list to the new faces.
   *
   * @private
   * @param {Array<Face>} newFaces - The new faces.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _resolveUnassignedPoints(t) {
    if (this.unassigned.isEmpty() === !1) {
      let e = this.unassigned.first();
      do {
        const s = e.next;
        let i = this.tolerance, n = null;
        for (let r = 0; r < t.length; r++) {
          const o = t[r];
          if (o.mark === dn) {
            const a = o.distanceToPoint(e.point);
            if (a > i && (i = a, n = o), i > 1e3 * this.tolerance)
              break;
          }
        }
        n !== null && this._addVertexToFace(e, n), e = s;
      } while (e !== null);
    }
    return this;
  }
  /**
   * Computes the extremes values (min/max vectors) which will be used to
   * compute the initial hull.
   *
   * @private
   * @return {Object} The extremes.
   */
  _computeExtremes() {
    const t = new q(), e = new q(), s = [], i = [];
    for (let n = 0; n < 3; n++)
      s[n] = i[n] = this.vertices[0];
    t.copy(this.vertices[0].point), e.copy(this.vertices[0].point);
    for (let n = 0, r = this.vertices.length; n < r; n++) {
      const o = this.vertices[n], a = o.point;
      for (let c = 0; c < 3; c++)
        a.getComponent(c) < t.getComponent(c) && (t.setComponent(c, a.getComponent(c)), s[c] = o);
      for (let c = 0; c < 3; c++)
        a.getComponent(c) > e.getComponent(c) && (e.setComponent(c, a.getComponent(c)), i[c] = o);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(t.x), Math.abs(e.x)) + Math.max(Math.abs(t.y), Math.abs(e.y)) + Math.max(Math.abs(t.z), Math.abs(e.z))), { min: s, max: i };
  }
  /**
   * Computes the initial simplex assigning to its faces all the points that are
   * candidates to form part of the hull.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _computeInitialHull() {
    const t = this.vertices, e = this._computeExtremes(), s = e.min, i = e.max;
    let n = 0, r = 0;
    for (let u = 0; u < 3; u++) {
      const d = i[u].point.getComponent(u) - s[u].point.getComponent(u);
      d > n && (n = d, r = u);
    }
    const o = s[r], a = i[r];
    let c, h;
    n = 0, Bo.set(o.point, a.point);
    for (let u = 0, d = this.vertices.length; u < d; u++) {
      const p = t[u];
      if (p !== o && p !== a) {
        Bo.closestPointToPoint(p.point, !0, Vo);
        const m = Vo.distanceToSquared(p.point);
        m > n && (n = m, c = p);
      }
    }
    n = -1, ur.setFromCoplanarPoints(o.point, a.point, c.point);
    for (let u = 0, d = this.vertices.length; u < d; u++) {
      const p = t[u];
      if (p !== o && p !== a && p !== c) {
        const m = Math.abs(ur.distanceToPoint(p.point));
        m > n && (n = m, h = p);
      }
    }
    const f = [];
    if (ur.distanceToPoint(h.point) < 0) {
      f.push(
        ft.create(o, a, c),
        ft.create(h, a, o),
        ft.create(h, c, a),
        ft.create(h, o, c)
      );
      for (let u = 0; u < 3; u++) {
        const d = (u + 1) % 3;
        f[u + 1].getEdge(2).setTwin(f[0].getEdge(d)), f[u + 1].getEdge(1).setTwin(f[d + 1].getEdge(0));
      }
    } else {
      f.push(
        ft.create(o, c, a),
        ft.create(h, o, a),
        ft.create(h, a, c),
        ft.create(h, c, o)
      );
      for (let u = 0; u < 3; u++) {
        const d = (u + 1) % 3;
        f[u + 1].getEdge(2).setTwin(f[0].getEdge((3 - u) % 3)), f[u + 1].getEdge(0).setTwin(f[d + 1].getEdge(1));
      }
    }
    for (let u = 0; u < 4; u++)
      this.faces.push(f[u]);
    for (let u = 0, d = t.length; u < d; u++) {
      const p = t[u];
      if (p !== o && p !== a && p !== c && p !== h) {
        n = this.tolerance;
        let m = null;
        for (let E = 0; E < 4; E++) {
          const I = this.faces[E].distanceToPoint(p.point);
          I > n && (n = I, m = this.faces[E]);
        }
        m !== null && this._addVertexToFace(p, m);
      }
    }
    return this;
  }
  /**
   * Removes inactive (e.g. deleted) faces from the internal face list.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _reindexFaces() {
    const t = [];
    for (let e = 0; e < this.faces.length; e++) {
      const s = this.faces[e];
      s.mark === dn && t.push(s);
    }
    return this.faces = t, this;
  }
  /**
   * Finds the next vertex to create faces with the current hull.
   *
   * - Let the initial face be the first face existing in the 'assigned' vertex list.
   * - If a face doesn't exist then return since there're no vertices left.
   * - Otherwise for each vertex that face sees find the one furthest away from it.
   *
   * @private
   * @return {?VertexNode} The next vertex to add.
   */
  _nextVertexToAdd() {
    if (this.assigned.isEmpty() === !1) {
      let t, e = 0;
      const s = this.assigned.first().face;
      let i = s.outside;
      do {
        const n = s.distanceToPoint(i.point);
        n > e && (e = n, t = i), i = i.next;
      } while (i !== null && i.face === s);
      return t;
    }
  }
  /**
   * Computes a chain of half edges in CCW order called the 'horizon'. For an edge
   * to be part of the horizon it must join a face that can see 'eyePoint' and a face
   * that cannot see 'eyePoint'.
   *
   * @private
   * @param {Vector3} eyePoint - The 3D-coordinates of a point.
   * @param {HalfEdge} crossEdge - The edge used to jump to the current face.
   * @param {Face} face - The current face being tested.
   * @param {Array<HalfEdge>} horizon - The edges that form part of the horizon in CCW order.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _computeHorizon(t, e, s, i) {
    this._deleteFaceVertices(s), s.mark = Qh;
    let n;
    e === null ? n = e = s.getEdge(0) : n = e.next;
    do {
      const r = n.twin, o = r.face;
      o.mark === dn && (o.distanceToPoint(t) > this.tolerance ? this._computeHorizon(t, r, o, i) : i.push(n)), n = n.next;
    } while (n !== e);
    return this;
  }
  /**
   * Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head'
   * in CCW order. All the half edges are created in CCW order thus the face is always pointing
   * outside the hull.
   *
   * @private
   * @param {VertexNode} eyeVertex - The vertex that is added to the hull.
   * @param {HalfEdge} horizonEdge - A single edge of the horizon.
   * @return {HalfEdge} The half edge whose vertex is the eyeVertex.
   */
  _addAdjoiningFace(t, e) {
    const s = ft.create(t, e.tail(), e.head());
    return this.faces.push(s), s.getEdge(-1).setTwin(e.twin), s.getEdge(0);
  }
  /**
   * Adds 'horizon.length' faces to the hull, each face will be linked with the horizon
   * opposite face and the face on the left/right.
   *
   * @private
   * @param {VertexNode} eyeVertex - The vertex that is added to the hull.
   * @param {Array<HalfEdge>} horizon - The horizon.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _addNewFaces(t, e) {
    this.newFaces = [];
    let s = null, i = null;
    for (let n = 0; n < e.length; n++) {
      const r = e[n], o = this._addAdjoiningFace(t, r);
      s === null ? s = o : o.next.setTwin(i), this.newFaces.push(o.face), i = o;
    }
    return s.next.setTwin(i), this;
  }
  /**
   * Adds a vertex to the hull with the following algorithm:
   *
   * - Compute the 'horizon' which is a chain of half edges. For an edge to belong to this group
   * it must be the edge connecting a face that can see 'eyeVertex' and a face which cannot see 'eyeVertex'.
   * - All the faces that can see 'eyeVertex' have its visible vertices removed from the assigned vertex list.
   * - A new set of faces is created with each edge of the 'horizon' and 'eyeVertex'. Each face is connected
   * with the opposite horizon face and the face on the left/right.
   * - The vertices removed from all the visible faces are assigned to the new faces if possible.
   *
   * @private
   * @param {VertexNode} eyeVertex - The vertex to add.
   * @return {ConvexHull} A reference to this convex hull.
   */
  _addVertexToHull(t) {
    const e = [];
    return this.unassigned.clear(), this._removeVertexFromFace(t, t.face), this._computeHorizon(t.point, null, t.face, e), this._addNewFaces(t, e), this._resolveUnassignedPoints(this.newFaces), this;
  }
  /**
   * Cleans up internal properties after computing the convex hull.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  /**
   * Starts the execution of the quick hull algorithm.
   *
   * @private
   * @return {ConvexHull} A reference to this convex hull.
   */
  _compute() {
    let t;
    for (this._computeInitialHull(); (t = this._nextVertexToAdd()) !== void 0; )
      this._addVertexToHull(t);
    return this._reindexFaces(), this._cleanup(), this;
  }
}
class ft {
  /**
   * Constructs a new face.
   */
  constructor() {
    this.normal = new q(), this.midpoint = new q(), this.area = 0, this.constant = 0, this.outside = null, this.mark = dn, this.edge = null;
  }
  /**
   * Creates a face from the given vertex nodes.
   *
   * @private
   * @param {VertexNode} a - The first vertex node.
   * @param {VertexNode} b - The second vertex node.
   * @param {VertexNode} c - The third vertex node.
   * @return {Face} The created face.
   */
  static create(t, e, s) {
    const i = new ft(), n = new fr(t, i), r = new fr(e, i), o = new fr(s, i);
    return n.next = o.prev = r, r.next = n.prev = o, o.next = r.prev = n, i.edge = n, i.compute();
  }
  /**
   * Returns an edge by the given index.
   *
   * @private
   * @param {number} i - The edge index.
   * @return {HalfEdge} The edge.
   */
  getEdge(t) {
    let e = this.edge;
    for (; t > 0; )
      e = e.next, t--;
    for (; t < 0; )
      e = e.prev, t++;
    return e;
  }
  /**
   * Computes all properties of the face.
   *
   * @private
   * @return {Face} A reference to this face.
   */
  compute() {
    const t = this.edge.tail(), e = this.edge.head(), s = this.edge.next.head();
    return Xi.set(t.point, e.point, s.point), Xi.getNormal(this.normal), Xi.getMidpoint(this.midpoint), this.area = Xi.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  /**
   * Returns the signed distance from a given point to the plane representation of this face.
   *
   * @private
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(t) {
    return this.normal.dot(t) - this.constant;
  }
}
class fr {
  /**
   * Constructs a new half edge.
   *
   * @param {VertexNode} vertex - A reference to its destination vertex.
   * @param {Face} face - A reference to its face.
   */
  constructor(t, e) {
    this.vertex = t, this.prev = null, this.next = null, this.twin = null, this.face = e;
  }
  /**
   * Returns the destination vertex.
   *
   * @private
   * @return {VertexNode} The destination vertex.
   */
  head() {
    return this.vertex;
  }
  /**
   * Returns the origin vertex.
   *
   * @private
   * @return {VertexNode} The destination vertex.
   */
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  /**
   * Returns the Euclidean length (straight-line length) of the edge.
   *
   * @private
   * @return {number} The edge's length.
   */
  length() {
    const t = this.head(), e = this.tail();
    return e !== null ? e.point.distanceTo(t.point) : -1;
  }
  /**
   * Returns the square of the Euclidean length (straight-line length) of the edge.
   *
   * @private
   * @return {number} The square of the edge's length.
   */
  lengthSquared() {
    const t = this.head(), e = this.tail();
    return e !== null ? e.point.distanceToSquared(t.point) : -1;
  }
  /**
   * Sets the twin edge of this half-edge. It also ensures that the twin reference
   * of the given half-edge is correctly set.
   *
   * @private
   * @param {HalfEdge} edge - The twin edge to set.
   * @return {HalfEdge} A reference to this edge.
   */
  setTwin(t) {
    return this.twin = t, t.twin = this, this;
  }
}
class Jh {
  /**
   * Constructs a new vertex node.
   *
   * @param {Vector3} point - A point in 3D space.
   */
  constructor(t) {
    this.point = t, this.prev = null, this.next = null, this.face = null;
  }
}
class zo {
  /**
   * Constructs a new vertex list.
   */
  constructor() {
    this.head = null, this.tail = null;
  }
  /**
   * Returns the head reference.
   *
   * @private
   * @return {VertexNode} The head reference.
   */
  first() {
    return this.head;
  }
  /**
   * Returns the tail reference.
   *
   * @private
   * @return {VertexNode} The tail reference.
   */
  last() {
    return this.tail;
  }
  /**
   * Clears the linked list.
   *
   * @private
   * @return {VertexList} A reference to this vertex list.
   */
  clear() {
    return this.head = this.tail = null, this;
  }
  /**
   * Inserts a vertex before a target vertex.
   *
   * @private
   * @param {VertexNode} target - The target.
   * @param {VertexNode} vertex - The vertex to insert.
   * @return {VertexList} A reference to this vertex list.
   */
  insertBefore(t, e) {
    return e.prev = t.prev, e.next = t, e.prev === null ? this.head = e : e.prev.next = e, t.prev = e, this;
  }
  /**
   * Inserts a vertex after a target vertex.
   *
   * @private
   * @param {VertexNode} target - The target.
   * @param {VertexNode} vertex - The vertex to insert.
   * @return {VertexList} A reference to this vertex list.
   */
  insertAfter(t, e) {
    return e.prev = t, e.next = t.next, e.next === null ? this.tail = e : e.next.prev = e, t.next = e, this;
  }
  /**
   * Appends a vertex to this vertex list.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to append.
   * @return {VertexList} A reference to this vertex list.
   */
  append(t) {
    return this.head === null ? this.head = t : this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t, this;
  }
  /**
   * Appends a chain of vertices where the given vertex is the head.
   *
   * @private
   * @param {VertexNode} vertex - The head vertex of a chain of vertices.
   * @return {VertexList} A reference to this vertex list.
   */
  appendChain(t) {
    for (this.head === null ? this.head = t : this.tail.next = t, t.prev = this.tail; t.next !== null; )
      t = t.next;
    return this.tail = t, this;
  }
  /**
   * Removes a vertex from the linked list.
   *
   * @private
   * @param {VertexNode} vertex - The vertex to remove.
   * @return {VertexList} A reference to this vertex list.
   */
  remove(t) {
    return t.prev === null ? this.head = t.next : t.prev.next = t.next, t.next === null ? this.tail = t.prev : t.next.prev = t.prev, this;
  }
  /**
   * Removes a sublist of vertices from the linked list.
   *
   * @private
   * @param {VertexNode} a - The head of the sublist.
   * @param {VertexNode} b - The tail of the sublist.
   * @return {VertexList} A reference to this vertex list.
   */
  removeSubList(t, e) {
    return t.prev === null ? this.head = e.next : t.prev.next = e.next, e.next === null ? this.tail = t.prev : e.next.prev = t.prev, this;
  }
  /**
   * Returns `true` if the linked list is empty.
   *
   * @private
   * @return {boolean} Whether the linked list is empty or not.
   */
  isEmpty() {
    return this.head === null;
  }
}
const br = [2, 2, 1], Dr = [1, 0, 0];
function At(l, t) {
  return l * 3 + t;
}
function $h(l) {
  const t = l.elements;
  let e = 0;
  for (let s = 0; s < 9; s++)
    e += t[s] * t[s];
  return Math.sqrt(e);
}
function eu(l) {
  const t = l.elements;
  let e = 0;
  for (let s = 0; s < 3; s++) {
    const i = t[At(br[s], Dr[s])];
    e += 2 * i * i;
  }
  return Math.sqrt(e);
}
function tu(l, t) {
  let e = 0, s = 1;
  const i = l.elements;
  for (let c = 0; c < 3; c++) {
    const h = Math.abs(i[At(br[c], Dr[c])]);
    h > e && (e = h, s = c);
  }
  let n = 1, r = 0;
  const o = Dr[s], a = br[s];
  if (Math.abs(i[At(a, o)]) > Number.EPSILON) {
    const c = i[At(a, a)], h = i[At(o, o)], f = i[At(a, o)], u = (c - h) / 2 / f;
    let d;
    u < 0 ? d = -1 / (-u + Math.sqrt(1 + u * u)) : d = 1 / (u + Math.sqrt(1 + u * u)), n = 1 / Math.sqrt(1 + d * d), r = d * n;
  }
  return t.identity(), t.elements[At(o, o)] = n, t.elements[At(a, a)] = n, t.elements[At(a, o)] = r, t.elements[At(o, a)] = -r, t;
}
function su(l, t) {
  let e = 0, s = 0;
  const i = 10;
  t.unitary.identity(), t.diagonal.copy(l);
  const n = t.unitary, r = t.diagonal, o = new A.Matrix3(), a = new A.Matrix3(), c = Number.EPSILON * $h(r);
  for (; s < i && eu(r) > c; )
    tu(r, o), a.copy(o).transpose(), r.multiply(o), r.premultiply(a), n.multiply(o), ++e > 2 && (s++, e = 0);
  return t;
}
function iu(l) {
  const t = [];
  for (let le = 0; le < l.length - 2; le += 3) {
    const me = l[le], pe = l[le + 1], Te = l[le + 2];
    t.push(new A.Vector3(me, pe, Te));
  }
  const e = new qh();
  e.setFromPoints(t);
  const s = {
    unitary: new A.Matrix3(),
    diagonal: new A.Matrix3()
  }, i = e.faces, n = [], r = [];
  for (let le = 0, me = i.length; le < me; le++) {
    const pe = i[le];
    let Te = pe.edge;
    n.length = 0;
    do
      n.push(Te), Te = Te.next;
    while (Te !== pe.edge);
    const tt = n.length - 2;
    for (let Ge = 1, S = tt; Ge <= S; Ge++) {
      const Q = n[0].vertex, X = n[Ge + 0].vertex, x = n[Ge + 1].vertex;
      r.push(Q.point.x, Q.point.y, Q.point.z), r.push(X.point.x, X.point.y, X.point.z), r.push(x.point.x, x.point.y, x.point.z);
    }
  }
  const o = new A.Vector3(), a = new A.Vector3(), c = new A.Vector3(), h = new A.Vector3(), f = new A.Vector3(), u = new A.Vector3(), d = new A.Vector3(), p = new A.Vector3();
  let m = 0, E = 0, I = 0, g = 0, T = 0, C = 0, F = 0;
  for (let le = 0, me = r.length; le < me; le += 9) {
    o.fromArray(r, le), a.fromArray(r, le + 3), c.fromArray(r, le + 6), d.set(0, 0, 0), d.add(o).add(a).add(c).divideScalar(3), h.subVectors(a, o), f.subVectors(c, o);
    const pe = u.crossVectors(h, f).length() / 2;
    p.add(u.copy(d).multiplyScalar(pe)), m += pe, E += (9 * d.x * d.x + o.x * o.x + a.x * a.x + c.x * c.x) * (pe / 12), I += (9 * d.x * d.y + o.x * o.y + a.x * a.y + c.x * c.y) * (pe / 12), g += (9 * d.x * d.z + o.x * o.z + a.x * a.z + c.x * c.z) * (pe / 12), T += (9 * d.y * d.y + o.y * o.y + a.y * a.y + c.y * c.y) * (pe / 12), C += (9 * d.y * d.z + o.y * o.z + a.y * a.z + c.y * c.z) * (pe / 12), F += (9 * d.z * d.z + o.z * o.z + a.z * a.z + c.z * c.z) * (pe / 12);
  }
  p.divideScalar(m), E /= m, I /= m, g /= m, T /= m, C /= m, F /= m, E -= p.x * p.x, I -= p.x * p.y, g -= p.x * p.z, T -= p.y * p.y, C -= p.y * p.z, F -= p.z * p.z;
  const O = new A.Matrix3();
  O.elements[0] = E, O.elements[1] = I, O.elements[2] = g, O.elements[3] = I, O.elements[4] = T, O.elements[5] = C, O.elements[6] = g, O.elements[7] = C, O.elements[8] = F, su(O, s);
  const P = s.unitary, M = new A.Vector3(), L = new A.Vector3(), b = new A.Vector3();
  P.extractBasis(M, L, b);
  let B = -1 / 0, v = -1 / 0, D = -1 / 0, R = 1 / 0, _ = 1 / 0, K = 1 / 0;
  for (let le = 0, me = t.length; le < me; le++) {
    const pe = t[le];
    B = Math.max(M.dot(pe), B), v = Math.max(L.dot(pe), v), D = Math.max(b.dot(pe), D), R = Math.min(M.dot(pe), R), _ = Math.min(L.dot(pe), _), K = Math.min(b.dot(pe), K);
  }
  M.multiplyScalar(0.5 * (R + B)), L.multiplyScalar(0.5 * (_ + v)), b.multiplyScalar(0.5 * (K + D));
  const U = new A.Vector3(), Z = new A.Vector3(), H = new A.Matrix3();
  U.add(M).add(L).add(b), Z.x = B - R, Z.y = v - _, Z.z = D - K, Z.multiplyScalar(0.5), H.copy(P);
  const { x: J, y: z, z: k } = Z, ae = new A.Matrix4();
  ae.makeScale(J * 2, z * 2, k * 2);
  const ne = new A.Matrix4();
  ne.makeTranslation(-J, -z, -k);
  const ie = new A.Matrix4();
  ie.makeTranslation(U.x, U.y, U.z);
  const Fe = new A.Matrix4();
  Fe.setFromMatrix3(H);
  const Le = new A.Matrix4();
  return Le.multiply(ie), Le.multiply(Fe), Le.multiply(ne), Le.multiply(ae), { center: U, halfSizes: Z, rotation: H, transformation: Le };
}
class ko {
  static isTransparent(t) {
    return t.transparent && t.opacity < 1;
  }
}
const no = class Ue {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
    return `${Ue._lut[t & 255] + Ue._lut[t >> 8 & 255] + Ue._lut[t >> 16 & 255] + Ue._lut[t >> 24 & 255]}-${Ue._lut[e & 255]}${Ue._lut[e >> 8 & 255]}-${Ue._lut[e >> 16 & 15 | 64]}${Ue._lut[e >> 24 & 255]}-${Ue._lut[s & 63 | 128]}${Ue._lut[s >> 8 & 255]}-${Ue._lut[s >> 16 & 255]}${Ue._lut[s >> 24 & 255]}${Ue._lut[i & 255]}${Ue._lut[i >> 8 & 255]}${Ue._lut[i >> 16 & 255]}${Ue._lut[i >> 24 & 255]}`.toLowerCase();
  }
  static validate(t) {
    if (!Ue._pattern.test(t))
      throw new Error(
        `${t} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
y(no, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/);
y(no, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
let zt = no;
class nu extends ue {
  constructor(t, e) {
    super(t), y(this, "onDisposed", new Y()), y(this, "onVertexFound", new Y()), y(this, "onVertexLost", new Y()), y(this, "onEnabled", new Y()), y(this, "components"), y(this, "workingPlane", null), y(this, "_pickedPoint", null), y(this, "_config"), y(this, "_enabled", !1), this.components = t, this.config = {
      snapDistance: 0.25,
      showOnlyVertex: !1,
      ...e
    }, this.enabled = !1;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(t) {
    this._enabled = t, t || (this._pickedPoint = null), this.onEnabled.trigger(t);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(t) {
    this._config = { ...this._config, ...t };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset(), this.onVertexLost.reset(), this.components = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  get(t) {
    if (!this.enabled)
      return this._pickedPoint;
    const i = this.components.get(ct).get(t).castRay();
    if (!i)
      return this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint;
    const n = this.getClosestVertex(i);
    return n ? (this.workingPlane ? Math.abs(this.workingPlane.distanceToPoint(n)) < 1e-3 : !0) ? ((this._pickedPoint === null || !this._pickedPoint.equals(n)) && (this._pickedPoint = n.clone(), this.onVertexFound.trigger(this._pickedPoint)), this._pickedPoint) : (this._pickedPoint = null, this._pickedPoint) : (this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint);
  }
  getClosestVertex(t) {
    let e = new A.Vector3(), s = !1, i = Number.MAX_SAFE_INTEGER;
    const n = this.getVertices(t);
    if (n === null)
      return null;
    for (const r of n) {
      if (!r)
        continue;
      const o = t.point.distanceTo(r);
      o > i || o > this._config.snapDistance || (s = !0, e = r, i = t.point.distanceTo(r));
    }
    return s ? e : this.config.showOnlyVertex ? null : t.point;
  }
  getVertices(t) {
    const e = t.object;
    if (!t.face || !e)
      return null;
    const s = e.geometry, i = new A.Matrix4(), { instanceId: n } = t, r = n !== void 0, o = e instanceof A.InstancedMesh;
    return o && r && e.getMatrixAt(n, i), [
      this.getVertex(t.face.a, s),
      this.getVertex(t.face.b, s),
      this.getVertex(t.face.c, s)
    ].map((a) => (a && (o && r && a.applyMatrix4(i), a.applyMatrix4(e.matrixWorld)), a));
  }
  getVertex(t, e) {
    if (t === void 0)
      return null;
    const s = e.attributes.position;
    return new A.Vector3(
      s.getX(t),
      s.getY(t),
      s.getZ(t)
    );
  }
}
var Zi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ja(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var ro = { exports: {} };
ro.exports = kn;
ro.exports.default = kn;
function kn(l, t, e) {
  e = e || 2;
  var s = t && t.length, i = s ? t[0] * e : l.length, n = $a(l, 0, i, e, !0), r = [];
  if (!n || n.next === n.prev)
    return r;
  var o, a, c, h, f, u, d;
  if (s && (n = cu(l, t, n, e)), l.length > 80 * e) {
    o = c = l[0], a = h = l[1];
    for (var p = e; p < i; p += e)
      f = l[p], u = l[p + 1], f < o && (o = f), u < a && (a = u), f > c && (c = f), u > h && (h = u);
    d = Math.max(c - o, h - a), d = d !== 0 ? 32767 / d : 0;
  }
  return Ei(n, r, e, o, a, d, 0), r;
}
function $a(l, t, e, s, i) {
  var n, r;
  if (i === Br(l, t, e, s) > 0)
    for (n = t; n < e; n += s)
      r = Go(n, l[n], l[n + 1], r);
  else
    for (n = e - s; n >= t; n -= s)
      r = Go(n, l[n], l[n + 1], r);
  return r && Gn(r, r.next) && (Ci(r), r = r.next), r;
}
function ds(l, t) {
  if (!l)
    return l;
  t || (t = l);
  var e = l, s;
  do
    if (s = !1, !e.steiner && (Gn(e, e.next) || Ne(e.prev, e, e.next) === 0)) {
      if (Ci(e), e = t = e.prev, e === e.next)
        break;
      s = !0;
    } else
      e = e.next;
  while (s || e !== t);
  return t;
}
function Ei(l, t, e, s, i, n, r) {
  if (l) {
    !r && n && pu(l, s, i, n);
    for (var o = l, a, c; l.prev !== l.next; ) {
      if (a = l.prev, c = l.next, n ? ou(l, s, i, n) : ru(l)) {
        t.push(a.i / e | 0), t.push(l.i / e | 0), t.push(c.i / e | 0), Ci(l), l = c.next, o = c.next;
        continue;
      }
      if (l = c, l === o) {
        r ? r === 1 ? (l = au(ds(l), t, e), Ei(l, t, e, s, i, n, 2)) : r === 2 && lu(l, t, e, s, i, n) : Ei(ds(l), t, e, s, i, n, 1);
        break;
      }
    }
  }
}
function ru(l) {
  var t = l.prev, e = l, s = l.next;
  if (Ne(t, e, s) >= 0)
    return !1;
  for (var i = t.x, n = e.x, r = s.x, o = t.y, a = e.y, c = s.y, h = i < n ? i < r ? i : r : n < r ? n : r, f = o < a ? o < c ? o : c : a < c ? a : c, u = i > n ? i > r ? i : r : n > r ? n : r, d = o > a ? o > c ? o : c : a > c ? a : c, p = s.next; p !== t; ) {
    if (p.x >= h && p.x <= u && p.y >= f && p.y <= d && bs(i, o, n, a, r, c, p.x, p.y) && Ne(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function ou(l, t, e, s) {
  var i = l.prev, n = l, r = l.next;
  if (Ne(i, n, r) >= 0)
    return !1;
  for (var o = i.x, a = n.x, c = r.x, h = i.y, f = n.y, u = r.y, d = o < a ? o < c ? o : c : a < c ? a : c, p = h < f ? h < u ? h : u : f < u ? f : u, m = o > a ? o > c ? o : c : a > c ? a : c, E = h > f ? h > u ? h : u : f > u ? f : u, I = _r(d, p, t, e, s), g = _r(m, E, t, e, s), T = l.prevZ, C = l.nextZ; T && T.z >= I && C && C.z <= g; ) {
    if (T.x >= d && T.x <= m && T.y >= p && T.y <= E && T !== i && T !== r && bs(o, h, a, f, c, u, T.x, T.y) && Ne(T.prev, T, T.next) >= 0 || (T = T.prevZ, C.x >= d && C.x <= m && C.y >= p && C.y <= E && C !== i && C !== r && bs(o, h, a, f, c, u, C.x, C.y) && Ne(C.prev, C, C.next) >= 0))
      return !1;
    C = C.nextZ;
  }
  for (; T && T.z >= I; ) {
    if (T.x >= d && T.x <= m && T.y >= p && T.y <= E && T !== i && T !== r && bs(o, h, a, f, c, u, T.x, T.y) && Ne(T.prev, T, T.next) >= 0)
      return !1;
    T = T.prevZ;
  }
  for (; C && C.z <= g; ) {
    if (C.x >= d && C.x <= m && C.y >= p && C.y <= E && C !== i && C !== r && bs(o, h, a, f, c, u, C.x, C.y) && Ne(C.prev, C, C.next) >= 0)
      return !1;
    C = C.nextZ;
  }
  return !0;
}
function au(l, t, e) {
  var s = l;
  do {
    var i = s.prev, n = s.next.next;
    !Gn(i, n) && el(i, s, s.next, n) && gi(i, n) && gi(n, i) && (t.push(i.i / e | 0), t.push(s.i / e | 0), t.push(n.i / e | 0), Ci(s), Ci(s.next), s = l = n), s = s.next;
  } while (s !== l);
  return ds(s);
}
function lu(l, t, e, s, i, n) {
  var r = l;
  do {
    for (var o = r.next.next; o !== r.prev; ) {
      if (r.i !== o.i && Eu(r, o)) {
        var a = tl(r, o);
        r = ds(r, r.next), a = ds(a, a.next), Ei(r, t, e, s, i, n, 0), Ei(a, t, e, s, i, n, 0);
        return;
      }
      o = o.next;
    }
    r = r.next;
  } while (r !== l);
}
function cu(l, t, e, s) {
  var i = [], n, r, o, a, c;
  for (n = 0, r = t.length; n < r; n++)
    o = t[n] * s, a = n < r - 1 ? t[n + 1] * s : l.length, c = $a(l, o, a, s, !1), c === c.next && (c.steiner = !0), i.push(Iu(c));
  for (i.sort(hu), n = 0; n < i.length; n++)
    e = uu(i[n], e);
  return e;
}
function hu(l, t) {
  return l.x - t.x;
}
function uu(l, t) {
  var e = fu(l, t);
  if (!e)
    return t;
  var s = tl(e, l);
  return ds(s, s.next), ds(e, e.next);
}
function fu(l, t) {
  var e = t, s = l.x, i = l.y, n = -1 / 0, r;
  do {
    if (i <= e.y && i >= e.next.y && e.next.y !== e.y) {
      var o = e.x + (i - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (o <= s && o > n && (n = o, r = e.x < e.next.x ? e : e.next, o === s))
        return r;
    }
    e = e.next;
  } while (e !== t);
  if (!r)
    return null;
  var a = r, c = r.x, h = r.y, f = 1 / 0, u;
  e = r;
  do
    s >= e.x && e.x >= c && s !== e.x && bs(i < h ? s : n, i, c, h, i < h ? n : s, i, e.x, e.y) && (u = Math.abs(i - e.y) / (s - e.x), gi(e, l) && (u < f || u === f && (e.x > r.x || e.x === r.x && du(r, e))) && (r = e, f = u)), e = e.next;
  while (e !== a);
  return r;
}
function du(l, t) {
  return Ne(l.prev, l, t.prev) < 0 && Ne(t.next, l, l.next) < 0;
}
function pu(l, t, e, s) {
  var i = l;
  do
    i.z === 0 && (i.z = _r(i.x, i.y, t, e, s)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== l);
  i.prevZ.nextZ = null, i.prevZ = null, mu(i);
}
function mu(l) {
  var t, e, s, i, n, r, o, a, c = 1;
  do {
    for (e = l, l = null, n = null, r = 0; e; ) {
      for (r++, s = e, o = 0, t = 0; t < c && (o++, s = s.nextZ, !!s); t++)
        ;
      for (a = c; o > 0 || a > 0 && s; )
        o !== 0 && (a === 0 || !s || e.z <= s.z) ? (i = e, e = e.nextZ, o--) : (i = s, s = s.nextZ, a--), n ? n.nextZ = i : l = i, i.prevZ = n, n = i;
      e = s;
    }
    n.nextZ = null, c *= 2;
  } while (r > 1);
  return l;
}
function _r(l, t, e, s, i) {
  return l = (l - e) * i | 0, t = (t - s) * i | 0, l = (l | l << 8) & 16711935, l = (l | l << 4) & 252645135, l = (l | l << 2) & 858993459, l = (l | l << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, l | t << 1;
}
function Iu(l) {
  var t = l, e = l;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== l);
  return e;
}
function bs(l, t, e, s, i, n, r, o) {
  return (i - r) * (t - o) >= (l - r) * (n - o) && (l - r) * (s - o) >= (e - r) * (t - o) && (e - r) * (n - o) >= (i - r) * (s - o);
}
function Eu(l, t) {
  return l.next.i !== t.i && l.prev.i !== t.i && !gu(l, t) && // dones't intersect other edges
  (gi(l, t) && gi(t, l) && Cu(l, t) && // locally visible
  (Ne(l.prev, l, t.prev) || Ne(l, t.prev, t)) || // does not create opposite-facing sectors
  Gn(l, t) && Ne(l.prev, l, l.next) > 0 && Ne(t.prev, t, t.next) > 0);
}
function Ne(l, t, e) {
  return (t.y - l.y) * (e.x - t.x) - (t.x - l.x) * (e.y - t.y);
}
function Gn(l, t) {
  return l.x === t.x && l.y === t.y;
}
function el(l, t, e, s) {
  var i = Qi(Ne(l, t, e)), n = Qi(Ne(l, t, s)), r = Qi(Ne(e, s, l)), o = Qi(Ne(e, s, t));
  return !!(i !== n && r !== o || i === 0 && ji(l, e, t) || n === 0 && ji(l, s, t) || r === 0 && ji(e, l, s) || o === 0 && ji(e, t, s));
}
function ji(l, t, e) {
  return t.x <= Math.max(l.x, e.x) && t.x >= Math.min(l.x, e.x) && t.y <= Math.max(l.y, e.y) && t.y >= Math.min(l.y, e.y);
}
function Qi(l) {
  return l > 0 ? 1 : l < 0 ? -1 : 0;
}
function gu(l, t) {
  var e = l;
  do {
    if (e.i !== l.i && e.next.i !== l.i && e.i !== t.i && e.next.i !== t.i && el(e, e.next, l, t))
      return !0;
    e = e.next;
  } while (e !== l);
  return !1;
}
function gi(l, t) {
  return Ne(l.prev, l, l.next) < 0 ? Ne(l, t, l.next) >= 0 && Ne(l, l.prev, t) >= 0 : Ne(l, t, l.prev) < 0 || Ne(l, l.next, t) < 0;
}
function Cu(l, t) {
  var e = l, s = !1, i = (l.x + t.x) / 2, n = (l.y + t.y) / 2;
  do
    e.y > n != e.next.y > n && e.next.y !== e.y && i < (e.next.x - e.x) * (n - e.y) / (e.next.y - e.y) + e.x && (s = !s), e = e.next;
  while (e !== l);
  return s;
}
function tl(l, t) {
  var e = new Ur(l.i, l.x, l.y), s = new Ur(t.i, t.x, t.y), i = l.next, n = t.prev;
  return l.next = t, t.prev = l, e.next = i, i.prev = e, s.next = e, e.prev = s, n.next = s, s.prev = n, s;
}
function Go(l, t, e, s) {
  var i = new Ur(l, t, e);
  return s ? (i.next = s.next, i.prev = s, s.next.prev = i, s.next = i) : (i.prev = i, i.next = i), i;
}
function Ci(l) {
  l.next.prev = l.prev, l.prev.next = l.next, l.prevZ && (l.prevZ.nextZ = l.nextZ), l.nextZ && (l.nextZ.prevZ = l.prevZ);
}
function Ur(l, t, e) {
  this.i = l, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
kn.deviation = function(l, t, e, s) {
  var i = t && t.length, n = i ? t[0] * e : l.length, r = Math.abs(Br(l, 0, n, e));
  if (i)
    for (var o = 0, a = t.length; o < a; o++) {
      var c = t[o] * e, h = o < a - 1 ? t[o + 1] * e : l.length;
      r -= Math.abs(Br(l, c, h, e));
    }
  var f = 0;
  for (o = 0; o < s.length; o += 3) {
    var u = s[o] * e, d = s[o + 1] * e, p = s[o + 2] * e;
    f += Math.abs(
      (l[u] - l[p]) * (l[d + 1] - l[u + 1]) - (l[u] - l[d]) * (l[p + 1] - l[u + 1])
    );
  }
  return r === 0 && f === 0 ? 0 : Math.abs((f - r) / r);
};
function Br(l, t, e, s) {
  for (var i = 0, n = t, r = e - s; n < e; n += s)
    i += (l[r] - l[n]) * (l[n + 1] + l[r + 1]), r = n;
  return i;
}
kn.flatten = function(l) {
  for (var t = l[0][0].length, e = { vertices: [], holes: [], dimensions: t }, s = 0, i = 0; i < l.length; i++) {
    for (var n = 0; n < l[i].length; n++)
      for (var r = 0; r < t; r++)
        e.vertices.push(l[i][n][r]);
    i > 0 && (s += l[i - 1].length, e.holes.push(s));
  }
  return e;
};
var Tu = ro.exports;
const yu = /* @__PURE__ */ Ja(Tu);
class Ru extends ue {
  constructor() {
    super(...arguments), y(this, "enabled", !0), y(this, "_inverseMatrix", new A.Matrix4()), y(this, "_localPlane", new A.Plane()), y(this, "_tempLine", new A.Line3()), y(this, "_tempVector", new A.Vector3()), y(this, "_plane"), y(this, "_plane2DCoordinateSystem", new A.Matrix4()), y(this, "_precission", 1e4), y(this, "_planeAxis");
  }
  get plane() {
    if (!this._plane)
      throw new Error("Plane not set");
    return this._plane;
  }
  set plane(t) {
    this._plane = t;
  }
  // This assumes that the mesh that contains the posAttr is aligned with the current plane
  createEdges(t) {
    const { meshes: e, posAttr: s } = t;
    let i = 0;
    s.array.fill(0);
    const n = [];
    let r = 0;
    const o = new A.Mesh();
    for (const a of e)
      if (a.geometry) {
        if (a.geometry.boundsTree || a.geometry.computeBoundsTree(), !a.geometry.boundsTree)
          throw new Error("Bounds tree not found for edges generation.");
        if (a instanceof A.InstancedMesh) {
          if (a.count === 0)
            continue;
          const c = a;
          for (let h = 0; h < c.count; h++) {
            o.geometry = a.geometry, o.matrix.copy(a.matrix);
            const f = new A.Matrix4();
            c.getMatrixAt(h, f), o.applyMatrix4(f), o.applyMatrix4(a.matrixWorld), o.updateMatrix(), o.updateMatrixWorld(), this._inverseMatrix.copy(o.matrixWorld).invert(), this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix), i = this.shapecast(o, s, i), i !== r && (n.push(i), r = i);
          }
        } else
          this._inverseMatrix.copy(a.matrixWorld).invert(), this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix), i = this.shapecast(a, s, i), i !== r && (n.push(i), r = i);
      }
    return { indexes: n, index: i };
  }
  createFills(t, e) {
    this.updatePlane2DCoordinateSystem();
    const s = [];
    let i = 0;
    for (let n = 0; n < e.length; n++) {
      const r = e[n], o = [];
      for (let c = i; c < r; c += 2)
        o.push(c * 3);
      const a = this.computeFill(o, t);
      for (const c of a)
        s.push(c);
      i = r;
    }
    return s;
  }
  computeFill(t, e) {
    const s = /* @__PURE__ */ new Map(), i = {}, n = /* @__PURE__ */ new Map();
    let r = 0;
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), h = this._precission;
    for (let u = 0; u < t.length; u++) {
      const d = t[u];
      let p = 0, m = 0, E = 0, I = 0;
      const g = e[d], T = e[d + 1], C = e[d + 2], F = e[d + 3], O = e[d + 4], P = e[d + 5];
      if (this._tempVector.set(g, T, C), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), p = Math.trunc(this._tempVector.x * h) / h, m = Math.trunc(this._tempVector.y * h) / h, this._tempVector.set(F, O, P), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), E = Math.trunc(this._tempVector.x * h) / h, I = Math.trunc(this._tempVector.y * h) / h, p === E && m === I)
        continue;
      const M = `${p}|${m}`, L = `${E}|${I}`;
      s.has(M) || s.set(M, d / 3), s.has(L) || s.set(L, d / 3 + 1);
      const b = s.get(M), B = s.get(L);
      i[b] = [p, m], i[B] = [E, I];
      const v = a.has(b), D = o.has(b), R = a.has(B), _ = o.has(B);
      if (!v && !D && !R && !_)
        a.set(b, r), o.set(B, r), c.add(r), n.set(r, [b, B]), r++;
      else if (v && _) {
        const U = a.get(b), Z = o.get(B);
        if (U !== Z) {
          const J = n.get(Z), z = n.get(U);
          if (!J || !z)
            continue;
          n.delete(U), c.delete(U), o.set(z[z.length - 1], Z), o.delete(J[J.length - 1]);
          for (const k of z)
            J.push(k);
        } else
          c.delete(Z);
        a.delete(b), o.delete(B);
      } else if (D && R) {
        const U = a.get(B), Z = o.get(b);
        if (U !== Z) {
          const J = n.get(Z), z = n.get(U);
          if (!J || !z)
            continue;
          n.delete(U), c.delete(U), o.set(z[z.length - 1], Z), o.delete(J[J.length - 1]);
          for (const k of z)
            J.push(k);
        } else
          c.delete(Z);
        a.delete(B), o.delete(b);
      } else if (v && R) {
        const U = a.get(B), Z = a.get(b), H = n.get(Z), J = n.get(U);
        if (!H || !J)
          continue;
        n.delete(U), c.delete(U), a.delete(H[0]), a.delete(J[0]), o.delete(J[J.length - 1]), a.set(J[J.length - 1], Z), J.reverse(), H.splice(0, 0, ...J);
      } else if (D && _) {
        const U = o.get(B), Z = o.get(b), H = n.get(Z), J = n.get(U);
        if (!H || !J)
          continue;
        n.delete(U), c.delete(U), o.delete(H[H.length - 1]), o.delete(J[J.length - 1]), a.delete(J[0]), o.set(J[0], Z), J.reverse(), H.push(...J);
      } else if (v) {
        const U = a.get(b), Z = n.get(U);
        if (!Z)
          continue;
        Z.unshift(B), a.delete(b), a.set(B, U);
      } else if (D) {
        const U = o.get(b), Z = n.get(U);
        if (!Z)
          continue;
        Z.push(B), o.delete(b), o.set(B, U);
      } else if (R) {
        const U = a.get(B), Z = n.get(U);
        if (!Z)
          continue;
        Z.unshift(b), a.delete(B), a.set(b, U);
      } else if (_) {
        const U = o.get(B), Z = n.get(U);
        if (!Z)
          continue;
        Z.push(b), o.delete(B), o.set(b, U);
      }
    }
    const f = [];
    for (const [u, d] of n) {
      if (c.has(u))
        continue;
      const p = [], m = /* @__PURE__ */ new Map();
      let E = 0;
      for (const g of d) {
        const T = i[g];
        p.push(T[0], T[1]), m.set(E++, g);
      }
      const I = yu(p);
      for (const g of I) {
        const T = m.get(g);
        if (T === void 0)
          throw new Error("Map error!");
        f.push(T);
      }
    }
    return f;
  }
  updatePlane2DCoordinateSystem() {
    this._plane2DCoordinateSystem = new A.Matrix4();
    const t = new A.Vector3(1, 0, 0), e = new A.Vector3(0, 1, 0), s = this.plane.normal, i = new A.Vector3();
    this.plane.coplanarPoint(i), this._planeAxis === "x" ? t.crossVectors(e, s) : this._planeAxis === "y" ? e.crossVectors(s, t) : this._planeAxis === "z" || (t.crossVectors(e, s).normalize(), e.crossVectors(s, t)), this._plane2DCoordinateSystem.fromArray([
      t.x,
      t.y,
      t.z,
      0,
      e.x,
      e.y,
      e.z,
      0,
      s.x,
      s.y,
      s.z,
      0,
      i.x,
      i.y,
      i.z,
      1
    ]), this._plane2DCoordinateSystem.invert();
  }
  shapecast(t, e, s) {
    return t.geometry.boundsTree.shapecast({
      intersectsBounds: (i) => this._localPlane.intersectsBox(i),
      // @ts-ignore
      intersectsTriangle: (i) => {
        let n = 0;
        if (this._tempLine.start.copy(i.a), this._tempLine.end.copy(i.b), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(s, r.x, r.y, r.z), n++, s++;
        }
        if (this._tempLine.start.copy(i.b), this._tempLine.end.copy(i.c), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(s, r.x, r.y, r.z), n++, s++;
        }
        if (this._tempLine.start.copy(i.c), this._tempLine.end.copy(i.a), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(s, r.x, r.y, r.z), n++, s++;
        }
        n !== 2 && (s -= n);
      }
    }), s;
  }
}
y(Ru, "uuid", "1a193b87-6376-46c8-9e65-62a1576fdb64");
const sl = class il {
  constructor() {
    y(this, "onDisposed", new Y()), y(this, "list", /* @__PURE__ */ new Map()), y(this, "enabled", !1), y(this, "_clock"), y(this, "onInit", new Y()), y(this, "update", () => {
      if (!this.enabled)
        return;
      const t = this._clock.getDelta();
      for (const [e, s] of this.list)
        s.enabled && s.isUpdateable() && s.update(t);
      requestAnimationFrame(this.update);
    }), this._clock = new A.Clock(), il.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(t, e) {
    if (this.list.has(t))
      throw new Error(
        "You're trying to add a component that already exists in the components instance. Use Components.get() instead."
      );
    zt.validate(t), this.list.set(t, e);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(t) {
    const e = t.uuid;
    if (!this.list.has(e)) {
      const s = new t(this);
      return this.list.has(e) || this.add(e, s), s;
    }
    return this.list.get(e);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   */
  init() {
    this.enabled = !0, this._clock.start(), this.update(), this.onInit.trigger();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = !1;
    for (const [t, e] of this.list)
      e.enabled = !1, e.isDisposeable() && e.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    A.BufferGeometry.prototype.computeBoundsTree = Hh, A.BufferGeometry.prototype.disposeBoundsTree = Wh, A.Mesh.prototype.raycast = Yh;
  }
};
y(sl, "release", "2.4.11");
let nl = sl;
class Su extends io {
  constructor() {
    super(...arguments), y(this, "meshes", /* @__PURE__ */ new Set()), y(this, "onAfterUpdate", new Y()), y(this, "onBeforeUpdate", new Y()), y(this, "onDisposed", new Y()), y(this, "isDisposing", !1), y(this, "enabled", !0), y(this, "uuid", zt.create()), y(this, "name"), y(this, "_scene"), y(this, "_camera"), y(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  /** {@link Disposable.dispose} */
  dispose(t = !0) {
    if (this.enabled = !1, this.isDisposing = !0, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const s = this.components.get(Ot);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const i of this.meshes)
        s.destroy(i);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.components.get(hl).list.delete(this.uuid), this.onDisposed.trigger(), this.onDisposed.reset();
  }
}
class zs {
  constructor(t, e, s, i) {
    y(this, "_component"), y(this, "name"), y(this, "uuid"), this._component = t, this.name = s, this.uuid = i ?? zt.create(), e.get(Yn).list.set(this.uuid, this);
  }
  get controls() {
    return hr.copySchema(this._config);
  }
  set(t) {
    for (const e in t)
      if (e in this) {
        const s = e;
        this[s] = t[e].value;
      }
  }
  export(t = this._config, e = {}) {
    for (const s in t) {
      const i = t[s];
      if (hr.isEntry(i))
        if (i.type === "Color") {
          const { r, g: o, b: a } = i.value;
          e[s] = { ...i, value: { r, g: o, b: a } };
        } else if (i.type === "Vector3") {
          const { x: r, y: o, z: a } = i.value;
          e[s] = { ...i, value: { x: r, y: o, z: a } };
        } else if (i.type === "TextSet") {
          const r = Array.from(i.value);
          e[s] = { ...i, value: r };
        } else if (i.type === "Select") {
          const r = Array.from(i.options);
          e[s] = { ...i, options: r };
        } else
          e[s] = { ...i };
      else
        e[s] = {}, this.export(i, e[s]);
    }
    return e;
  }
  import(t, e = {}, s = !0) {
    for (const i in t) {
      const n = t[i];
      if (hr.isEntry(n))
        if (n.type === "Color") {
          const { r: o, g: a, b: c } = n.value;
          e[i] = { ...n, value: new A.Color(o, a, c) };
        } else if (n.type === "Vector3") {
          const { x: o, y: a, z: c } = n.value;
          e[i] = { ...n, value: new A.Vector3(o, a, c) };
        } else
          n.type === "TextSet" ? e[i] = { ...n, value: new Set(n.value) } : n.type === "Select" ? e[i] = { ...n, options: new Set(n.options) } : e[i] = { ...n };
      else
        e[i] = {}, this.import(n, e[i], !1);
    }
    s && this.set(e);
  }
}
const rl = class ol extends ue {
  constructor(t) {
    super(t), y(this, "list", new mt()), y(this, "enabled", !0), t.add(ol.uuid, this);
  }
};
y(rl, "uuid", "b8c764e0-6b24-4e77-9a32-35fa728ee5b4");
let Yn = rl;
class Au extends Zh {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(t, e, s) {
    super(t), y(this, "enabled", !0), y(this, "container"), y(this, "three"), y(this, "_canvas"), y(this, "_parameters"), y(this, "_resizeObserver", null), y(this, "onContainerUpdated", new Y()), y(this, "_resizing", !1), y(this, "resize", (r) => {
      if (this._resizing)
        return;
      this._resizing = !0, this.onContainerUpdated.trigger();
      const o = r ? r.x : this.container.clientWidth, a = r ? r.y : this.container.clientHeight;
      this.three.setSize(o, a), this.onResize.trigger(new A.Vector2(o, a)), this._resizing = !1;
    }), y(this, "resizeEvent", () => {
      this.resize();
    }), y(this, "onContextLost", (r) => {
      r.preventDefault(), this.enabled = !1;
    }), y(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new A.WebGLRenderer({
        canvas: this._canvas,
        antialias: !0,
        alpha: !0,
        ...this._parameters
      }), this.enabled = !0;
    }), this.container = e, this._parameters = s, this.three = new A.WebGLRenderer({
      antialias: !0,
      alpha: !0,
      ...s
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(!0), this.resize(), this._canvas = this.three.domElement;
    const i = this.three.getContext(), { canvas: n } = i;
    n.addEventListener("webglcontextlost", this.onContextLost, !1), n.addEventListener("webglcontextrestored", this.onContextBack, !1);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.setupEvents(!1), this.three.domElement.remove(), this.three.forceContextLoss(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new A.Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = !0, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const ve = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, j = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), Fs = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function ts(l) {
  return l.isPerspectiveCamera;
}
function Wt(l) {
  return l.isOrthographicCamera;
}
const ws = Math.PI * 2, Yo = Math.PI / 2, al = 1e-5, Js = Math.PI / 180;
function ut(l, t, e) {
  return Math.max(t, Math.min(e, l));
}
function Se(l, t = al) {
  return Math.abs(l) < t;
}
function ge(l, t, e = al) {
  return Se(l - t, e);
}
function Ho(l, t) {
  return Math.round(l / t) * t;
}
function $s(l) {
  return isFinite(l) ? l : l < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function ei(l) {
  return Math.abs(l) < Number.MAX_VALUE ? l : l * (1 / 0);
}
function Ki(l, t, e, s, i = 1 / 0, n) {
  s = Math.max(1e-4, s);
  const r = 2 / s, o = r * n, a = 1 / (1 + o + 0.48 * o * o + 0.235 * o * o * o);
  let c = l - t;
  const h = t, f = i * s;
  c = ut(c, -f, f), t = l - c;
  const u = (e.value + r * c) * n;
  e.value = (e.value - r * u) * a;
  let d = t + (c + u) * a;
  return h - l > 0 == d > h && (d = h, e.value = (d - h) / n), d;
}
function Wo(l, t, e, s, i = 1 / 0, n, r) {
  s = Math.max(1e-4, s);
  const o = 2 / s, a = o * n, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let h = t.x, f = t.y, u = t.z, d = l.x - h, p = l.y - f, m = l.z - u;
  const E = h, I = f, g = u, T = i * s, C = T * T, F = d * d + p * p + m * m;
  if (F > C) {
    const _ = Math.sqrt(F);
    d = d / _ * T, p = p / _ * T, m = m / _ * T;
  }
  h = l.x - d, f = l.y - p, u = l.z - m;
  const O = (e.x + o * d) * n, P = (e.y + o * p) * n, M = (e.z + o * m) * n;
  e.x = (e.x - o * O) * c, e.y = (e.y - o * P) * c, e.z = (e.z - o * M) * c, r.x = h + (d + O) * c, r.y = f + (p + P) * c, r.z = u + (m + M) * c;
  const L = E - l.x, b = I - l.y, B = g - l.z, v = r.x - E, D = r.y - I, R = r.z - g;
  return L * v + b * D + B * R > 0 && (r.x = E, r.y = I, r.z = g, e.x = (r.x - E) / n, e.y = (r.y - I) / n, e.z = (r.z - g) / n), r;
}
function dr(l, t) {
  t.set(0, 0), l.forEach((e) => {
    t.x += e.clientX, t.y += e.clientY;
  }), t.x /= l.length, t.y /= l.length;
}
function pr(l, t) {
  return Wt(l) ? (console.warn(`${t} is not supported in OrthographicCamera`), !0) : !1;
}
class Fu {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    const s = this._listeners;
    s[t] === void 0 && (s[t] = []), s[t].indexOf(e) === -1 && s[t].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(t, e) {
    const s = this._listeners;
    return s[t] !== void 0 && s[t].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    const i = this._listeners[t];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(t) {
    if (!t) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(t) {
    const s = this._listeners[t.type];
    if (s !== void 0) {
      t.target = this;
      const i = s.slice(0);
      for (let n = 0, r = i.length; n < r; n++)
        i[n].call(this, t);
    }
  }
}
var mr;
const wu = "2.9.0", qi = 1 / 8, vu = /Mac/.test((mr = globalThis == null ? void 0 : globalThis.navigator) === null || mr === void 0 ? void 0 : mr.platform);
let he, Xo, Ji, Ir, Qe, de, Ee, vs, ti, Ct, Tt, ss, Zo, jo, it, si, Os, Qo, Er, Ko, gr, Cr, $i;
class De extends Fu {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(t) {
    he = t.THREE, Xo = Object.freeze(new he.Vector3(0, 0, 0)), Ji = Object.freeze(new he.Vector3(0, 1, 0)), Ir = Object.freeze(new he.Vector3(0, 0, 1)), Qe = new he.Vector2(), de = new he.Vector3(), Ee = new he.Vector3(), vs = new he.Vector3(), ti = new he.Vector3(), Ct = new he.Vector3(), Tt = new he.Vector3(), ss = new he.Vector3(), Zo = new he.Vector3(), jo = new he.Vector3(), it = new he.Spherical(), si = new he.Spherical(), Os = new he.Box3(), Qo = new he.Box3(), Er = new he.Sphere(), Ko = new he.Quaternion(), gr = new he.Quaternion(), Cr = new he.Matrix4(), $i = new he.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return j;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(t, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = j.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = Fs.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new he.Vector3(), this._focalOffsetVelocity = new he.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (I, g, T) => {
      let C, F;
      if (ts(this._camera)) {
        const O = de.copy(this._camera.position).sub(this._target), P = this._camera.getEffectiveFOV() * Js, M = O.length() * Math.tan(P * 0.5);
        C = this.truckSpeed * I * M / this._elementRect.height, F = this.truckSpeed * g * M / this._elementRect.height;
      } else if (Wt(this._camera)) {
        const O = this._camera;
        C = I * (O.right - O.left) / O.zoom / this._elementRect.width, F = g * (O.top - O.bottom) / O.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (T ? this.setFocalOffset(this._focalOffsetEnd.x + C, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(C, 0, !0), this.forward(-F, !0)) : T ? this.setFocalOffset(this._focalOffsetEnd.x + C, this._focalOffsetEnd.y + F, this._focalOffsetEnd.z, !0) : this.truck(C, F, !0);
    }, this._rotateInternal = (I, g) => {
      const T = ws * this.azimuthRotateSpeed * I / this._elementRect.height, C = ws * this.polarRotateSpeed * g / this._elementRect.height;
      this.rotate(T, C, !0);
    }, this._dollyInternal = (I, g, T) => {
      const C = Math.pow(0.95, -I * this.dollySpeed), F = this._sphericalEnd.radius, O = this._sphericalEnd.radius * C, P = ut(O, this.minDistance, this.maxDistance), M = P - O;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(O, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(M, !0), this._dollyToNoClamp(P, !0)) : this._dollyToNoClamp(P, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? O : P) - F, this._dollyControlCoord.set(g, T)), this._lastDollyDirection = Math.sign(-I);
    }, this._zoomInternal = (I, g, T) => {
      const C = Math.pow(0.95, I * this.dollySpeed), F = this._zoom, O = this._zoom * C;
      this.zoomTo(O, !0), this.dollyToCursor && (this._changedZoom += O - F, this._dollyControlCoord.set(g, T));
    }, typeof he > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new he.Quaternion().setFromUnitVectors(this._camera.up, Ji), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = j.NONE, this._target = new he.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new he.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new he.Spherical().setFromVector3(de.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new he.Vector3(),
      new he.Vector3(),
      new he.Vector3(),
      new he.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new he.Box3(new he.Vector3(-1 / 0, -1 / 0, -1 / 0), new he.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new he.Vector2(), this.mouseButtons = {
      left: j.ROTATE,
      middle: j.DOLLY,
      right: j.TRUCK,
      wheel: ts(this._camera) ? j.DOLLY : Wt(this._camera) ? j.ZOOM : j.NONE
    }, this.touches = {
      one: j.TOUCH_ROTATE,
      two: ts(this._camera) ? j.TOUCH_DOLLY_TRUCK : Wt(this._camera) ? j.TOUCH_ZOOM_TRUCK : j.NONE,
      three: j.TOUCH_TRUCK
    };
    const s = new he.Vector2(), i = new he.Vector2(), n = new he.Vector2(), r = (I) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const C = this._domElement.getBoundingClientRect(), F = I.clientX / C.width, O = I.clientY / C.height;
        if (F < this._interactiveArea.left || F > this._interactiveArea.right || O < this._interactiveArea.top || O > this._interactiveArea.bottom)
          return;
      }
      const g = I.pointerType !== "mouse" ? null : (I.buttons & ve.LEFT) === ve.LEFT ? ve.LEFT : (I.buttons & ve.MIDDLE) === ve.MIDDLE ? ve.MIDDLE : (I.buttons & ve.RIGHT) === ve.RIGHT ? ve.RIGHT : null;
      if (g !== null) {
        const C = this._findPointerByMouseButton(g);
        C && this._disposePointer(C);
      }
      if ((I.buttons & ve.LEFT) === ve.LEFT && this._lockedPointer)
        return;
      const T = {
        pointerId: I.pointerId,
        clientX: I.clientX,
        clientY: I.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: g
      };
      this._activePointers.push(T), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.ownerDocument.addEventListener("pointermove", o, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", a), this._isDragging = !0, u(I);
    }, o = (I) => {
      I.cancelable && I.preventDefault();
      const g = I.pointerId, T = this._lockedPointer || this._findPointerById(g);
      if (T) {
        if (T.clientX = I.clientX, T.clientY = I.clientY, T.deltaX = I.movementX, T.deltaY = I.movementY, this._state = 0, I.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (I.buttons & ve.LEFT) === ve.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (I.buttons & ve.MIDDLE) === ve.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (I.buttons & ve.RIGHT) === ve.RIGHT && (this._state = this._state | this.mouseButtons.right);
        d();
      }
    }, a = (I) => {
      const g = this._findPointerById(I.pointerId);
      if (!(g && g === this._lockedPointer)) {
        if (g && this._disposePointer(g), I.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = j.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = j.NONE;
        p();
      }
    };
    let c = -1;
    const h = (I) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === j.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const O = this._domElement.getBoundingClientRect(), P = I.clientX / O.width, M = I.clientY / O.height;
        if (P < this._interactiveArea.left || P > this._interactiveArea.right || M < this._interactiveArea.top || M > this._interactiveArea.bottom)
          return;
      }
      if (I.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === j.ROTATE || this.mouseButtons.wheel === j.TRUCK) {
        const O = performance.now();
        c - O < 1e3 && this._getClientRect(this._elementRect), c = O;
      }
      const g = vu ? -1 : -3, T = I.deltaMode === 1 ? I.deltaY / g : I.deltaY / (g * 10), C = this.dollyToCursor ? (I.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, F = this.dollyToCursor ? (I.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case j.ROTATE: {
          this._rotateInternal(I.deltaX, I.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case j.TRUCK: {
          this._truckInternal(I.deltaX, I.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case j.OFFSET: {
          this._truckInternal(I.deltaX, I.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case j.DOLLY: {
          this._dollyInternal(-T, C, F), this._isUserControllingDolly = !0;
          break;
        }
        case j.ZOOM: {
          this._zoomInternal(-T, C, F), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, f = (I) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === De.ACTION.NONE) {
          const g = I instanceof PointerEvent ? I.pointerId : 0, T = this._findPointerById(g);
          T && this._disposePointer(T), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", a);
          return;
        }
        I.preventDefault();
      }
    }, u = (I) => {
      if (!this._enabled)
        return;
      if (dr(this._activePointers, Qe), this._getClientRect(this._elementRect), s.copy(Qe), i.copy(Qe), this._activePointers.length >= 2) {
        const T = Qe.x - this._activePointers[1].clientX, C = Qe.y - this._activePointers[1].clientY, F = Math.sqrt(T * T + C * C);
        n.set(0, F);
        const O = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, P = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(O, P);
      }
      if (this._state = 0, !I)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in I && I.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (I.buttons & ve.LEFT) === ve.LEFT && (this._state = this._state | this.mouseButtons.left), (I.buttons & ve.MIDDLE) === ve.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (I.buttons & ve.RIGHT) === ve.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & j.ROTATE) === j.ROTATE || (this._state & j.TOUCH_ROTATE) === j.TOUCH_ROTATE || (this._state & j.TOUCH_DOLLY_ROTATE) === j.TOUCH_DOLLY_ROTATE || (this._state & j.TOUCH_ZOOM_ROTATE) === j.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & j.TRUCK) === j.TRUCK || (this._state & j.TOUCH_TRUCK) === j.TOUCH_TRUCK || (this._state & j.TOUCH_DOLLY_TRUCK) === j.TOUCH_DOLLY_TRUCK || (this._state & j.TOUCH_ZOOM_TRUCK) === j.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & j.DOLLY) === j.DOLLY || (this._state & j.TOUCH_DOLLY) === j.TOUCH_DOLLY || (this._state & j.TOUCH_DOLLY_TRUCK) === j.TOUCH_DOLLY_TRUCK || (this._state & j.TOUCH_DOLLY_OFFSET) === j.TOUCH_DOLLY_OFFSET || (this._state & j.TOUCH_DOLLY_ROTATE) === j.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & j.ZOOM) === j.ZOOM || (this._state & j.TOUCH_ZOOM) === j.TOUCH_ZOOM || (this._state & j.TOUCH_ZOOM_TRUCK) === j.TOUCH_ZOOM_TRUCK || (this._state & j.TOUCH_ZOOM_OFFSET) === j.TOUCH_ZOOM_OFFSET || (this._state & j.TOUCH_ZOOM_ROTATE) === j.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & j.OFFSET) === j.OFFSET || (this._state & j.TOUCH_OFFSET) === j.TOUCH_OFFSET || (this._state & j.TOUCH_DOLLY_OFFSET) === j.TOUCH_DOLLY_OFFSET || (this._state & j.TOUCH_ZOOM_OFFSET) === j.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, d = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, dr(this._activePointers, Qe);
      const g = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, T = g ? -g.deltaX : i.x - Qe.x, C = g ? -g.deltaY : i.y - Qe.y;
      if (i.copy(Qe), ((this._state & j.ROTATE) === j.ROTATE || (this._state & j.TOUCH_ROTATE) === j.TOUCH_ROTATE || (this._state & j.TOUCH_DOLLY_ROTATE) === j.TOUCH_DOLLY_ROTATE || (this._state & j.TOUCH_ZOOM_ROTATE) === j.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(T, C), this._isUserControllingRotate = !0), (this._state & j.DOLLY) === j.DOLLY || (this._state & j.ZOOM) === j.ZOOM) {
        const F = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, O = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, P = this.dollyDragInverted ? -1 : 1;
        (this._state & j.DOLLY) === j.DOLLY ? (this._dollyInternal(P * C * qi, F, O), this._isUserControllingDolly = !0) : (this._zoomInternal(P * C * qi, F, O), this._isUserControllingZoom = !0);
      }
      if ((this._state & j.TOUCH_DOLLY) === j.TOUCH_DOLLY || (this._state & j.TOUCH_ZOOM) === j.TOUCH_ZOOM || (this._state & j.TOUCH_DOLLY_TRUCK) === j.TOUCH_DOLLY_TRUCK || (this._state & j.TOUCH_ZOOM_TRUCK) === j.TOUCH_ZOOM_TRUCK || (this._state & j.TOUCH_DOLLY_OFFSET) === j.TOUCH_DOLLY_OFFSET || (this._state & j.TOUCH_ZOOM_OFFSET) === j.TOUCH_ZOOM_OFFSET || (this._state & j.TOUCH_DOLLY_ROTATE) === j.TOUCH_DOLLY_ROTATE || (this._state & j.TOUCH_ZOOM_ROTATE) === j.TOUCH_ZOOM_ROTATE) {
        const F = Qe.x - this._activePointers[1].clientX, O = Qe.y - this._activePointers[1].clientY, P = Math.sqrt(F * F + O * O), M = n.y - P;
        n.set(0, P);
        const L = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, b = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & j.TOUCH_DOLLY) === j.TOUCH_DOLLY || (this._state & j.TOUCH_DOLLY_ROTATE) === j.TOUCH_DOLLY_ROTATE || (this._state & j.TOUCH_DOLLY_TRUCK) === j.TOUCH_DOLLY_TRUCK || (this._state & j.TOUCH_DOLLY_OFFSET) === j.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(M * qi, L, b), this._isUserControllingDolly = !0) : (this._zoomInternal(M * qi, L, b), this._isUserControllingZoom = !0);
      }
      ((this._state & j.TRUCK) === j.TRUCK || (this._state & j.TOUCH_TRUCK) === j.TOUCH_TRUCK || (this._state & j.TOUCH_DOLLY_TRUCK) === j.TOUCH_DOLLY_TRUCK || (this._state & j.TOUCH_ZOOM_TRUCK) === j.TOUCH_ZOOM_TRUCK) && (this._truckInternal(T, C, !1), this._isUserControllingTruck = !0), ((this._state & j.OFFSET) === j.OFFSET || (this._state & j.TOUCH_OFFSET) === j.TOUCH_OFFSET || (this._state & j.TOUCH_DOLLY_OFFSET) === j.TOUCH_DOLLY_OFFSET || (this._state & j.TOUCH_ZOOM_OFFSET) === j.TOUCH_ZOOM_OFFSET) && (this._truckInternal(T, C, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, p = () => {
      dr(this._activePointers, Qe), i.copy(Qe), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", m), this._domElement.ownerDocument.addEventListener("pointerlockerror", E), this._domElement.ownerDocument.addEventListener("pointermove", o, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", a), u());
    }, this.unlockPointer = () => {
      var I, g, T;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (I = this._domElement) === null || I === void 0 || I.ownerDocument.exitPointerLock(), (g = this._domElement) === null || g === void 0 || g.ownerDocument.removeEventListener("pointerlockchange", m), (T = this._domElement) === null || T === void 0 || T.ownerDocument.removeEventListener("pointerlockerror", E), this.cancel();
    };
    const m = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, E = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (I) => {
      this._domElement = I, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), this._domElement.addEventListener("pointercancel", a), this._domElement.addEventListener("wheel", h, { passive: !1 }), this._domElement.addEventListener("contextmenu", f);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("pointercancel", a), this._domElement.removeEventListener("wheel", h, { passive: !1 }), this._domElement.removeEventListener("contextmenu", f), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.ownerDocument.removeEventListener("pointerlockchange", m), this._domElement.ownerDocument.removeEventListener("pointerlockerror", E));
    }, this.cancel = () => {
      this._state !== j.NONE && (this._state = j.NONE, this._activePointers.length = 0, p());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this._domElement && (t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(t) {
    this._interactiveArea.width = ut(t.width, 0, 1), this._interactiveArea.height = ut(t.height, 0, 1), this._interactiveArea.x = ut(t.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = ut(t.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    super.addEventListener(t, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    super.removeEventListener(t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(t, e, s = !1) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, s);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(t, e = !1) {
    return this.rotateTo(t, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(t, e = !1) {
    return this.rotateTo(this._sphericalEnd.theta, t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(t, e, s = !1) {
    this._isUserControllingRotate = !1;
    const i = ut(t, this.minAzimuthAngle, this.maxAzimuthAngle), n = ut(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = n, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, s || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !s || ge(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ge(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(t, e = !1) {
    return this.dollyTo(this._sphericalEnd.radius - t, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(t, e = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = Fs.NONE, this._changedDolly = 0, this._dollyToNoClamp(ut(t, this.minDistance, this.maxDistance), e);
  }
  _dollyToNoClamp(t, e = !1) {
    const s = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const r = this._collisionTest(), o = ge(r, this._spherical.radius);
      if (!(s > t) && o)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(t, r);
    } else
      this._sphericalEnd.radius = t;
    this._needsUpdate = !0, e || (this._spherical.radius = this._sphericalEnd.radius);
    const n = !e || ge(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(t, e = !1) {
    this._targetEnd.add(this._getCameraDirection(ti).multiplyScalar(t)), e || this._target.copy(this._targetEnd);
    const s = !e || ge(this._target.x, this._targetEnd.x, this.restThreshold) && ge(this._target.y, this._targetEnd.y, this.restThreshold) && ge(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(t, e = !1) {
    return this.zoomTo(this._zoomEnd + t, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(t, e = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = ut(t, this.minZoom, this.maxZoom), this._needsUpdate = !0, e || (this._zoom = this._zoomEnd);
    const s = !e || ge(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(s);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(t, e, s = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, s);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(t, e, s = !1) {
    this._camera.updateMatrix(), Ct.setFromMatrixColumn(this._camera.matrix, 0), Tt.setFromMatrixColumn(this._camera.matrix, 1), Ct.multiplyScalar(t), Tt.multiplyScalar(-e);
    const i = de.copy(Ct).add(Tt), n = Ee.copy(this._targetEnd).add(i);
    return this.moveTo(n.x, n.y, n.z, s);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(t, e = !1) {
    de.setFromMatrixColumn(this._camera.matrix, 0), de.crossVectors(this._camera.up, de), de.multiplyScalar(t);
    const s = Ee.copy(this._targetEnd).add(de);
    return this.moveTo(s.x, s.y, s.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(t, e = !1) {
    return de.copy(this._camera.up).multiplyScalar(t), this.moveTo(this._targetEnd.x + de.x, this._targetEnd.y + de.y, this._targetEnd.z + de.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(t, e, s, i = !1) {
    this._isUserControllingTruck = !1;
    const n = de.set(t, e, s).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, n, this.boundaryFriction), this._needsUpdate = !0, i || this._target.copy(this._targetEnd);
    const r = !i || ge(this._target.x, this._targetEnd.x, this.restThreshold) && ge(this._target.y, this._targetEnd.y, this.restThreshold) && ge(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(t, e, s, i = !1) {
    const o = de.set(t, e, s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(o.x, o.y, o.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(t, e, { cover: s = !1, paddingLeft: i = 0, paddingRight: n = 0, paddingBottom: r = 0, paddingTop: o = 0 } = {}) {
    const a = [], c = t.isBox3 ? Os.copy(t) : Os.setFromObject(t);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const h = Ho(this._sphericalEnd.theta, Yo), f = Ho(this._sphericalEnd.phi, Yo);
    a.push(this.rotateTo(h, f, e));
    const u = de.setFromSpherical(this._sphericalEnd).normalize(), d = Ko.setFromUnitVectors(u, Ir), p = ge(Math.abs(u.y), 1);
    p && d.multiply(gr.setFromAxisAngle(Ji, h)), d.multiply(this._yAxisUpSpaceInverse);
    const m = Qo.makeEmpty();
    Ee.copy(c.min).applyQuaternion(d), m.expandByPoint(Ee), Ee.copy(c.min).setX(c.max.x).applyQuaternion(d), m.expandByPoint(Ee), Ee.copy(c.min).setY(c.max.y).applyQuaternion(d), m.expandByPoint(Ee), Ee.copy(c.max).setZ(c.min.z).applyQuaternion(d), m.expandByPoint(Ee), Ee.copy(c.min).setZ(c.max.z).applyQuaternion(d), m.expandByPoint(Ee), Ee.copy(c.max).setY(c.min.y).applyQuaternion(d), m.expandByPoint(Ee), Ee.copy(c.max).setX(c.min.x).applyQuaternion(d), m.expandByPoint(Ee), Ee.copy(c.max).applyQuaternion(d), m.expandByPoint(Ee), m.min.x -= i, m.min.y -= r, m.max.x += n, m.max.y += o, d.setFromUnitVectors(Ir, u), p && d.premultiply(gr.invert()), d.premultiply(this._yAxisUpSpace);
    const E = m.getSize(de), I = m.getCenter(Ee).applyQuaternion(d);
    if (ts(this._camera)) {
      const g = this.getDistanceToFitBox(E.x, E.y, E.z, s);
      a.push(this.moveTo(I.x, I.y, I.z, e)), a.push(this.dollyTo(g, e)), a.push(this.setFocalOffset(0, 0, 0, e));
    } else if (Wt(this._camera)) {
      const g = this._camera, T = g.right - g.left, C = g.top - g.bottom, F = s ? Math.max(T / E.x, C / E.y) : Math.min(T / E.x, C / E.y);
      a.push(this.moveTo(I.x, I.y, I.z, e)), a.push(this.zoomTo(F, e)), a.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(t, e) {
    const s = [], n = "isObject3D" in t ? De.createBoundingSphere(t, Er) : Er.copy(t);
    if (s.push(this.moveTo(n.center.x, n.center.y, n.center.z, e)), ts(this._camera)) {
      const r = this.getDistanceToFitSphere(n.radius);
      s.push(this.dollyTo(r, e));
    } else if (Wt(this._camera)) {
      const r = this._camera.right - this._camera.left, o = this._camera.top - this._camera.bottom, a = 2 * n.radius, c = Math.min(r / a, o / a);
      s.push(this.zoomTo(c, e));
    }
    return s.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(s);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(t, e, s, i, n, r, o = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Fs.NONE, this._changedDolly = 0;
    const a = Ee.set(i, n, r), c = de.set(t, e, s);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(c.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, o || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !o || ge(this._target.x, this._targetEnd.x, this.restThreshold) && ge(this._target.y, this._targetEnd.y, this.restThreshold) && ge(this._target.z, this._targetEnd.z, this.restThreshold) && ge(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ge(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ge(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(t, e, s, i, n, r, o, a, c, h, f, u, d, p = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Fs.NONE, this._changedDolly = 0;
    const m = de.set(i, n, r), E = Ee.set(t, e, s);
    it.setFromVector3(E.sub(m).applyQuaternion(this._yAxisUpSpace));
    const I = vs.set(h, f, u), g = Ee.set(o, a, c);
    si.setFromVector3(g.sub(I).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(m.lerp(I, d));
    const T = si.theta - it.theta, C = si.phi - it.phi, F = si.radius - it.radius;
    this._sphericalEnd.set(it.radius + F * d, it.phi + C * d, it.theta + T * d), this.normalizeRotations(), this._needsUpdate = !0, p || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const O = !p || ge(this._target.x, this._targetEnd.x, this.restThreshold) && ge(this._target.y, this._targetEnd.y, this.restThreshold) && ge(this._target.z, this._targetEnd.z, this.restThreshold) && ge(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ge(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ge(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(O);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(t, e, s, i = !1) {
    return this.setLookAt(t, e, s, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(t, e, s, i = !1) {
    const n = this.getPosition(de), r = this.setLookAt(n.x, n.y, n.z, t, e, s, i);
    return this._sphericalEnd.phi = ut(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(t, e, s, i = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(t, e, s), this._needsUpdate = !0, i || this._focalOffset.copy(this._focalOffsetEnd);
    const n = !i || ge(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && ge(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && ge(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(t, e, s) {
    this._camera.updateMatrixWorld(), Ct.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Tt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), ss.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = de.set(t, e, s), n = i.distanceTo(this._camera.position), r = i.sub(this._camera.position);
    Ct.multiplyScalar(r.x), Tt.multiplyScalar(r.y), ss.multiplyScalar(r.z), de.copy(Ct).add(Tt).add(ss), de.z = de.z + n, this.dollyTo(n, !1), this.setFocalOffset(-de.x, de.y, -de.z, !1), this.moveTo(t, e, s, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(t) {
    if (!t) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(t, e, s, i) {
    if (t === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new he.Vector4(), typeof t == "number" ? this._viewport.set(t, e, s, i) : this._viewport.copy(t);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(t, e, s, i = !1) {
    if (pr(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const n = t / e, r = this._camera.getEffectiveFOV() * Js, o = this._camera.aspect;
    return ((i ? n > o : n < o) ? e : t / o) * 0.5 / Math.tan(r * 0.5) + s * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(t) {
    if (pr(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * Js, s = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? e : s;
    return t / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(t, e = !0) {
    return (t && t.isVector3 ? t : new he.Vector3()).copy(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(t, e = !0) {
    return (t && t.isVector3 ? t : new he.Vector3()).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(t, e = !0) {
    return (t || new he.Spherical()).copy(e ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(t, e = !0) {
    return (t && t.isVector3 ? t : new he.Vector3()).copy(e ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % ws, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += ws), this._spherical.theta += ws * Math.round((this._sphericalEnd.theta - this._spherical.theta) / ws);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(t = !1) {
    if (!ge(this._camera.up.x, this._cameraUp0.x) || !ge(this._camera.up.y, this._cameraUp0.y) || !ge(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const s = this.getPosition(de);
      this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t),
      this.zoomTo(this._zoom0, t)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Ji), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const t = de.subVectors(this._target, this._camera.position).normalize(), e = Ee.crossVectors(t, this._camera.up);
    this._camera.up.crossVectors(e, t).normalize(), this._camera.updateMatrixWorld();
    const s = this.getPosition(de);
    this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(t) {
    const e = this._sphericalEnd.theta - this._spherical.theta, s = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, n = Zo.subVectors(this._targetEnd, this._target), r = jo.subVectors(this._focalOffsetEnd, this._focalOffset), o = this._zoomEnd - this._zoom;
    if (Se(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const f = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Ki(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, f, 1 / 0, t), this._needsUpdate = !0;
    }
    if (Se(s))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const f = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Ki(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, f, 1 / 0, t), this._needsUpdate = !0;
    }
    if (Se(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const f = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Ki(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, f, this.maxSpeed, t), this._needsUpdate = !0;
    }
    if (Se(n.x) && Se(n.y) && Se(n.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const f = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      Wo(this._target, this._targetEnd, this._targetVelocity, f, this.maxSpeed, t, this._target), this._needsUpdate = !0;
    }
    if (Se(r.x) && Se(r.y) && Se(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const f = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      Wo(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, f, this.maxSpeed, t, this._focalOffset), this._needsUpdate = !0;
    }
    if (Se(o))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const f = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Ki(this._zoom, this._zoomEnd, this._zoomVelocity, f, 1 / 0, t);
    }
    if (this.dollyToCursor) {
      if (ts(this._camera) && this._changedDolly !== 0) {
        const f = this._spherical.radius - this._lastDistance, u = this._camera, d = this._getCameraDirection(ti), p = de.copy(d).cross(u.up).normalize();
        p.lengthSq() === 0 && (p.x = 1);
        const m = Ee.crossVectors(p, d), E = this._sphericalEnd.radius * Math.tan(u.getEffectiveFOV() * Js * 0.5), g = (this._sphericalEnd.radius - f - this._sphericalEnd.radius) / this._sphericalEnd.radius, T = vs.copy(this._targetEnd).add(p.multiplyScalar(this._dollyControlCoord.x * E * u.aspect)).add(m.multiplyScalar(this._dollyControlCoord.y * E)), C = de.copy(this._targetEnd).lerp(T, g), F = this._lastDollyDirection === Fs.IN && this._spherical.radius <= this.minDistance, O = this._lastDollyDirection === Fs.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (F || O)) {
          this._sphericalEnd.radius -= f, this._spherical.radius -= f;
          const M = Ee.copy(d).multiplyScalar(-f);
          C.add(M);
        }
        this._boundary.clampPoint(C, C);
        const P = Ee.subVectors(C, this._targetEnd);
        this._targetEnd.copy(C), this._target.add(P), this._changedDolly -= f, Se(this._changedDolly) && (this._changedDolly = 0);
      } else if (Wt(this._camera) && this._changedZoom !== 0) {
        const f = this._zoom - this._lastZoom, u = this._camera, d = de.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (u.near + u.far) / (u.near - u.far)).unproject(u), p = Ee.set(0, 0, -1).applyQuaternion(u.quaternion), m = vs.copy(d).add(p.multiplyScalar(-d.dot(u.up))), I = -(this._zoom - f - this._zoom) / this._zoom, g = this._getCameraDirection(ti), T = this._targetEnd.dot(g), C = de.copy(this._targetEnd).lerp(m, I), F = C.dot(g), O = g.multiplyScalar(F - T);
        C.sub(O), this._boundary.clampPoint(C, C);
        const P = Ee.subVectors(C, this._targetEnd);
        this._targetEnd.copy(C), this._target.add(P), this._changedZoom -= f, Se(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Se(this._focalOffset.x) || !Se(this._focalOffset.y) || !Se(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Ct.setFromMatrixColumn(this._camera.matrix, 0), Tt.setFromMatrixColumn(this._camera.matrix, 1), ss.setFromMatrixColumn(this._camera.matrix, 2), Ct.multiplyScalar(this._focalOffset.x), Tt.multiplyScalar(-this._focalOffset.y), ss.multiplyScalar(this._focalOffset.z), de.copy(Ct).add(Tt).add(ss), this._camera.position.add(de)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), de.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), Se(e, this.restThreshold) && Se(s, this.restThreshold) && Se(i, this.restThreshold) && Se(n.x, this.restThreshold) && Se(n.y, this.restThreshold) && Se(n.z, this.restThreshold) && Se(r.x, this.restThreshold) && Se(r.y, this.restThreshold) && Se(r.z, this.restThreshold) && Se(o, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = !1, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: $s(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: $s(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: $s(this.maxPolarAngle),
      minAzimuthAngle: $s(this.minAzimuthAngle),
      maxAzimuthAngle: $s(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: de.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(t, e = !1) {
    const s = JSON.parse(t);
    this.enabled = s.enabled, this.minDistance = s.minDistance, this.maxDistance = ei(s.maxDistance), this.minZoom = s.minZoom, this.maxZoom = ei(s.maxZoom), this.minPolarAngle = s.minPolarAngle, this.maxPolarAngle = ei(s.maxPolarAngle), this.minAzimuthAngle = ei(s.minAzimuthAngle), this.maxAzimuthAngle = ei(s.maxAzimuthAngle), this.smoothTime = s.smoothTime, this.draggingSmoothTime = s.draggingSmoothTime, this.dollySpeed = s.dollySpeed, this.truckSpeed = s.truckSpeed, this.dollyToCursor = s.dollyToCursor, this.verticalDragToForward = s.verticalDragToForward, this._target0.fromArray(s.target0), this._position0.fromArray(s.position0), this._zoom0 = s.zoom0, this._focalOffset0.fromArray(s.focalOffset0), this.moveTo(s.target[0], s.target[1], s.target[2], e), it.setFromVector3(de.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(it.theta, it.phi, e), this.dollyTo(it.radius, e), this.zoomTo(s.zoom, e), this.setFocalOffset(s.focalOffset[0], s.focalOffset[1], s.focalOffset[2], e), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(t) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t.setAttribute("data-camera-controls-version", wu), this._addAllEventListeners(t), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(t) {
    return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(t) {
    return this._getTargetDirection(t).negate();
  }
  _findPointerById(t) {
    return this._activePointers.find((e) => e.pointerId === t);
  }
  _findPointerByMouseButton(t) {
    return this._activePointers.find((e) => e.mouseButton === t);
  }
  _disposePointer(t) {
    this._activePointers.splice(this._activePointers.indexOf(t), 1);
  }
  _encloseToBoundary(t, e, s) {
    const i = e.lengthSq();
    if (i === 0)
      return t;
    const n = Ee.copy(e).add(t), o = this._boundary.clampPoint(n, vs).sub(n), a = o.lengthSq();
    if (a === 0)
      return t.add(e);
    if (a === i)
      return t;
    if (s === 0)
      return t.add(e).add(o);
    {
      const c = 1 + s * a / e.dot(o);
      return t.add(Ee.copy(e).multiplyScalar(c)).add(o.multiplyScalar(1 - s));
    }
  }
  _updateNearPlaneCorners() {
    if (ts(this._camera)) {
      const t = this._camera, e = t.near, s = t.getEffectiveFOV() * Js, i = Math.tan(s * 0.5) * e, n = i * t.aspect;
      this._nearPlaneCorners[0].set(-n, -i, 0), this._nearPlaneCorners[1].set(n, -i, 0), this._nearPlaneCorners[2].set(n, i, 0), this._nearPlaneCorners[3].set(-n, i, 0);
    } else if (Wt(this._camera)) {
      const t = this._camera, e = 1 / t.zoom, s = t.left * e, i = t.right * e, n = t.top * e, r = t.bottom * e;
      this._nearPlaneCorners[0].set(s, n, 0), this._nearPlaneCorners[1].set(i, n, 0), this._nearPlaneCorners[2].set(i, r, 0), this._nearPlaneCorners[3].set(s, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || pr(this._camera, "_collisionTest"))
      return t;
    const s = this._getTargetDirection(ti);
    Cr.lookAt(Xo, s, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const n = Ee.copy(this._nearPlaneCorners[i]);
      n.applyMatrix4(Cr);
      const r = vs.addVectors(this._target, n);
      $i.set(r, s), $i.far = this._spherical.radius + 1;
      const o = $i.intersectObjects(this.colliderMeshes);
      o.length !== 0 && o[0].distance < t && (t = o[0].distance);
    }
    return t;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(t) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const s = () => {
        this.removeEventListener("rest", s), e();
      };
      this.addEventListener("rest", s);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(t) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(t) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(t, e = new he.Sphere()) {
    const s = e, i = s.center;
    Os.makeEmpty(), t.traverseVisible((r) => {
      r.isMesh && Os.expandByObject(r);
    }), Os.getCenter(i);
    let n = 0;
    return t.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const o = r, a = o.geometry.clone();
      a.applyMatrix4(o.matrixWorld);
      const h = a.attributes.position;
      for (let f = 0, u = h.count; f < u; f++)
        de.fromBufferAttribute(h, f), n = Math.max(n, i.distanceToSquared(de));
    }), s.radius = Math.sqrt(n), s;
  }
}
class Ti extends Xh {
  constructor(t) {
    super(t), y(this, "onBeforeUpdate", new Y()), y(this, "onAfterUpdate", new Y()), y(this, "onAspectUpdated", new Y()), y(this, "onDisposed", new Y()), y(this, "three"), y(this, "_allControls", /* @__PURE__ */ new Map()), y(this, "updateAspect", () => {
      var e;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof A.OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((e = this.currentWorld.renderer) != null && e.isResizeable()) {
          const s = this.currentWorld.renderer.getSize();
          this.three.aspect = s.width / s.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    }), this.three = this.setupCamera(), this.setupEvents(!0), this.onWorldChanged.add(({ action: e, world: s }) => {
      if (e === "added") {
        const i = this.newCameraControls();
        this._allControls.set(s.uuid, i);
      }
      if (e === "removed") {
        const i = this._allControls.get(s.uuid);
        i && (i.dispose(), this._allControls.delete(s.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    return this.currentWorld === null ? !1 : this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(t) {
    this.currentWorld !== null && (this.controls.enabled = t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new A.PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new A.Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    De.install({ THREE: Ti.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new De(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = !0, e.infinityDolly = !0, e.minDistance = 6, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE: A.MOUSE,
      Vector2: A.Vector2,
      Vector3: A.Vector3,
      Vector4: A.Vector4,
      Quaternion: A.Quaternion,
      Matrix4: A.Matrix4,
      Spherical: A.Spherical,
      Box3: A.Box3,
      Sphere: A.Sphere,
      Raycaster: A.Raycaster,
      MathUtils: A.MathUtils
    };
  }
}
const ll = class cl extends ue {
  constructor(t) {
    super(t), y(this, "onAfterUpdate", new Y()), y(this, "onBeforeUpdate", new Y()), y(this, "onDisposed", new Y()), y(this, "list", new mt()), y(this, "enabled", !0), t.add(cl.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new Su(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), t;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   */
  delete(t) {
    if (!this.list.has(t.uuid))
      throw new Error("The provided world is not found in the list!");
    this.list.delete(t.uuid), t.dispose();
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   */
  dispose() {
    this.enabled = !1;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(t) {
    if (this.enabled)
      for (const [e, s] of this.list)
        s.update(t);
  }
};
y(ll, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
let hl = ll;
function Ou(l, t, e, s) {
  return new Promise((i, n) => {
    function r() {
      const o = l.clientWaitSync(t, e, 0);
      if (o === l.WAIT_FAILED) {
        n();
        return;
      }
      if (o === l.TIMEOUT_EXPIRED) {
        setTimeout(r, s);
        return;
      }
      i();
    }
    r();
  });
}
async function Pu(l, t, e, s, i, n, r) {
  const o = l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE, 0);
  l.flush(), await Ou(l, o, 0, 10), l.deleteSync(o), l.bindBuffer(t, e), l.getBufferSubData(t, s, i, n, r), l.bindBuffer(t, null);
}
async function Nu(l, t, e, s, i, n, r, o) {
  const a = l.createBuffer();
  return l.bindBuffer(l.PIXEL_PACK_BUFFER, a), l.bufferData(l.PIXEL_PACK_BUFFER, o.byteLength, l.STREAM_READ), l.readPixels(t, e, s, i, n, r, 0), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), await Pu(l, l.PIXEL_PACK_BUFFER, a, 0, o), l.deleteBuffer(a), o;
}
class xu extends zs {
  constructor() {
    super(...arguments), y(this, "_config", {
      enabled: {
        value: !0,
        type: "Boolean"
      },
      width: {
        type: "Number",
        interpolable: !0,
        value: 512,
        min: 32,
        max: 1024
      },
      height: {
        type: "Number",
        interpolable: !0,
        value: 512,
        min: 32,
        max: 1024
      },
      autoUpdate: {
        value: !0,
        type: "Boolean"
      },
      renderDebugFrame: {
        value: !1,
        type: "Boolean"
      },
      updateInterval: {
        type: "Number",
        interpolable: !0,
        value: 1,
        min: 0,
        max: 1
      },
      threshold: {
        type: "Number",
        interpolable: !0,
        value: 100,
        min: 1,
        max: 512
      }
    }), y(this, "_interval", null);
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(t) {
    this._config.enabled.value = t, this._component.enabled = t;
  }
  get width() {
    return this._config.width.value;
  }
  set width(t) {
    this.setWidthHeight(t, this.height);
  }
  get height() {
    return this._config.height.value;
  }
  set height(t) {
    this.setWidthHeight(this.width, t);
  }
  get autoUpdate() {
    return this._config.autoUpdate.value;
  }
  set autoUpdate(t) {
    this.setAutoAndInterval(t, this.updateInterval);
  }
  get updateInterval() {
    return this._config.updateInterval.value;
  }
  set updateInterval(t) {
    this.setAutoAndInterval(this.autoUpdate, t);
  }
  get renderDebugFrame() {
    return this._config.renderDebugFrame.value;
  }
  set renderDebugFrame(t) {
    this._config.renderDebugFrame.value = t;
  }
  get threshold() {
    return this._config.threshold.value;
  }
  set threshold(t) {
    this._config.threshold.value = t;
  }
  setWidthHeight(t, e) {
    if (t <= 0 || e <= 0)
      throw new Error(
        "The width and height of the culler renderer must be more than 0!"
      );
    this._config.width.value = t, this._config.height.value = e, this.resetRenderTarget();
  }
  setAutoAndInterval(t, e) {
    if (e <= 0)
      throw new Error(
        "The updateInterval of the culler renderer must be more than 0!"
      );
    this._config.autoUpdate.value = t, this._config.updateInterval.value = e, this.resetInterval(t);
  }
  resetRenderTarget() {
    this._component.renderTarget.dispose(), this._component.renderTarget = new A.WebGLRenderTarget(
      this.width,
      this.height
    ), this._component.bufferSize = this.width * this.height * 4, this._component.buffer = new Uint8Array(this._component.bufferSize);
  }
  resetInterval(t) {
    this._interval !== null && window.clearInterval(this._interval), t && (this._interval = window.setInterval(async () => {
      this._component.preventUpdate || await this._component.updateVisibility();
    }, this.updateInterval));
  }
}
class ul {
  constructor(t, e) {
    if (y(this, "onSetup", new Y()), y(this, "onDisposed", new Y()), y(this, "onViewUpdated", new bt()), y(this, "enabled", !0), y(this, "needsUpdate", !1), y(this, "components"), y(this, "renderTarget", new A.WebGLRenderTarget()), y(this, "bufferSize", 1), y(this, "buffer", new Uint8Array()), y(this, "preventUpdate", !1), y(this, "config"), y(this, "isSetup", !1), y(this, "world"), y(this, "renderer"), y(this, "_defaultConfig", {
      enabled: !0,
      height: 512,
      width: 512,
      updateInterval: 1e3,
      autoUpdate: !0,
      renderDebugFrame: !1,
      threshold: 100
    }), y(this, "worker"), y(this, "scene", new A.Scene()), y(this, "_availableColor", 1), y(this, "_isWorkerBusy", !1), y(this, "updateVisibility", async (n) => {
      if (!this.enabled || !this.needsUpdate && !n || this._isWorkerBusy)
        return;
      this._isWorkerBusy = !0;
      const r = this.world.camera.three;
      r.updateMatrix();
      const { width: o, height: a } = this.config;
      this.renderer.setSize(o, a), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, r);
      const c = this.renderer.getContext();
      await Nu(
        c,
        0,
        0,
        o,
        a,
        c.RGBA,
        c.UNSIGNED_BYTE,
        this.buffer
      ), this.renderer.setRenderTarget(null), this.config.renderDebugFrame && this.renderer.render(this.scene, r), this.worker.postMessage({
        buffer: this.buffer
      }), this.needsUpdate = !1;
    }), !e.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = t, this.config = new xu(
      this,
      this.components,
      "Culler renderer"
    ), this.world = e, this.renderer = new A.WebGLRenderer(), this.renderer.clippingPlanes = e.renderer.clippingPlanes;
    const s = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `, i = new Blob([s], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(i)), this.setup();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.config.autoUpdate = !1, this.components.get(Yn).list.delete(this.config.uuid);
    for (const e of this.scene.children)
      e.removeFromParent();
    this.onViewUpdated.reset(), this.worker.terminate(), this.renderer.forceContextLoss(), this.renderer.dispose(), this.renderTarget.dispose(), this.buffer = null, this.onDisposed.reset();
  }
  setup(t) {
    const e = { ...this._defaultConfig, ...t }, { width: s, height: i } = e;
    this.config.setWidthHeight(s, i);
    const { updateInterval: n, autoUpdate: r } = e;
    this.config.setAutoAndInterval(r, n), this.config.threshold = e.threshold, this.isSetup = !0, this.onSetup.trigger();
  }
  getAvailableColor() {
    let t = BigInt(this._availableColor.toString());
    const e = [];
    do
      e.unshift(Number(t % 256n)), t /= 256n;
    while (t);
    for (; e.length !== 3; )
      e.unshift(0);
    const [s, i, n] = e, r = `${s}-${i}-${n}`;
    return { r: s, g: i, b: n, code: r };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
}
class Lu extends ul {
  constructor(t, e) {
    super(t, e), y(this, "onViewUpdated", new Y()), y(this, "colorMeshes", /* @__PURE__ */ new Map()), y(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map()), y(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map()), y(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set()), y(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set()), y(this, "_transparentMat", new A.MeshBasicMaterial({
      transparent: !0,
      opacity: 0
    })), y(this, "handleWorkerMessage", async (s) => {
      if (this.preventUpdate)
        return;
      const i = s.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes), this._currentVisibleMeshes.clear();
      for (const [n, r] of i) {
        if (r < this.config.threshold)
          continue;
        const o = this._colorCodeMeshMap.get(n);
        o && (this._currentVisibleMeshes.add(o), this._recentlyHiddenMeshes.delete(o));
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      }), this._isWorkerBusy = !1;
    }), this.worker.addEventListener("message", this.handleWorkerMessage), this.onViewUpdated.add(({ seen: s, unseen: i }) => {
      for (const n of s)
        n.visible = !0;
      for (const n of i)
        n.visible = !1;
    });
  }
  /**
   * @deprecated use config.threshold instead.
   */
  get threshold() {
    return this.config.threshold;
  }
  /**
   * @deprecated use config.threshold instead.
   */
  set threshold(t) {
    this.config.threshold = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this._currentVisibleMeshes.clear(), this._recentlyHiddenMeshes.clear(), this._meshIDColorCodeMap.clear(), this._transparentMat.dispose(), this._colorCodeMeshMap.clear();
    const t = this.components.get(Ot);
    for (const e in this.colorMeshes) {
      const s = this.colorMeshes.get(e);
      s && t.destroy(s, !0);
    }
    this.colorMeshes.clear();
  }
  /**
   * Adds a mesh to the culler. When the mesh is not visibile anymore, it will be removed from the scene. When it's visible again, it will be added to the scene.
   * @param mesh - The mesh to add. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   */
  add(t) {
    if (!this.enabled)
      return;
    if (this.preventUpdate) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.preventUpdate = !0;
    const e = t instanceof A.InstancedMesh, { geometry: s, material: i } = t, { colorMaterial: n, code: r } = this.getAvailableMaterial();
    let o;
    if (Array.isArray(i)) {
      let h = !0;
      const f = [];
      for (const u of i)
        ko.isTransparent(u) ? f.push(this._transparentMat) : (h = !1, f.push(n));
      if (h) {
        n.dispose(), this.preventUpdate = !1;
        return;
      }
      o = f;
    } else if (ko.isTransparent(i)) {
      n.dispose(), this.preventUpdate = !1;
      return;
    } else
      o = n;
    this._colorCodeMeshMap.set(r, t), this._meshIDColorCodeMap.set(t.uuid, r);
    const a = e ? t.count : 1, c = new A.InstancedMesh(s, o, a);
    e ? c.instanceMatrix = t.instanceMatrix : c.setMatrixAt(0, new A.Matrix4()), t.visible = !1, t.updateWorldMatrix(!0, !1), c.applyMatrix4(t.matrixWorld), c.updateMatrix(), this.scene.add(c), this.colorMeshes.set(t.uuid, c), this.increaseColor(), this.preventUpdate = !1;
  }
  /**
   * Removes a mesh from the culler, so its visibility is not controlled by the culler anymore.
   * When the mesh is removed, it will be hidden from the scene and its color-coded mesh will be destroyed.
   * @param mesh - The mesh to remove. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   */
  remove(t) {
    if (this.preventUpdate) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.preventUpdate = !0;
    const e = this.components.get(Ot);
    this._currentVisibleMeshes.delete(t), this._recentlyHiddenMeshes.delete(t);
    const s = this.colorMeshes.get(t.uuid), i = this._meshIDColorCodeMap.get(t.uuid);
    if (!s || !i) {
      this.preventUpdate = !1;
      return;
    }
    this._colorCodeMeshMap.delete(i), this._meshIDColorCodeMap.delete(t.uuid), this.colorMeshes.delete(t.uuid), s.geometry = void 0, s.material = [], e.destroy(s, !0), this._recentlyHiddenMeshes.delete(t), this._currentVisibleMeshes.delete(t), this.preventUpdate = !1;
  }
  /**
   * Updates the given instanced meshes inside the culler. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   * @returns {void}
   */
  updateInstanced(t) {
    for (const e of t) {
      const s = this.colorMeshes.get(e.uuid);
      s && (s.count = e.count);
    }
  }
  getAvailableMaterial() {
    const { r: t, g: e, b: s, code: i } = this.getAvailableColor(), n = A.ColorManagement.enabled;
    A.ColorManagement.enabled = !1;
    const r = new A.Color(`rgb(${t}, ${e}, ${s})`);
    if (!this.world.renderer)
      throw new Error("Renderer not found in the world!");
    const o = this.world.renderer.clippingPlanes, a = new A.MeshBasicMaterial({
      color: r,
      clippingPlanes: o,
      side: A.DoubleSide
    });
    return A.ColorManagement.enabled = n, { colorMaterial: a, code: i };
  }
}
const fl = class Vr extends ue {
  constructor(t) {
    super(t), y(this, "onDisposed", new Y()), y(this, "_enabled", !0), y(this, "list", /* @__PURE__ */ new Map()), t.add(Vr.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const [e, s] of this.list)
      s.enabled = t;
  }
  /**
   * Creates a new MeshCullerRenderer for the given world.
   * If a MeshCullerRenderer already exists for the world, it will return the existing one.
   *
   * @param world - The world for which to create the MeshCullerRenderer.
   *
   * @returns The newly created or existing MeshCullerRenderer for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Lu(this.components, t);
    return this.list.set(t.uuid, e), e;
  }
  /**
   * Deletes the MeshCullerRenderer associated with the given world.
   * If a MeshCullerRenderer exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the MeshCullerRenderer.
   *
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.onDisposed.trigger(Vr.uuid), this.onDisposed.reset();
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear();
  }
  /**
   * Updates the given instanced meshes inside the all the cullers. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   */
  updateInstanced(t) {
    for (const [, e] of this.list)
      e.updateInstanced(t);
  }
};
y(fl, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
let Mu = fl;
class bu {
  constructor(t) {
    y(this, "_event"), y(this, "_position", new A.Vector2()), y(this, "onDisposed", new Y()), y(this, "updateMouseInfo", (e) => {
      this._event = e;
    }), this.dom = t, this.setupEvents(!0);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const t = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(t, this._event), this._position.y = this.getPositionY(t, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getPositionY(t, e) {
    return -((this.getDataObject(e).clientY - t.top) / (t.bottom - t.top)) * 2 + 1;
  }
  getPositionX(t, e) {
    return (this.getDataObject(e).clientX - t.left) / (t.right - t.left) * 2 - 1;
  }
  getDataObject(t) {
    return t instanceof MouseEvent ? t : t.touches[0];
  }
  setupEvents(t) {
    t ? (this.dom.addEventListener("pointermove", this.updateMouseInfo), this.dom.addEventListener("touchstart", this.updateMouseInfo)) : (this.dom.removeEventListener("pointermove", this.updateMouseInfo), this.dom.removeEventListener("touchstart", this.updateMouseInfo));
  }
}
class Du {
  constructor(t, e) {
    y(this, "enabled", !0), y(this, "components"), y(this, "onDisposed", new Y()), y(this, "mouse"), y(this, "three", new A.Raycaster()), y(this, "world");
    const s = e.renderer;
    if (!s)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = e, this.mouse = new bu(s.three.domElement), this.components = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   * @param position - the screen position to use for raycasting. If not provided,
   * the last pointer (mouse/touch) position will be used.
   */
  castRay(t = Array.from(this.world.meshes), e = this.mouse.position) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const s = this.world.camera.three;
    return this.three.setFromCamera(e, s), this.intersect(t);
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(t, e, s = Array.from(this.world.meshes)) {
    return this.three.set(t, e), this.intersect(s);
  }
  intersect(t = Array.from(this.world.meshes)) {
    const e = this.three.intersectObjects(t), s = this.filterClippingPlanes(e);
    return s.length > 0 ? s[0] : null;
  }
  filterClippingPlanes(t) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const e = this.world.renderer.three;
    if (!e.clippingPlanes)
      return t;
    const s = e.clippingPlanes;
    return t.length <= 0 || !s || (s == null ? void 0 : s.length) <= 0 ? t : t.filter(
      (i) => s.every((n) => n.distanceToPoint(i.point) > 0)
    );
  }
}
const dl = class pl extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), y(this, "list", /* @__PURE__ */ new Map()), y(this, "onDisposed", new Y()), t.add(pl.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Du(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
y(dl, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
let ct = dl;
class _u extends zs {
  constructor() {
    super(...arguments), y(this, "_config", {
      visible: {
        value: !0,
        type: "Boolean"
      },
      color: {
        value: new A.Color(),
        type: "Color"
      },
      primarySize: {
        type: "Number",
        interpolable: !0,
        value: 1,
        min: 0,
        max: 1e3
      },
      secondarySize: {
        type: "Number",
        interpolable: !0,
        value: 10,
        min: 0,
        max: 1e3
      },
      distance: {
        type: "Number",
        interpolable: !0,
        value: 500,
        min: 0,
        max: 500
      }
    });
  }
  /**
   * Whether the grid is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the grid is visible or not.
   */
  set visible(t) {
    this._config.visible.value = t, this._component.visible = t;
  }
  /**
   * The color of the grid lines.
   */
  get color() {
    return this._config.color.value;
  }
  /**
   * The color of the grid lines.
   */
  set color(t) {
    this._config.color.value = t, this._component.material.uniforms.uColor.value = t, this._component.material.uniformsNeedUpdate = !0;
  }
  /**
   * The size of the primary grid lines.
   */
  get primarySize() {
    return this._config.primarySize.value;
  }
  /**
   * The size of the primary grid lines.
   */
  set primarySize(t) {
    this._config.primarySize.value = t, this._component.material.uniforms.uSize1.value = t, this._component.material.uniformsNeedUpdate = !0;
  }
  /**
   * The size of the secondary grid lines.
   */
  get secondarySize() {
    return this._config.secondarySize.value;
  }
  /**
   * The size of the secondary grid lines.
   */
  set secondarySize(t) {
    this._config.secondarySize.value = t, this._component.material.uniforms.uSize2.value = t, this._component.material.uniformsNeedUpdate = !0;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  get distance() {
    return this._config.distance.value;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  set distance(t) {
    this._config.distance.value = t, this._component.material.uniforms.uDistance.value = t, this._component.material.uniformsNeedUpdate = !0;
  }
}
class Uu {
  constructor(t, e) {
    y(this, "onDisposed", new Y()), y(this, "onSetup", new Y()), y(this, "isSetup", !1), y(this, "world"), y(this, "components"), y(this, "config"), y(this, "_defaultConfig", {
      visible: !0,
      color: new A.Color(12303291),
      primarySize: 1,
      secondarySize: 10,
      distance: 500
    }), y(this, "three"), y(this, "_fade", 3), y(this, "updateZoom", () => {
      this.world.camera instanceof Ti && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    }), this.world = e;
    const { color: s, primarySize: i, secondarySize: n, distance: r } = this._defaultConfig;
    this.components = t, this.config = new _u(this, this.components, "Grid");
    const o = new A.PlaneGeometry(2, 2, 1, 1), a = new A.ShaderMaterial({
      side: A.DoubleSide,
      uniforms: {
        uSize1: {
          value: i
        },
        uSize2: {
          value: n
        },
        uColor: {
          value: s
        },
        uDistance: {
          value: r
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: !0,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        // derivatives: true,
      }
    });
    this.three = new A.Mesh(o, a), this.three.frustumCulled = !1, e.scene.three.add(this.three), this.setupEvents(!0);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(t) {
    t ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(t) {
    this._fade = t ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Configurable.setup} */
  setup(t) {
    const e = { ...this._defaultConfig, ...t };
    this.config.visible = !0, this.config.color = e.color, this.config.primarySize = e.primarySize, this.config.secondarySize = e.secondarySize, this.config.distance = e.distance, this.isSetup = !0, this.onSetup.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.components.get(Yn).list.delete(this.config.uuid), this.components.get(Ot).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(t) {
    if (this.world.isDisposing || !(this.world.camera instanceof Ti))
      return;
    const e = this.world.camera.controls;
    t ? e.addEventListener("update", this.updateZoom) : e.removeEventListener("update", this.updateZoom);
  }
}
const Bu = class ml extends ue {
  constructor(t) {
    super(t), y(this, "list", /* @__PURE__ */ new Map()), y(this, "onDisposed", new Y()), y(this, "enabled", !0), t.add(ml.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new Uu(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
y(Bu, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
const is = new Cc(), Ye = new q(), Ht = new q(), we = new Ft(), qo = {
  X: new q(1, 0, 0),
  Y: new q(0, 1, 0),
  Z: new q(0, 0, 1)
}, Tr = { type: "change" }, Jo = { type: "mouseDown", mode: null }, $o = { type: "mouseUp", mode: null }, ea = { type: "objectChange" };
class Vu extends yc {
  /**
   * Constructs a new controls instance.
   *
   * @param {Camera} camera - The camera of the rendered scene.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(t, e = null) {
    super(void 0, e);
    const s = new Wu(this);
    this._root = s;
    const i = new Xu();
    this._gizmo = i, s.add(i);
    const n = new Zu();
    this._plane = n, s.add(n);
    const r = this;
    function o(T, C) {
      let F = C;
      Object.defineProperty(r, T, {
        get: function() {
          return F !== void 0 ? F : C;
        },
        set: function(O) {
          F !== O && (F = O, n[T] = O, i[T] = O, r.dispatchEvent({ type: T + "-changed", value: O }), r.dispatchEvent(Tr));
        }
      }), r[T] = C, n[T] = C, i[T] = C;
    }
    o("camera", t), o("object", void 0), o("enabled", !0), o("axis", null), o("mode", "translate"), o("translationSnap", null), o("rotationSnap", null), o("scaleSnap", null), o("space", "world"), o("size", 1), o("dragging", !1), o("showX", !0), o("showY", !0), o("showZ", !0), o("minX", -1 / 0), o("maxX", 1 / 0), o("minY", -1 / 0), o("maxY", 1 / 0), o("minZ", -1 / 0), o("maxZ", 1 / 0);
    const a = new q(), c = new q(), h = new Ft(), f = new Ft(), u = new q(), d = new Ft(), p = new q(), m = new q(), E = new q(), I = 0, g = new q();
    o("worldPosition", a), o("worldPositionStart", c), o("worldQuaternion", h), o("worldQuaternionStart", f), o("cameraPosition", u), o("cameraQuaternion", d), o("pointStart", p), o("pointEnd", m), o("rotationAxis", E), o("rotationAngle", I), o("eye", g), this._offset = new q(), this._startNorm = new q(), this._endNorm = new q(), this._cameraScale = new q(), this._parentPosition = new q(), this._parentQuaternion = new Ft(), this._parentQuaternionInv = new Ft(), this._parentScale = new q(), this._worldScaleStart = new q(), this._worldQuaternionInv = new Ft(), this._worldScale = new q(), this._positionStart = new q(), this._quaternionStart = new Ft(), this._scaleStart = new q(), this._getPointer = zu.bind(this), this._onPointerDown = Gu.bind(this), this._onPointerHover = ku.bind(this), this._onPointerMove = Yu.bind(this), this._onPointerUp = Hu.bind(this), e !== null && this.connect(e);
  }
  connect(t) {
    super.connect(t), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  /**
   * Returns the visual representation of the controls. Add the helper to your scene to
   * visually transform the attached  3D object.
   *
   * @return {TransformControlsRoot} The helper.
   */
  getHelper() {
    return this._root;
  }
  pointerHover(t) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    t !== null && is.setFromCamera(t, this.camera);
    const e = yr(this._gizmo.picker[this.mode], is);
    e ? this.axis = e.object.name : this.axis = null;
  }
  pointerDown(t) {
    if (!(this.object === void 0 || this.dragging === !0 || t != null && t.button !== 0) && this.axis !== null) {
      t !== null && is.setFromCamera(t, this.camera);
      const e = yr(this._plane, is, !0);
      e && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(e.point).sub(this.worldPositionStart)), this.dragging = !0, Jo.mode = this.mode, this.dispatchEvent(Jo);
    }
  }
  pointerMove(t) {
    const e = this.axis, s = this.mode, i = this.object;
    let n = this.space;
    if (s === "scale" ? n = "local" : (e === "E" || e === "XYZE" || e === "XYZ") && (n = "world"), i === void 0 || e === null || this.dragging === !1 || t !== null && t.button !== -1)
      return;
    t !== null && is.setFromCamera(t, this.camera);
    const r = yr(this._plane, is, !0);
    if (r) {
      if (this.pointEnd.copy(r.point).sub(this.worldPositionStart), s === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), n === "local" && e !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), e.indexOf("X") === -1 && (this._offset.x = 0), e.indexOf("Y") === -1 && (this._offset.y = 0), e.indexOf("Z") === -1 && (this._offset.z = 0), n === "local" && e !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (n === "local" && (i.position.applyQuaternion(we.copy(this._quaternionStart).invert()), e.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), n === "world" && (i.parent && i.position.add(Ye.setFromMatrixPosition(i.parent.matrixWorld)), e.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(Ye.setFromMatrixPosition(i.parent.matrixWorld)))), i.position.x = Math.max(this.minX, Math.min(this.maxX, i.position.x)), i.position.y = Math.max(this.minY, Math.min(this.maxY, i.position.y)), i.position.z = Math.max(this.minZ, Math.min(this.maxZ, i.position.z));
      else if (s === "scale") {
        if (e.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), Ht.set(o, o, o);
        } else
          Ye.copy(this.pointStart), Ht.copy(this.pointEnd), Ye.applyQuaternion(this._worldQuaternionInv), Ht.applyQuaternion(this._worldQuaternionInv), Ht.divide(Ye), e.search("X") === -1 && (Ht.x = 1), e.search("Y") === -1 && (Ht.y = 1), e.search("Z") === -1 && (Ht.z = 1);
        i.scale.copy(this._scaleStart).multiply(Ht), this.scaleSnap && (e.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (s === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(Ye.setFromMatrixPosition(this.camera.matrixWorld));
        let a = !1;
        e === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Ye.copy(this.rotationAxis).cross(this.eye)) * o) : (e === "X" || e === "Y" || e === "Z") && (this.rotationAxis.copy(qo[e]), Ye.copy(qo[e]), n === "local" && Ye.applyQuaternion(this.worldQuaternion), Ye.cross(this.eye), Ye.length() === 0 ? a = !0 : this.rotationAngle = this._offset.dot(Ye.normalize()) * o), (e === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), n === "local" && e !== "E" && e !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(we.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(we.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Tr), this.dispatchEvent(ea);
    }
  }
  pointerUp(t) {
    t !== null && t.button !== 0 || (this.dragging && this.axis !== null && ($o.mode = this.mode, this.dispatchEvent($o)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  /**
   * Sets the 3D object that should be transformed and ensures the controls UI is visible.
   *
   * @param {Object3D} object -  The 3D object that should be transformed.
   * @return {TransformControls} A reference to this controls.
   */
  attach(t) {
    return this.object = t, this._root.visible = !0, this;
  }
  /**
   * Removes the current 3D object from the controls and makes the helper UI invisible.
   *
   * @return {TransformControls} A reference to this controls.
   */
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  /**
   * Resets the object's position, rotation and scale to when the current transform began.
   */
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Tr), this.dispatchEvent(ea), this.pointStart.copy(this.pointEnd));
  }
  /**
   * Returns the raycaster that is used for user interaction. This object is shared between all
   * instances of `TransformControls`.
   *
   * @returns {Raycaster} The internal raycaster.
   */
  getRaycaster() {
    return is;
  }
  /**
   * Returns the transformation mode.
   *
   * @returns {'translate'|'rotate'|'scale'} The transformation mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the given transformation mode.
   *
   * @param {'translate'|'rotate'|'scale'} mode - The transformation mode to set.
   */
  setMode(t) {
    this.mode = t;
  }
  /**
   * Sets the translation snap.
   *
   * @param {?number} translationSnap - The translation snap to set.
   */
  setTranslationSnap(t) {
    this.translationSnap = t;
  }
  /**
   * Sets the rotation snap.
   *
   * @param {?number} rotationSnap - The rotation snap to set.
   */
  setRotationSnap(t) {
    this.rotationSnap = t;
  }
  /**
   * Sets the scale snap.
   *
   * @param {?number} scaleSnap - The scale snap to set.
   */
  setScaleSnap(t) {
    this.scaleSnap = t;
  }
  /**
   * Sets the size of the helper UI.
   *
   * @param {number} size - The size to set.
   */
  setSize(t) {
    this.size = t;
  }
  /**
   * Sets the coordinate space in which transformations are applied.
   *
   * @param {'world'|'local'} space - The space to set.
   */
  setSpace(t) {
    this.space = t;
  }
}
function zu(l) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: l.button
    };
  {
    const t = this.domElement.getBoundingClientRect();
    return {
      x: (l.clientX - t.left) / t.width * 2 - 1,
      y: -(l.clientY - t.top) / t.height * 2 + 1,
      button: l.button
    };
  }
}
function ku(l) {
  if (this.enabled)
    switch (l.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(l));
        break;
    }
}
function Gu(l) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(l.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(l)), this.pointerDown(this._getPointer(l)));
}
function Yu(l) {
  this.enabled && this.pointerMove(this._getPointer(l));
}
function Hu(l) {
  this.enabled && (this.domElement.releasePointerCapture(l.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(l)));
}
function yr(l, t, e) {
  const s = t.intersectObject(l, !0);
  for (let i = 0; i < s.length; i++)
    if (s[i].object.visible || e)
      return s[i];
  return !1;
}
const en = new Tc(), ye = new q(0, 1, 0), ta = new q(0, 0, 0), sa = new Ce(), tn = new Ft(), pn = new Ft(), yt = new q(), ia = new Ce(), li = new q(1, 0, 0), rs = new q(0, 1, 0), ci = new q(0, 0, 1), sn = new q(), ii = new q(), ni = new q();
class Wu extends In {
  constructor(t) {
    super(), this.isTransformControlsRoot = !0, this.controls = t, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(t) {
    const e = this.controls;
    e.object !== void 0 && (e.object.updateMatrixWorld(), e.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : e.object.parent.matrixWorld.decompose(e._parentPosition, e._parentQuaternion, e._parentScale), e.object.matrixWorld.decompose(e.worldPosition, e.worldQuaternion, e._worldScale), e._parentQuaternionInv.copy(e._parentQuaternion).invert(), e._worldQuaternionInv.copy(e.worldQuaternion).invert()), e.camera.updateMatrixWorld(), e.camera.matrixWorld.decompose(e.cameraPosition, e.cameraQuaternion, e._cameraScale), e.camera.isOrthographicCamera ? e.camera.getWorldDirection(e.eye).negate() : e.eye.copy(e.cameraPosition).sub(e.worldPosition).normalize(), super.updateMatrixWorld(t);
  }
  dispose() {
    this.traverse(function(t) {
      t.geometry && t.geometry.dispose(), t.material && t.material.dispose();
    });
  }
}
class Xu extends In {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const t = new ka({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), e = new Ga({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), s = t.clone();
    s.opacity = 0.15;
    const i = e.clone();
    i.opacity = 0.5;
    const n = t.clone();
    n.color.setHex(16711680);
    const r = t.clone();
    r.color.setHex(65280);
    const o = t.clone();
    o.color.setHex(255);
    const a = t.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const c = t.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const h = t.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const f = t.clone();
    f.opacity = 0.25;
    const u = t.clone();
    u.color.setHex(16776960), u.opacity = 0.25, t.clone().color.setHex(16776960);
    const p = t.clone();
    p.color.setHex(7895160);
    const m = new je(0, 0.04, 0.1, 12);
    m.translate(0, 0.05, 0);
    const E = new He(0.08, 0.08, 0.08);
    E.translate(0, 0.04, 0);
    const I = new En();
    I.setAttribute("position", new Us([0, 0, 0, 1, 0, 0], 3));
    const g = new je(75e-4, 75e-4, 0.5, 3);
    g.translate(0, 0.25, 0);
    function T(_, K) {
      const U = new Ws(_, 75e-4, 3, 64, K * Math.PI * 2);
      return U.rotateY(Math.PI / 2), U.rotateX(Math.PI / 2), U;
    }
    function C() {
      const _ = new En();
      return _.setAttribute("position", new Us([0, 0, 0, 1, 1, 1], 3)), _;
    }
    const F = {
      X: [
        [new oe(m, n), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new oe(m, n), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new oe(g, n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new oe(m, r), [0, 0.5, 0]],
        [new oe(m, r), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new oe(g, r)]
      ],
      Z: [
        [new oe(m, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new oe(m, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new oe(g, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new oe(new Ni(0.1, 0), f.clone()), [0, 0, 0]]
      ],
      XY: [
        [new oe(new He(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new oe(new He(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new oe(new He(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, O = {
      X: [
        [new oe(new je(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new oe(new je(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new oe(new Ni(0.2, 0), s)]
      ],
      XY: [
        [new oe(new He(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new oe(new He(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new oe(new He(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, P = {
      START: [
        [new oe(new Ni(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new oe(new Ni(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new kt(C(), i), null, null, null, "helper"]
      ],
      X: [
        [new kt(I, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new kt(I, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new kt(I, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, M = {
      XYZE: [
        [new oe(T(0.5, 1), p), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new oe(T(0.5, 0.5), n)]
      ],
      Y: [
        [new oe(T(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new oe(T(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new oe(T(0.75, 1), u), null, [0, Math.PI / 2, 0]]
      ]
    }, L = {
      AXIS: [
        [new kt(I, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, b = {
      XYZE: [
        [new oe(new Rc(0.25, 10, 8), s)]
      ],
      X: [
        [new oe(new Ws(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new oe(new Ws(0.5, 0.1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new oe(new Ws(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new oe(new Ws(0.75, 0.1, 2, 24), s)]
      ]
    }, B = {
      X: [
        [new oe(E, n), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new oe(g, n), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new oe(E, n), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new oe(E, r), [0, 0.5, 0]],
        [new oe(g, r)],
        [new oe(E, r), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new oe(E, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new oe(g, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new oe(E, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new oe(new He(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new oe(new He(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new oe(new He(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new oe(new He(0.1, 0.1, 0.1), f.clone())]
      ]
    }, v = {
      X: [
        [new oe(new je(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new oe(new je(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new oe(new je(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new oe(new He(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new oe(new He(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new oe(new He(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new oe(new He(0.2, 0.2, 0.2), s), [0, 0, 0]]
      ]
    }, D = {
      X: [
        [new kt(I, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new kt(I, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new kt(I, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function R(_) {
      const K = new In();
      for (const U in _)
        for (let Z = _[U].length; Z--; ) {
          const H = _[U][Z][0].clone(), J = _[U][Z][1], z = _[U][Z][2], k = _[U][Z][3], ae = _[U][Z][4];
          H.name = U, H.tag = ae, J && H.position.set(J[0], J[1], J[2]), z && H.rotation.set(z[0], z[1], z[2]), k && H.scale.set(k[0], k[1], k[2]), H.updateMatrix();
          const ne = H.geometry.clone();
          ne.applyMatrix4(H.matrix), H.geometry = ne, H.renderOrder = 1 / 0, H.position.set(0, 0, 0), H.rotation.set(0, 0, 0), H.scale.set(1, 1, 1), K.add(H);
        }
      return K;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = R(F)), this.add(this.gizmo.rotate = R(M)), this.add(this.gizmo.scale = R(B)), this.add(this.picker.translate = R(O)), this.add(this.picker.rotate = R(b)), this.add(this.picker.scale = R(v)), this.add(this.helper.translate = R(P)), this.add(this.helper.rotate = R(L)), this.add(this.helper.scale = R(D)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(t) {
    const s = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : pn;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let n = 0; n < i.length; n++) {
      const r = i[n];
      r.visible = !0, r.rotation.set(0, 0, 0), r.position.copy(this.worldPosition);
      let o;
      if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), r.tag === "helper") {
        r.visible = !1, r.name === "AXIS" ? (r.visible = !!this.axis, this.axis === "X" && (we.setFromEuler(en.set(0, 0, 0)), r.quaternion.copy(s).multiply(we), Math.abs(ye.copy(li).applyQuaternion(s).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "Y" && (we.setFromEuler(en.set(0, 0, Math.PI / 2)), r.quaternion.copy(s).multiply(we), Math.abs(ye.copy(rs).applyQuaternion(s).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "Z" && (we.setFromEuler(en.set(0, Math.PI / 2, 0)), r.quaternion.copy(s).multiply(we), Math.abs(ye.copy(ci).applyQuaternion(s).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "XYZE" && (we.setFromEuler(en.set(0, Math.PI / 2, 0)), ye.copy(this.rotationAxis), r.quaternion.setFromRotationMatrix(sa.lookAt(ta, ye, rs)), r.quaternion.multiply(we), r.visible = this.dragging), this.axis === "E" && (r.visible = !1)) : r.name === "START" ? (r.position.copy(this.worldPositionStart), r.visible = this.dragging) : r.name === "END" ? (r.position.copy(this.worldPosition), r.visible = this.dragging) : r.name === "DELTA" ? (r.position.copy(this.worldPositionStart), r.quaternion.copy(this.worldQuaternionStart), Ye.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Ye.applyQuaternion(this.worldQuaternionStart.clone().invert()), r.scale.copy(Ye), r.visible = this.dragging) : (r.quaternion.copy(s), this.dragging ? r.position.copy(this.worldPositionStart) : r.position.copy(this.worldPosition), this.axis && (r.visible = this.axis.search(r.name) !== -1));
        continue;
      }
      r.quaternion.copy(s), this.mode === "translate" || this.mode === "scale" ? (r.name === "X" && Math.abs(ye.copy(li).applyQuaternion(s).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "Y" && Math.abs(ye.copy(rs).applyQuaternion(s).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "Z" && Math.abs(ye.copy(ci).applyQuaternion(s).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "XY" && Math.abs(ye.copy(ci).applyQuaternion(s).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "YZ" && Math.abs(ye.copy(li).applyQuaternion(s).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "XZ" && Math.abs(ye.copy(rs).applyQuaternion(s).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1)) : this.mode === "rotate" && (tn.copy(s), ye.copy(this.eye).applyQuaternion(we.copy(s).invert()), r.name.search("E") !== -1 && r.quaternion.setFromRotationMatrix(sa.lookAt(this.eye, ta, rs)), r.name === "X" && (we.setFromAxisAngle(li, Math.atan2(-ye.y, ye.z)), we.multiplyQuaternions(tn, we), r.quaternion.copy(we)), r.name === "Y" && (we.setFromAxisAngle(rs, Math.atan2(ye.x, ye.z)), we.multiplyQuaternions(tn, we), r.quaternion.copy(we)), r.name === "Z" && (we.setFromAxisAngle(ci, Math.atan2(ye.y, ye.x)), we.multiplyQuaternions(tn, we), r.quaternion.copy(we))), r.visible = r.visible && (r.name.indexOf("X") === -1 || this.showX), r.visible = r.visible && (r.name.indexOf("Y") === -1 || this.showY), r.visible = r.visible && (r.name.indexOf("Z") === -1 || this.showZ), r.visible = r.visible && (r.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), r.material._color = r.material._color || r.material.color.clone(), r.material._opacity = r.material._opacity || r.material.opacity, r.material.color.copy(r.material._color), r.material.opacity = r.material._opacity, this.enabled && this.axis && (r.name === this.axis || this.axis.split("").some(function(a) {
        return r.name === a;
      })) && (r.material.color.setHex(16776960), r.material.opacity = 1);
    }
    super.updateMatrixWorld(t);
  }
}
class Zu extends oe {
  constructor() {
    super(
      new Sc(1e5, 1e5, 2, 2),
      new ka({ visible: !1, wireframe: !0, side: Ya, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(t) {
    let e = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), sn.copy(li).applyQuaternion(e === "local" ? this.worldQuaternion : pn), ii.copy(rs).applyQuaternion(e === "local" ? this.worldQuaternion : pn), ni.copy(ci).applyQuaternion(e === "local" ? this.worldQuaternion : pn), ye.copy(ii), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            ye.copy(this.eye).cross(sn), yt.copy(sn).cross(ye);
            break;
          case "Y":
            ye.copy(this.eye).cross(ii), yt.copy(ii).cross(ye);
            break;
          case "Z":
            ye.copy(this.eye).cross(ni), yt.copy(ni).cross(ye);
            break;
          case "XY":
            yt.copy(ni);
            break;
          case "YZ":
            yt.copy(sn);
            break;
          case "XZ":
            ye.copy(ni), yt.copy(ii);
            break;
          case "XYZ":
          case "E":
            yt.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        yt.set(0, 0, 0);
    }
    yt.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (ia.lookAt(Ye.set(0, 0, 0), yt, ye), this.quaternion.setFromRotationMatrix(ia)), super.updateMatrixWorld(t);
  }
}
class Hn {
  constructor(t, e, s, i, n, r = 5, o = !0) {
    if (y(this, "onDraggingStarted", new Y()), y(this, "onDraggingEnded", new Y()), y(this, "onDisposed", new Y()), y(this, "normal"), y(this, "origin"), y(this, "three", new A.Plane()), y(this, "components"), y(this, "world"), y(this, "type", "default"), y(this, "_helper"), y(this, "_visible", !0), y(this, "_enabled", !0), y(this, "_controlsActive", !1), y(this, "_arrowBoundBox", new A.Mesh()), y(this, "_planeMesh"), y(this, "_controls"), y(this, "_hiddenMaterial", new A.MeshBasicMaterial({
      visible: !1
    })), y(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    }), y(this, "changeDrag", (a) => {
      this._visible = !a.value, this.preventCameraMovement(), this.notifyDraggingChanged(a);
    }), this.components = t, this.world = e, !e.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = i, this.origin = s, e.renderer.setPlane(!0, this.three), this._planeMesh = Hn.newPlaneMesh(r, n), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(i, s), o && this.toggleControls(!0);
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(t) {
    if (!this.world.isDisposing) {
      if (!this.world.renderer)
        throw new Error("No renderer found for clipping plane!");
      this._enabled = t, this.world.renderer.setPlane(t, this.three);
    }
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t, this._controls.object.visible = t, this._helper.visible = t, this.toggleControls(t);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(t) {
    this._planeMesh.material = t;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(t) {
    this._planeMesh.scale.set(t, t, t);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(t, e) {
    this.reset(), this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = !1, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(!1, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.object.removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const t = new A.Vector3(1, 0, 0), e = new A.Vector3();
    this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix();
  }
  toggleControls(t) {
    if (t) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = t;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const t = this.world.camera.three, e = this.world.renderer.three.domElement, s = new Vu(t, e);
    return this.initializeControls(s), this.world.scene.three.add(s.object), s;
  }
  initializeControls(t) {
    t.attach(this._helper), t.showX = !1, t.showY = !1, t.setSpace("local"), this.createArrowBoundingBox(), t.object.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new A.CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(t) {
    t.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const t = new A.Object3D();
    return t.lookAt(this.normal), t.position.copy(this.origin), this._planeMesh.position.z += 0.01, t.add(this._planeMesh), this.world.scene.three.add(t), t;
  }
  static newPlaneMesh(t, e) {
    const s = new A.PlaneGeometry(1), i = new A.Mesh(s, e);
    return i.scale.set(t, t, t), i;
  }
}
class ju extends zs {
  constructor() {
    super(...arguments), y(this, "_config", {
      enabled: {
        value: !0,
        type: "Boolean"
      },
      visible: {
        value: !0,
        type: "Boolean"
      },
      color: {
        value: new A.Color(),
        type: "Color"
      },
      opacity: {
        type: "Number",
        interpolable: !0,
        value: 1,
        min: 0,
        max: 1
      },
      size: {
        type: "Number",
        interpolable: !0,
        value: 2,
        min: 0,
        max: 100
      }
    });
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(t) {
    this._config.enabled.value = t, this._component.enabled = t;
  }
  get visible() {
    return this._config.visible.value;
  }
  set visible(t) {
    this._config.visible.value = t, this._component.visible = t;
  }
  get color() {
    return this._config.color.value;
  }
  set color(t) {
    this._config.color.value = t, this._component.material.color.copy(t);
  }
  get opacity() {
    return this._config.opacity.value;
  }
  set opacity(t) {
    this._config.opacity.value = t, this._component.material.opacity = t;
  }
  get size() {
    return this._config.size.value;
  }
  set size(t) {
    this._config.size.value = t, this._component.size = t;
  }
}
const Il = class mn extends ue {
  constructor(t) {
    super(t), y(this, "onSetup", new Y()), y(this, "onBeforeDrag", new Y()), y(this, "onAfterDrag", new Y()), y(this, "onBeforeCreate", new Y()), y(this, "onBeforeCancel", new Y()), y(this, "onAfterCancel", new Y()), y(this, "onBeforeDelete", new Y()), y(this, "onAfterCreate", new Y()), y(this, "onAfterDelete", new Y()), y(this, "onDisposed", new Y()), y(this, "isSetup", !1), y(this, "orthogonalY", !1), y(this, "toleranceOrthogonalY", 0.7), y(this, "Type", Hn), y(this, "list", []), y(this, "config", new ju(
      this,
      this.components,
      "Clipper",
      mn.uuid
    )), y(this, "_defaultConfig", {
      color: new A.Color(12255487),
      opacity: 0.2,
      size: 2
    }), y(this, "_material", new A.MeshBasicMaterial({
      color: 12255487,
      side: A.DoubleSide,
      transparent: !0,
      opacity: 0.2
    })), y(this, "_size", 5), y(this, "_enabled", !1), y(this, "_visible", !0), y(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    }), y(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    }), this.components.add(mn.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const e of this.list)
      e.enabled = t;
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const e of this.list)
      e.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const e of this.list)
      e.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const e of this.list)
      e.size = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = !1, this.components.get(Yn).list.delete(this.config.uuid);
    for (const e of this.list)
      e.dispose();
    this.list.length = 0, this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(mn.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(t) {
    const i = this.components.get(ct).get(t).castRay();
    return i ? this.createPlaneFromIntersection(t, i) : null;
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, e, s) {
    const i = this.newPlane(t, s, e);
    return this.updateMaterialsAndPlanes(), i;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(t, e) {
    e || (e = this.pickPlane(t)), e && this.deletePlane(e);
  }
  /**
   * Deletes all the existing clipping planes.
   *
   * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
   */
  deleteAll(t) {
    const e = [...this.list];
    for (const s of e)
      if (!t || t.has(s.type)) {
        this.delete(s.world, s);
        const i = this.list.indexOf(s);
        i !== -1 && this.list.splice(i, 1);
      }
  }
  /** {@link Configurable.setup} */
  setup(t) {
    const e = { ...this._defaultConfig, ...t };
    this.config.color = e.color, this.config.opacity = e.opacity, this.config.size = e.size, this.isSetup = !0, this.onSetup.trigger();
  }
  deletePlane(t) {
    const e = this.list.indexOf(t);
    if (e !== -1) {
      if (this.list.splice(e, 1), !t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(!1, t.three), t.dispose(), this.updateMaterialsAndPlanes(), this.onAfterDelete.trigger(t);
    }
  }
  pickPlane(t) {
    const s = this.components.get(ct).get(t), i = this.getAllPlaneMeshes(), n = s.castRay(i);
    if (n) {
      const r = n.object;
      return this.list.find((o) => o.meshes.includes(r));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const e of this.list)
      t.push(...e.meshes);
    return t;
  }
  createPlaneFromIntersection(t, e) {
    var s;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const i = e.point.distanceTo(new A.Vector3(0, 0, 0)), n = (s = e.face) == null ? void 0 : s.normal;
    if (!i || !n)
      return null;
    const r = this.getWorldNormal(e, n), o = this.newPlane(t, e.point, r.negate());
    return o.visible = this._visible, o.size = this._size, t.renderer.setPlane(!0, o.three), this.updateMaterialsAndPlanes(), o;
  }
  getWorldNormal(t, e) {
    const s = t.object;
    let i = t.object.matrixWorld.clone();
    if (s instanceof A.InstancedMesh && t.instanceId !== void 0) {
      const a = new A.Matrix4();
      s.getMatrixAt(t.instanceId, a), i = a.multiply(i);
    }
    const r = new A.Matrix3().getNormalMatrix(i), o = e.clone().applyMatrix3(r).normalize();
    return this.normalizePlaneDirectionY(o), o;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, e, s) {
    const i = new this.Type(
      this.components,
      t,
      e,
      s,
      this._material
    );
    return i.onDraggingStarted.add(this._onStartDragging), i.onDraggingEnded.add(this._onEndDragging), this.list.push(i), this.onAfterCreate.trigger(i), i;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(hl);
    for (const [e, s] of t.list) {
      if (!s.renderer)
        continue;
      s.renderer.updateClippingPlanes();
      const { clippingPlanes: i } = s.renderer;
      for (const n of s.meshes)
        if (n.material)
          if (Array.isArray(n.material))
            for (const r of n.material)
              r.clippingPlanes = i;
          else
            n.material.clippingPlanes = i;
    }
  }
};
y(Il, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
let Bs = Il;
class Qu {
  constructor(t) {
    y(this, "enabled", !1), y(this, "id", "FirstPerson"), this.camera = t;
  }
  /** {@link NavigationMode.set} */
  set(t) {
    if (this.enabled = t, t) {
      if (this.camera.projection.current !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const t = this.camera.controls, e = new A.Vector3();
    t.distance--, t.getPosition(e), t.minDistance = 1, t.maxDistance = 1, t.distance = 1, t.moveTo(
      e.x,
      e.y,
      e.z
    ), t.truckSpeed = 50, t.mouseButtons.wheel = De.ACTION.DOLLY, t.touches.two = De.ACTION.TOUCH_ZOOM_TRUCK;
  }
}
class Ku {
  constructor(t) {
    y(this, "enabled", !0), y(this, "id", "Orbit"), this.camera = t, this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(t) {
    this.enabled = t, t && this.activateOrbitControls();
  }
  activateOrbitControls() {
    const t = this.camera.controls;
    t.minDistance = 1, t.maxDistance = 300;
    const e = new A.Vector3();
    t.getPosition(e);
    const s = e.length();
    t.distance = s, t.truckSpeed = 2;
    const { rotation: i } = this.camera.three, n = new A.Vector3(0, 0, -1).applyEuler(i), r = e.addScaledVector(n, s);
    t.moveTo(r.x, r.y, r.z);
  }
}
class qu {
  constructor(t) {
    y(this, "enabled", !1), y(this, "id", "Plan"), y(this, "mouseAction1"), y(this, "mouseAction2"), y(this, "mouseInitialized", !1), y(this, "defaultAzimuthSpeed"), y(this, "defaultPolarSpeed"), this.camera = t, this.defaultAzimuthSpeed = t.controls.azimuthRotateSpeed, this.defaultPolarSpeed = t.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(t) {
    this.enabled = t;
    const e = this.camera.controls;
    e.azimuthRotateSpeed = t ? 0 : this.defaultAzimuthSpeed, e.polarRotateSpeed = t ? 0 : this.defaultPolarSpeed, this.mouseInitialized || (this.mouseAction1 = e.touches.one, this.mouseAction2 = e.touches.two, this.mouseInitialized = !0), t ? (e.mouseButtons.left = De.ACTION.TRUCK, e.touches.one = De.ACTION.TOUCH_TRUCK, e.touches.two = De.ACTION.TOUCH_ZOOM) : (e.mouseButtons.left = De.ACTION.ROTATE, e.touches.one = this.mouseAction1, e.touches.two = this.mouseAction2);
  }
}
class Ju {
  constructor(t) {
    y(this, "onChanged", new Y()), y(this, "current", "Perspective"), y(this, "camera"), y(this, "matchOrthoDistanceEnabled", !1), y(this, "_component"), y(this, "_previousDistance", -1), this._component = t, this.camera = t.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(t) {
    this.current !== t && (t === "Orthographic" ? this.setOrthoCamera() : await this.setPerspectiveCamera(), this.onChanged.trigger(this.camera));
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const e = this.current === "Perspective" ? "Orthographic" : "Perspective";
    await this.set(e);
  }
  setOrthoCamera() {
    if (this._component.mode === null || this._component.mode.id === "FirstPerson")
      return;
    this._previousDistance = this._component.controls.distance, this._component.controls.distance = 200;
    const t = this.getPerspectiveDims();
    if (!t)
      return;
    const { width: e, height: s } = t;
    this.setupOrthoCamera(s, e), this.camera = this._component.threeOrtho, this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const t = this._component.currentWorld;
    if (!t || !t.renderer)
      return null;
    const e = new A.Vector3();
    this._component.threePersp.getWorldDirection(e);
    const s = new A.Vector3();
    this._component.controls.getTarget(s);
    const n = s.clone().sub(this._component.threePersp.position).dot(e), r = t.renderer.getSize(), o = r.x / r.y, a = this._component.threePersp, c = n * 2 * Math.atan(a.fov * (Math.PI / 180) / 2);
    return { width: c * o, height: c };
  }
  setupOrthoCamera(t, e) {
    this._component.controls.mouseButtons.wheel = De.ACTION.ZOOM, this._component.controls.mouseButtons.middle = De.ACTION.ZOOM, this._component.controls.touches.two = De.ACTION.TOUCH_ZOOM_TRUCK, this._component.controls.touches.three = De.ACTION.TOUCH_ZOOM_TRUCK, this._component.controls.dollySpeed = 5;
    const s = this._component.threePersp, i = this._component.threeOrtho;
    i.zoom = 1, i.left = e / -2, i.right = e / 2, i.top = t / 2, i.bottom = t / -2, i.updateProjectionMatrix(), i.position.copy(s.position), i.quaternion.copy(s.quaternion), this._component.controls.camera = i;
  }
  getDistance() {
    const t = this._component.threePersp, e = this._component.threeOrtho;
    return (e.top - e.bottom) / e.zoom / (2 * Math.atan(t.fov * (Math.PI / 180) / 2));
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = De.ACTION.DOLLY, this._component.controls.mouseButtons.middle = De.ACTION.DOLLY;
    const t = this._component.threePersp, e = this._component.threeOrtho;
    t.position.copy(e.position), t.quaternion.copy(e.quaternion), this._component.controls.mouseButtons.wheel = De.ACTION.DOLLY, this._component.controls.touches.two = De.ACTION.TOUCH_DOLLY_TRUCK, this._component.controls.touches.three = De.ACTION.TOUCH_DOLLY_TRUCK, this._component.controls.dollySpeed = 5, this.matchOrthoDistanceEnabled ? this._component.controls.distance = this.getDistance() : this._component.controls.distance = this._previousDistance, await this._component.controls.zoomTo(1), t.updateProjectionMatrix(), this._component.controls.camera = t, this.camera = t, this.current = "Perspective";
  }
}
class $u extends Ti {
  constructor(t) {
    super(t), y(this, "projection"), y(this, "threeOrtho"), y(this, "threePersp"), y(this, "_userInputButtons", {}), y(this, "_frustumSize", 50), y(this, "_navigationModes", /* @__PURE__ */ new Map()), y(this, "_mode", null), y(this, "previousSize", null), this.threePersp = this.three, this.threeOrtho = this.newOrthoCamera(), this.projection = new Ju(this), this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    }), this.projection.onChanged.add(
      (e) => {
        this.three = e, this.updateAspect();
      }
    ), this.onWorldChanged.add(({ action: e }) => {
      e === "added" && (this._navigationModes.clear(), this._navigationModes.set("Orbit", new Ku(this)), this._navigationModes.set("FirstPerson", new Qu(this)), this._navigationModes.set("Plan", new qu(this)), this._mode = this._navigationModes.get("Orbit"), this.mode.set(!0, { preventTargetAdjustment: !0 }), this.currentWorld && this.currentWorld.renderer && (this.previousSize = this.currentWorld.renderer.getSize().clone()));
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode)
      throw new Error("Mode not found, camera not initialized");
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(t) {
    if (this.mode !== null && this.mode.id !== t) {
      if (this.mode.set(!1), !this._navigationModes.has(t))
        throw new Error("The specified mode does not exist!");
      this._mode = this._navigationModes.get(t), this.mode.set(!0);
    }
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(t, e = 1.5) {
    if (!this.enabled)
      return;
    const s = Number.MAX_VALUE, i = Number.MIN_VALUE, n = new A.Vector3(s, s, s), r = new A.Vector3(i, i, i);
    for (const u of t) {
      const d = new A.Box3().setFromObject(u);
      d.min.x < n.x && (n.x = d.min.x), d.min.y < n.y && (n.y = d.min.y), d.min.z < n.z && (n.z = d.min.z), d.max.x > r.x && (r.x = d.max.x), d.max.y > r.y && (r.y = d.max.y), d.max.z > r.z && (r.z = d.max.z);
    }
    const o = new A.Box3(n, r), a = new A.Vector3();
    o.getSize(a);
    const c = new A.Vector3();
    o.getCenter(c);
    const h = Math.max(a.x, a.y, a.z) * e, f = new A.Sphere(c, h);
    await this.controls.fitToSphere(f, !0);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(t) {
    t ? this.enableUserInput() : this.disableUserInput();
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left, this._userInputButtons.right = this.controls.mouseButtons.right, this._userInputButtons.middle = this.controls.mouseButtons.middle, this._userInputButtons.wheel = this.controls.mouseButtons.wheel, this.controls.mouseButtons.left = 0, this.controls.mouseButtons.right = 0, this.controls.mouseButtons.middle = 0, this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    Object.keys(this._userInputButtons).length !== 0 && (this.controls.mouseButtons.left = this._userInputButtons.left, this.controls.mouseButtons.right = this._userInputButtons.right, this.controls.mouseButtons.middle = this._userInputButtons.middle, this.controls.mouseButtons.wheel = this._userInputButtons.wheel);
  }
  newOrthoCamera() {
    const t = window.innerWidth / window.innerHeight;
    return new A.OrthographicCamera(
      this._frustumSize * t / -2,
      this._frustumSize * t / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer || !this.previousSize)
      return;
    const t = this.currentWorld.renderer.getSize(), e = this.threeOrtho.top, s = this.threeOrtho.right, i = t.y / this.previousSize.y, n = t.x / this.previousSize.x, r = e * i, o = s * n;
    this.threeOrtho.left = -o, this.threeOrtho.right = o, this.threeOrtho.top = r, this.threeOrtho.bottom = -r, this.threeOrtho.updateProjectionMatrix(), this.previousSize.copy(t);
  }
}
const na = /* @__PURE__ */ new Map([
  [
    W.IFCRELAGGREGATES,
    {
      forRelated: "Decomposes",
      forRelating: "IsDecomposedBy"
    }
  ],
  [
    W.IFCRELASSOCIATESMATERIAL,
    {
      forRelated: "HasAssociations",
      forRelating: "AssociatedTo"
    }
  ],
  [
    W.IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelated: "HasAssociations",
      forRelating: "ClassificationForObjects"
    }
  ],
  [
    W.IFCRELASSIGNSTOGROUP,
    {
      forRelated: "HasAssignments",
      forRelating: "IsGroupedBy"
    }
  ],
  [
    W.IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    W.IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    W.IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    W.IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ],
  [
    W.IFCRELFLOWCONTROLELEMENTS,
    {
      forRelated: "AssignedToFlowElement",
      forRelating: "HasControlElements"
    }
  ],
  [
    W.IFCRELCONNECTSELEMENTS,
    {
      forRelated: "ConnectedFrom",
      forRelating: "ConnectedTo"
    }
  ],
  [
    W.IFCRELASSIGNSTOPRODUCT,
    {
      forRelated: "HasAssignments",
      forRelating: "ReferencedBy"
    }
  ],
  [
    W.IFCRELDECLARES,
    {
      forRelated: "HasContext",
      forRelating: "Declares"
    }
  ],
  [
    W.IFCRELASSIGNSTOCONTROL,
    {
      forRelated: "HasAssignments",
      forRelating: "Controls"
    }
  ],
  [
    W.IFCRELNESTS,
    {
      forRelated: "Nests",
      forRelating: "IsNestedBy"
    }
  ],
  [
    W.IFCRELASSOCIATESDOCUMENT,
    {
      forRelated: "HasAssociations",
      forRelating: "DocumentRefForObjects"
    }
  ]
]), Cn = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
class cs {
  static async getUnits(t) {
    var e, s, i;
    const { IFCUNITASSIGNMENT: n } = W, r = await t.getAllPropertiesOfType(n);
    if (!r)
      return 1;
    const o = Object.keys(r), a = r[parseInt(o[0], 10)];
    for (const c of a.Units) {
      if (c.value === void 0 || c.value === null)
        continue;
      const h = await t.getProperties(c.value);
      if (!h || !h.UnitType || !h.UnitType.value || h.UnitType.value !== "LENGTHUNIT")
        continue;
      let u = 1, d = 1;
      return h.Name.value === "METRE" && (d = 1), h.Name.value === "FOOT" && (d = 0.3048), ((e = h.Prefix) == null ? void 0 : e.value) === "MILLI" ? u = 1e-3 : ((s = h.Prefix) == null ? void 0 : s.value) === "CENTI" ? u = 0.01 : ((i = h.Prefix) == null ? void 0 : i.value) === "DECI" && (u = 0.1), d * u;
    }
    return 1;
  }
  static async findItemByGuid(t, e) {
    var s;
    const i = t.getAllPropertiesIDs();
    for (const n of i) {
      const r = await t.getProperties(n);
      if (r && ((s = r.GlobalId) == null ? void 0 : s.value) === e)
        return r;
    }
    return null;
  }
  static async getRelationMap(t, e, s) {
    var i;
    const r = s ?? (async () => {
    }), o = {}, a = t.getAllPropertiesIDs();
    for (const c of a) {
      const h = await t.getProperties(c);
      if (!h)
        continue;
      const f = h.type === e, u = Object.keys(h).find(
        (I) => I.startsWith("Relating")
      ), d = Object.keys(h).find(
        (I) => I.startsWith("Related")
      );
      if (!(f && u && d))
        continue;
      const p = await t.getProperties((i = h[u]) == null ? void 0 : i.value), m = h[d];
      if (!p || !m || !(m && Array.isArray(m)))
        continue;
      const E = m.map((I) => I.value);
      await r(p.expressID, E), o[p.expressID] = E;
    }
    return o;
  }
  static async getQsetQuantities(t, e, s) {
    const n = s ?? (() => {
    }), r = await t.getProperties(e);
    return !r || r.type !== W.IFCELEMENTQUANTITY ? null : (r.Quantities ?? [{}]).map((c) => (c.value && n(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetProps(t, e, s) {
    const n = s ?? (() => {
    }), r = await t.getProperties(e);
    return !r || r.type !== W.IFCPROPERTYSET ? null : (r.HasProperties ?? [{}]).map((c) => (c.value && n(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetRel(t, e) {
    var s;
    if (!await t.getProperties(e))
      return null;
    const n = await t.getAllPropertiesOfType(
      W.IFCRELDEFINESBYPROPERTIES
    );
    if (!n)
      return null;
    const r = Object.values(n);
    let o = null;
    for (const a of r)
      ((s = a.RelatingPropertyDefinition) == null ? void 0 : s.value) === e && (o = a.expressID);
    return o;
  }
  static async getQsetRel(t, e) {
    return cs.getPsetRel(t, e);
  }
  static async getEntityName(t, e) {
    var s;
    const i = await t.getProperties(e);
    if (!i)
      return { key: null, name: null };
    const n = Object.keys(i).find((o) => o.endsWith("Name")) ?? null, r = n ? (s = i[n]) == null ? void 0 : s.value : null;
    return { key: n, name: r };
  }
  static async getQuantityValue(t, e) {
    const s = await t.getProperties(e);
    if (!s)
      return { key: null, value: null };
    const i = Object.keys(s).find((r) => r.endsWith("Value")) ?? null;
    let n;
    return i === null || s[i] === void 0 || s[i] === null ? n = null : n = s[i].value, { key: i, value: n };
  }
  static isRel(t) {
    return Cn[t].startsWith("IFCREL");
  }
  static async attributeExists(t, e, s) {
    const i = await t.getProperties(e);
    return i ? Object.keys(i).includes(s) : !1;
  }
  static async groupEntitiesByType(t, e) {
    var s;
    const i = /* @__PURE__ */ new Map();
    for (const n of e) {
      const r = await t.getProperties(n);
      if (!r)
        continue;
      const o = r.type;
      i.get(o) || i.set(o, /* @__PURE__ */ new Set()), (s = i.get(o)) == null || s.add(n);
    }
    return i;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
}
const ef = {
  IFCURIREFERENCE: "IfcUriReference",
  IFCTIME: "IfcTime",
  IFCTEMPERATURERATEOFCHANGEMEASURE: "IfcTemperatureRateOfChangeMeasure",
  IFCSOUNDPRESSURELEVELMEASURE: "IfcSoundPressureLevelMeasure",
  IFCSOUNDPOWERLEVELMEASURE: "IfcSoundPowerLevelMeasure",
  IFCPROPERTYSETDEFINITIONSET: "IfcPropertySetDefinitionSet",
  IFCPOSITIVEINTEGER: "IfcPositiveInteger",
  IFCNONNEGATIVELENGTHMEASURE: "IfcNonNegativeLengthMeasure",
  IFCLINEINDEX: "IfcLineIndex",
  IFCLANGUAGEID: "IfcLanguageId",
  IFCDURATION: "IfcDuration",
  IFCDAYINWEEKNUMBER: "IfcDayInWeekNumber",
  IFCDATETIME: "IfcDateTime",
  IFCDATE: "IfcDate",
  IFCCARDINALPOINTREFERENCE: "IfcCardinalPointReference",
  IFCBINARY: "IfcBinary",
  IFCAREADENSITYMEASURE: "IfcAreaDensityMeasure",
  IFCARCINDEX: "IfcArcIndex",
  IFCYEARNUMBER: "IfcYearNumber",
  IFCWARPINGMOMENTMEASURE: "IfcWarpingMomentMeasure",
  IFCWARPINGCONSTANTMEASURE: "IfcWarpingConstantMeasure",
  IFCVOLUMETRICFLOWRATEMEASURE: "IfcVolumetricFlowRateMeasure",
  IFCVOLUMEMEASURE: "IfcVolumeMeasure",
  IFCVAPORPERMEABILITYMEASURE: "IfcVaporPermeabilityMeasure",
  IFCTORQUEMEASURE: "IfcTorqueMeasure",
  IFCTIMESTAMP: "IfcTimestamp",
  IFCTIMEMEASURE: "IfcTimeMeasure",
  IFCTHERMODYNAMICTEMPERATUREMEASURE: "IfcThermodynamicTemperatureMeasure",
  IFCTHERMALTRANSMITTANCEMEASURE: "IfcThermalTransmittanceMeasure",
  IFCTHERMALRESISTANCEMEASURE: "IfcThermalResistanceMeasure",
  IFCTHERMALEXPANSIONCOEFFICIENTMEASURE: "IfcThermalExpansionCoefficientMeasure",
  IFCTHERMALCONDUCTIVITYMEASURE: "IfcThermalConductivityMeasure",
  IFCTHERMALADMITTANCEMEASURE: "IfcThermalAdmittanceMeasure",
  IFCTEXTTRANSFORMATION: "IfcTextTransformation",
  IFCTEXTFONTNAME: "IfcTextFontName",
  IFCTEXTDECORATION: "IfcTextDecoration",
  IFCTEXTALIGNMENT: "IfcTextAlignment",
  IFCTEXT: "IfcText",
  IFCTEMPERATUREGRADIENTMEASURE: "IfcTemperatureGradientMeasure",
  IFCSPECULARROUGHNESS: "IfcSpecularRoughness",
  IFCSPECULAREXPONENT: "IfcSpecularExponent",
  IFCSPECIFICHEATCAPACITYMEASURE: "IfcSpecificHeatCapacityMeasure",
  IFCSOUNDPRESSUREMEASURE: "IfcSoundPressureMeasure",
  IFCSOUNDPOWERMEASURE: "IfcSoundPowerMeasure",
  IFCSOLIDANGLEMEASURE: "IfcSolidAngleMeasure",
  IFCSHEARMODULUSMEASURE: "IfcShearModulusMeasure",
  IFCSECTIONALAREAINTEGRALMEASURE: "IfcSectionalAreaIntegralMeasure",
  IFCSECTIONMODULUSMEASURE: "IfcSectionModulusMeasure",
  IFCSECONDINMINUTE: "IfcSecondInMinute",
  IFCROTATIONALSTIFFNESSMEASURE: "IfcRotationalStiffnessMeasure",
  IFCROTATIONALMASSMEASURE: "IfcRotationalMassMeasure",
  IFCROTATIONALFREQUENCYMEASURE: "IfcRotationalFrequencyMeasure",
  IFCREAL: "IfcReal",
  IFCRATIOMEASURE: "IfcRatioMeasure",
  IFCRADIOACTIVITYMEASURE: "IfcRadioactivityMeasure",
  IFCPRESSUREMEASURE: "IfcPressureMeasure",
  IFCPRESENTABLETEXT: "IfcPresentableText",
  IFCPOWERMEASURE: "IfcPowerMeasure",
  IFCPOSITIVERATIOMEASURE: "IfcPositiveRatioMeasure",
  IFCPOSITIVEPLANEANGLEMEASURE: "IfcPositivePlaneAngleMeasure",
  IFCPOSITIVELENGTHMEASURE: "IfcPositiveLengthMeasure",
  IFCPLANEANGLEMEASURE: "IfcPlaneAngleMeasure",
  IFCPLANARFORCEMEASURE: "IfcPlanarForceMeasure",
  IFCPARAMETERVALUE: "IfcParameterValue",
  IFCPHMEASURE: "IfcPhMeasure",
  IFCNUMERICMEASURE: "IfcNumericMeasure",
  IFCNORMALISEDRATIOMEASURE: "IfcNormalisedRatioMeasure",
  IFCMONTHINYEARNUMBER: "IfcMonthInYearNumber",
  IFCMONETARYMEASURE: "IfcMonetaryMeasure",
  IFCMOMENTOFINERTIAMEASURE: "IfcMomentOfInertiaMeasure",
  IFCMOLECULARWEIGHTMEASURE: "IfcMolecularWeightMeasure",
  IFCMOISTUREDIFFUSIVITYMEASURE: "IfcMoistureDiffusivityMeasure",
  IFCMODULUSOFSUBGRADEREACTIONMEASURE: "IfcModulusOfSubgradeReactionMeasure",
  IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE: "IfcModulusOfRotationalSubgradeReactionMeasure",
  IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE: "IfcModulusOfLinearSubgradeReactionMeasure",
  IFCMODULUSOFELASTICITYMEASURE: "IfcModulusOfElasticityMeasure",
  IFCMINUTEINHOUR: "IfcMinuteInHour",
  IFCMASSPERLENGTHMEASURE: "IfcMassPerLengthMeasure",
  IFCMASSMEASURE: "IfcMassMeasure",
  IFCMASSFLOWRATEMEASURE: "IfcMassFlowRateMeasure",
  IFCMASSDENSITYMEASURE: "IfcMassDensityMeasure",
  IFCMAGNETICFLUXMEASURE: "IfcMagneticFluxMeasure",
  IFCMAGNETICFLUXDENSITYMEASURE: "IfcMagneticFluxDensityMeasure",
  IFCLUMINOUSINTENSITYMEASURE: "IfcLuminousIntensityMeasure",
  IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE: "IfcLuminousIntensityDistributionMeasure",
  IFCLUMINOUSFLUXMEASURE: "IfcLuminousFluxMeasure",
  IFCLOGICAL: "IfcLogical",
  IFCLINEARVELOCITYMEASURE: "IfcLinearVelocityMeasure",
  IFCLINEARSTIFFNESSMEASURE: "IfcLinearStiffnessMeasure",
  IFCLINEARMOMENTMEASURE: "IfcLinearMomentMeasure",
  IFCLINEARFORCEMEASURE: "IfcLinearForceMeasure",
  IFCLENGTHMEASURE: "IfcLengthMeasure",
  IFCLABEL: "IfcLabel",
  IFCKINEMATICVISCOSITYMEASURE: "IfcKinematicViscosityMeasure",
  IFCISOTHERMALMOISTURECAPACITYMEASURE: "IfcIsothermalMoistureCapacityMeasure",
  IFCIONCONCENTRATIONMEASURE: "IfcIonConcentrationMeasure",
  IFCINTEGERCOUNTRATEMEASURE: "IfcIntegerCountRateMeasure",
  IFCINTEGER: "IfcInteger",
  IFCINDUCTANCEMEASURE: "IfcInductanceMeasure",
  IFCILLUMINANCEMEASURE: "IfcIlluminanceMeasure",
  IFCIDENTIFIER: "IfcIdentifier",
  IFCHOURINDAY: "IfcHourInDay",
  IFCHEATINGVALUEMEASURE: "IfcHeatingValueMeasure",
  IFCHEATFLUXDENSITYMEASURE: "IfcHeatFluxDensityMeasure",
  IFCGLOBALLYUNIQUEID: "IfcGloballyUniqueId",
  IFCFREQUENCYMEASURE: "IfcFrequencyMeasure",
  IFCFORCEMEASURE: "IfcForceMeasure",
  IFCFONTWEIGHT: "IfcFontWeight",
  IFCFONTVARIANT: "IfcFontVariant",
  IFCFONTSTYLE: "IfcFontStyle",
  IFCENERGYMEASURE: "IfcEnergyMeasure",
  IFCELECTRICVOLTAGEMEASURE: "IfcElectricVoltageMeasure",
  IFCELECTRICRESISTANCEMEASURE: "IfcElectricResistanceMeasure",
  IFCELECTRICCURRENTMEASURE: "IfcElectricCurrentMeasure",
  IFCELECTRICCONDUCTANCEMEASURE: "IfcElectricConductanceMeasure",
  IFCELECTRICCHARGEMEASURE: "IfcElectricChargeMeasure",
  IFCELECTRICCAPACITANCEMEASURE: "IfcElectricCapacitanceMeasure",
  IFCDYNAMICVISCOSITYMEASURE: "IfcDynamicViscosityMeasure",
  IFCDOSEEQUIVALENTMEASURE: "IfcDoseEquivalentMeasure",
  IFCDIMENSIONCOUNT: "IfcDimensionCount",
  IFCDESCRIPTIVEMEASURE: "IfcDescriptiveMeasure",
  IFCDAYLIGHTSAVINGHOUR: "IfcDaylightSavingHour",
  IFCDAYINMONTHNUMBER: "IfcDayInMonthNumber",
  IFCCURVATUREMEASURE: "IfcCurvatureMeasure",
  IFCCOUNTMEASURE: "IfcCountMeasure",
  IFCCONTEXTDEPENDENTMEASURE: "IfcContextDependentMeasure",
  IFCCOMPOUNDPLANEANGLEMEASURE: "IfcCompoundPlaneAngleMeasure",
  IFCCOMPLEXNUMBER: "IfcComplexNumber",
  IFCBOXALIGNMENT: "IfcBoxAlignment",
  IFCBOOLEAN: "IfcBoolean",
  IFCAREAMEASURE: "IfcAreaMeasure",
  IFCANGULARVELOCITYMEASURE: "IfcAngularVelocityMeasure",
  IFCAMOUNTOFSUBSTANCEMEASURE: "IfcAmountOfSubstanceMeasure",
  IFCACCELERATIONMEASURE: "IfcAccelerationMeasure",
  IFCABSORBEDDOSEMEASURE: "IfcAbsorbedDoseMeasure",
  IFCGEOSLICE: "IfcGeoSlice",
  IFCGEOMODEL: "IfcGeoModel",
  IFCELECTRICFLOWTREATMENTDEVICE: "IfcElectricFlowTreatmentDevice",
  IFCDISTRIBUTIONBOARD: "IfcDistributionBoard",
  IFCCONVEYORSEGMENT: "IfcConveyorSegment",
  IFCCAISSONFOUNDATION: "IfcCaissonFoundation",
  IFCBOREHOLE: "IfcBorehole",
  IFCBEARING: "IfcBearing",
  IFCALIGNMENT: "IfcAlignment",
  IFCTRACKELEMENT: "IfcTrackElement",
  IFCSIGNAL: "IfcSignal",
  IFCREINFORCEDSOIL: "IfcReinforcedSoil",
  IFCRAIL: "IfcRail",
  IFCPAVEMENT: "IfcPavement",
  IFCNAVIGATIONELEMENT: "IfcNavigationElement",
  IFCMOORINGDEVICE: "IfcMooringDevice",
  IFCMOBILETELECOMMUNICATIONSAPPLIANCE: "IfcMobileTelecommunicationsAppliance",
  IFCLIQUIDTERMINAL: "IfcLiquidTerminal",
  IFCLINEARPOSITIONINGELEMENT: "IfcLinearPositioningElement",
  IFCKERB: "IfcKerb",
  IFCGEOTECHNICALASSEMBLY: "IfcGeotechnicalAssembly",
  IFCELECTRICFLOWTREATMENTDEVICETYPE: "IfcElectricFlowTreatmentDeviceType",
  IFCEARTHWORKSFILL: "IfcEarthworksFill",
  IFCEARTHWORKSELEMENT: "IfcEarthworksElement",
  IFCEARTHWORKSCUT: "IfcEarthworksCut",
  IFCDISTRIBUTIONBOARDTYPE: "IfcDistributionBoardType",
  IFCDEEPFOUNDATION: "IfcDeepFoundation",
  IFCCOURSE: "IfcCourse",
  IFCCONVEYORSEGMENTTYPE: "IfcConveyorSegmentType",
  IFCCAISSONFOUNDATIONTYPE: "IfcCaissonFoundationType",
  IFCBUILTSYSTEM: "IfcBuiltSystem",
  IFCBUILTELEMENT: "IfcBuiltElement",
  IFCBRIDGEPART: "IfcBridgePart",
  IFCBRIDGE: "IfcBridge",
  IFCBEARINGTYPE: "IfcBearingType",
  IFCALIGNMENTVERTICAL: "IfcAlignmentVertical",
  IFCALIGNMENTSEGMENT: "IfcAlignmentSegment",
  IFCALIGNMENTHORIZONTAL: "IfcAlignmentHorizontal",
  IFCALIGNMENTCANT: "IfcAlignmentCant",
  IFCVIBRATIONDAMPERTYPE: "IfcVibrationDamperType",
  IFCVIBRATIONDAMPER: "IfcVibrationDamper",
  IFCVEHICLE: "IfcVehicle",
  IFCTRANSPORTATIONDEVICE: "IfcTransportationDevice",
  IFCTRACKELEMENTTYPE: "IfcTrackElementType",
  IFCTENDONCONDUITTYPE: "IfcTendonConduitType",
  IFCTENDONCONDUIT: "IfcTendonConduit",
  IFCSINESPIRAL: "IfcSineSpiral",
  IFCSIGNALTYPE: "IfcSignalType",
  IFCSIGNTYPE: "IfcSignType",
  IFCSIGN: "IfcSign",
  IFCSEVENTHORDERPOLYNOMIALSPIRAL: "IfcSeventhOrderPolynomialSpiral",
  IFCSEGMENTEDREFERENCECURVE: "IfcSegmentedReferenceCurve",
  IFCSECONDORDERPOLYNOMIALSPIRAL: "IfcSecondOrderPolynomialSpiral",
  IFCROADPART: "IfcRoadPart",
  IFCROAD: "IfcRoad",
  IFCRELADHERESTOELEMENT: "IfcRelAdheresToElement",
  IFCREFERENT: "IfcReferent",
  IFCRAILWAYPART: "IfcRailwayPart",
  IFCRAILWAY: "IfcRailway",
  IFCRAILTYPE: "IfcRailType",
  IFCPOSITIONINGELEMENT: "IfcPositioningElement",
  IFCPAVEMENTTYPE: "IfcPavementType",
  IFCNAVIGATIONELEMENTTYPE: "IfcNavigationElementType",
  IFCMOORINGDEVICETYPE: "IfcMooringDeviceType",
  IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE: "IfcMobileTelecommunicationsApplianceType",
  IFCMARINEPART: "IfcMarinePart",
  IFCMARINEFACILITY: "IfcMarineFacility",
  IFCLIQUIDTERMINALTYPE: "IfcLiquidTerminalType",
  IFCLINEARELEMENT: "IfcLinearElement",
  IFCKERBTYPE: "IfcKerbType",
  IFCIMPACTPROTECTIONDEVICETYPE: "IfcImpactProtectionDeviceType",
  IFCIMPACTPROTECTIONDEVICE: "IfcImpactProtectionDevice",
  IFCGRADIENTCURVE: "IfcGradientCurve",
  IFCGEOTECHNICALSTRATUM: "IfcGeotechnicalStratum",
  IFCGEOTECHNICALELEMENT: "IfcGeotechnicalElement",
  IFCFACILITYPARTCOMMON: "IfcFacilityPartCommon",
  IFCFACILITYPART: "IfcFacilityPart",
  IFCFACILITY: "IfcFacility",
  IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID: "IfcDirectrixDerivedReferenceSweptAreaSolid",
  IFCDEEPFOUNDATIONTYPE: "IfcDeepFoundationType",
  IFCCOURSETYPE: "IfcCourseType",
  IFCCOSINESPIRAL: "IfcCosineSpiral",
  IFCCLOTHOID: "IfcClothoid",
  IFCBUILTELEMENTTYPE: "IfcBuiltElementType",
  IFCVEHICLETYPE: "IfcVehicleType",
  IFCTRIANGULATEDIRREGULARNETWORK: "IfcTriangulatedIrregularNetwork",
  IFCTRANSPORTATIONDEVICETYPE: "IfcTransportationDeviceType",
  IFCTHIRDORDERPOLYNOMIALSPIRAL: "IfcThirdOrderPolynomialSpiral",
  IFCSPIRAL: "IfcSpiral",
  IFCSECTIONEDSURFACE: "IfcSectionedSurface",
  IFCSECTIONEDSOLIDHORIZONTAL: "IfcSectionedSolidHorizontal",
  IFCSECTIONEDSOLID: "IfcSectionedSolid",
  IFCRELPOSITIONS: "IfcRelPositions",
  IFCRELASSOCIATESPROFILEDEF: "IfcRelAssociatesProfileDef",
  IFCPOLYNOMIALCURVE: "IfcPolynomialCurve",
  IFCOFFSETCURVEBYDISTANCES: "IfcOffsetCurveByDistances",
  IFCOFFSETCURVE: "IfcOffsetCurve",
  IFCINDEXEDPOLYGONALTEXTUREMAP: "IfcIndexedPolygonalTextureMap",
  IFCDIRECTRIXCURVESWEPTAREASOLID: "IfcDirectrixCurveSweptAreaSolid",
  IFCCURVESEGMENT: "IfcCurveSegment",
  IFCAXIS2PLACEMENTLINEAR: "IfcAxis2PlacementLinear",
  IFCSEGMENT: "IfcSegment",
  IFCPOINTBYDISTANCEEXPRESSION: "IfcPointByDistanceExpression",
  IFCOPENCROSSPROFILEDEF: "IfcOpenCrossProfileDef",
  IFCLINEARPLACEMENT: "IfcLinearPlacement",
  IFCALIGNMENTHORIZONTALSEGMENT: "IfcAlignmentHorizontalSegment",
  IFCALIGNMENTCANTSEGMENT: "IfcAlignmentCantSegment",
  IFCTEXTURECOORDINATEINDICESWITHVOIDS: "IfcTextureCoordinateIndicesWithVoids",
  IFCTEXTURECOORDINATEINDICES: "IfcTextureCoordinateIndices",
  IFCQUANTITYNUMBER: "IfcQuantityNumber",
  IFCALIGNMENTVERTICALSEGMENT: "IfcAlignmentVerticalSegment",
  IFCALIGNMENTPARAMETERSEGMENT: "IfcAlignmentParameterSegment",
  IFCCONTROLLER: "IfcController",
  IFCALARM: "IfcAlarm",
  IFCACTUATOR: "IfcActuator",
  IFCUNITARYCONTROLELEMENT: "IfcUnitaryControlElement",
  IFCSENSOR: "IfcSensor",
  IFCPROTECTIVEDEVICETRIPPINGUNIT: "IfcProtectiveDeviceTrippingUnit",
  IFCFLOWINSTRUMENT: "IfcFlowInstrument",
  IFCFIRESUPPRESSIONTERMINAL: "IfcFireSuppressionTerminal",
  IFCFILTER: "IfcFilter",
  IFCFAN: "IfcFan",
  IFCELECTRICTIMECONTROL: "IfcElectricTimeControl",
  IFCELECTRICMOTOR: "IfcElectricMotor",
  IFCELECTRICGENERATOR: "IfcElectricGenerator",
  IFCELECTRICFLOWSTORAGEDEVICE: "IfcElectricFlowStorageDevice",
  IFCELECTRICDISTRIBUTIONBOARD: "IfcElectricDistributionBoard",
  IFCELECTRICAPPLIANCE: "IfcElectricAppliance",
  IFCDUCTSILENCER: "IfcDuctSilencer",
  IFCDUCTSEGMENT: "IfcDuctSegment",
  IFCDUCTFITTING: "IfcDuctFitting",
  IFCDISTRIBUTIONCIRCUIT: "IfcDistributionCircuit",
  IFCDAMPER: "IfcDamper",
  IFCCOOLINGTOWER: "IfcCoolingTower",
  IFCCOOLEDBEAM: "IfcCooledBeam",
  IFCCONDENSER: "IfcCondenser",
  IFCCOMPRESSOR: "IfcCompressor",
  IFCCOMMUNICATIONSAPPLIANCE: "IfcCommunicationsAppliance",
  IFCCOIL: "IfcCoil",
  IFCCHILLER: "IfcChiller",
  IFCCABLESEGMENT: "IfcCableSegment",
  IFCCABLEFITTING: "IfcCableFitting",
  IFCCABLECARRIERSEGMENT: "IfcCableCarrierSegment",
  IFCCABLECARRIERFITTING: "IfcCableCarrierFitting",
  IFCBURNER: "IfcBurner",
  IFCBOILER: "IfcBoiler",
  IFCBEAMSTANDARDCASE: "IfcBeamStandardCase",
  IFCAUDIOVISUALAPPLIANCE: "IfcAudioVisualAppliance",
  IFCAIRTOAIRHEATRECOVERY: "IfcAirToAirHeatRecovery",
  IFCAIRTERMINALBOX: "IfcAirTerminalBox",
  IFCAIRTERMINAL: "IfcAirTerminal",
  IFCWINDOWSTANDARDCASE: "IfcWindowStandardCase",
  IFCWASTETERMINAL: "IfcWasteTerminal",
  IFCWALLELEMENTEDCASE: "IfcWallElementedCase",
  IFCVALVE: "IfcValve",
  IFCUNITARYEQUIPMENT: "IfcUnitaryEquipment",
  IFCUNITARYCONTROLELEMENTTYPE: "IfcUnitaryControlElementType",
  IFCTUBEBUNDLE: "IfcTubeBundle",
  IFCTRANSFORMER: "IfcTransformer",
  IFCTANK: "IfcTank",
  IFCSWITCHINGDEVICE: "IfcSwitchingDevice",
  IFCSTRUCTURALLOADCASE: "IfcStructuralLoadCase",
  IFCSTACKTERMINAL: "IfcStackTerminal",
  IFCSPACEHEATER: "IfcSpaceHeater",
  IFCSOLARDEVICE: "IfcSolarDevice",
  IFCSLABSTANDARDCASE: "IfcSlabStandardCase",
  IFCSLABELEMENTEDCASE: "IfcSlabElementedCase",
  IFCSHADINGDEVICE: "IfcShadingDevice",
  IFCSANITARYTERMINAL: "IfcSanitaryTerminal",
  IFCREINFORCINGBARTYPE: "IfcReinforcingBarType",
  IFCRATIONALBSPLINECURVEWITHKNOTS: "IfcRationalBSplineCurveWithKnots",
  IFCPUMP: "IfcPump",
  IFCPROTECTIVEDEVICETRIPPINGUNITTYPE: "IfcProtectiveDeviceTrippingUnitType",
  IFCPROTECTIVEDEVICE: "IfcProtectiveDevice",
  IFCPLATESTANDARDCASE: "IfcPlateStandardCase",
  IFCPIPESEGMENT: "IfcPipeSegment",
  IFCPIPEFITTING: "IfcPipeFitting",
  IFCOUTLET: "IfcOutlet",
  IFCOUTERBOUNDARYCURVE: "IfcOuterBoundaryCurve",
  IFCMOTORCONNECTION: "IfcMotorConnection",
  IFCMEMBERSTANDARDCASE: "IfcMemberStandardCase",
  IFCMEDICALDEVICE: "IfcMedicalDevice",
  IFCLIGHTFIXTURE: "IfcLightFixture",
  IFCLAMP: "IfcLamp",
  IFCJUNCTIONBOX: "IfcJunctionBox",
  IFCINTERCEPTOR: "IfcInterceptor",
  IFCHUMIDIFIER: "IfcHumidifier",
  IFCHEATEXCHANGER: "IfcHeatExchanger",
  IFCFLOWMETER: "IfcFlowMeter",
  IFCEXTERNALSPATIALELEMENT: "IfcExternalSpatialElement",
  IFCEVAPORATOR: "IfcEvaporator",
  IFCEVAPORATIVECOOLER: "IfcEvaporativeCooler",
  IFCENGINE: "IfcEngine",
  IFCELECTRICDISTRIBUTIONBOARDTYPE: "IfcElectricDistributionBoardType",
  IFCDOORSTANDARDCASE: "IfcDoorStandardCase",
  IFCDISTRIBUTIONSYSTEM: "IfcDistributionSystem",
  IFCCOMMUNICATIONSAPPLIANCETYPE: "IfcCommunicationsApplianceType",
  IFCCOLUMNSTANDARDCASE: "IfcColumnStandardCase",
  IFCCIVILELEMENT: "IfcCivilElement",
  IFCCHIMNEY: "IfcChimney",
  IFCCABLEFITTINGTYPE: "IfcCableFittingType",
  IFCBURNERTYPE: "IfcBurnerType",
  IFCBUILDINGSYSTEM: "IfcBuildingSystem",
  IFCBUILDINGELEMENTPARTTYPE: "IfcBuildingElementPartType",
  IFCBOUNDARYCURVE: "IfcBoundaryCurve",
  IFCBSPLINECURVEWITHKNOTS: "IfcBSplineCurveWithKnots",
  IFCAUDIOVISUALAPPLIANCETYPE: "IfcAudioVisualApplianceType",
  IFCWORKCALENDAR: "IfcWorkCalendar",
  IFCWINDOWTYPE: "IfcWindowType",
  IFCVOIDINGFEATURE: "IfcVoidingFeature",
  IFCVIBRATIONISOLATOR: "IfcVibrationIsolator",
  IFCTENDONTYPE: "IfcTendonType",
  IFCTENDONANCHORTYPE: "IfcTendonAnchorType",
  IFCSYSTEMFURNITUREELEMENT: "IfcSystemFurnitureElement",
  IFCSURFACEFEATURE: "IfcSurfaceFeature",
  IFCSTRUCTURALSURFACEACTION: "IfcStructuralSurfaceAction",
  IFCSTRUCTURALCURVEREACTION: "IfcStructuralCurveReaction",
  IFCSTRUCTURALCURVEACTION: "IfcStructuralCurveAction",
  IFCSTAIRTYPE: "IfcStairType",
  IFCSOLARDEVICETYPE: "IfcSolarDeviceType",
  IFCSHADINGDEVICETYPE: "IfcShadingDeviceType",
  IFCSEAMCURVE: "IfcSeamCurve",
  IFCROOFTYPE: "IfcRoofType",
  IFCREINFORCINGMESHTYPE: "IfcReinforcingMeshType",
  IFCREINFORCINGELEMENTTYPE: "IfcReinforcingElementType",
  IFCRATIONALBSPLINESURFACEWITHKNOTS: "IfcRationalBSplineSurfaceWithKnots",
  IFCRAMPTYPE: "IfcRampType",
  IFCPOLYGONALFACESET: "IfcPolygonalFaceSet",
  IFCPILETYPE: "IfcPileType",
  IFCOPENINGSTANDARDCASE: "IfcOpeningStandardCase",
  IFCMEDICALDEVICETYPE: "IfcMedicalDeviceType",
  IFCINTERSECTIONCURVE: "IfcIntersectionCurve",
  IFCINTERCEPTORTYPE: "IfcInterceptorType",
  IFCINDEXEDPOLYCURVE: "IfcIndexedPolyCurve",
  IFCGEOGRAPHICELEMENT: "IfcGeographicElement",
  IFCFURNITURE: "IfcFurniture",
  IFCFOOTINGTYPE: "IfcFootingType",
  IFCEXTERNALSPATIALSTRUCTUREELEMENT: "IfcExternalSpatialStructureElement",
  IFCEVENT: "IfcEvent",
  IFCENGINETYPE: "IfcEngineType",
  IFCELEMENTASSEMBLYTYPE: "IfcElementAssemblyType",
  IFCDOORTYPE: "IfcDoorType",
  IFCCYLINDRICALSURFACE: "IfcCylindricalSurface",
  IFCCONSTRUCTIONPRODUCTRESOURCETYPE: "IfcConstructionProductResourceType",
  IFCCONSTRUCTIONMATERIALRESOURCETYPE: "IfcConstructionMaterialResourceType",
  IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE: "IfcConstructionEquipmentResourceType",
  IFCCOMPOSITECURVEONSURFACE: "IfcCompositeCurveOnSurface",
  IFCCOMPLEXPROPERTYTEMPLATE: "IfcComplexPropertyTemplate",
  IFCCIVILELEMENTTYPE: "IfcCivilElementType",
  IFCCHIMNEYTYPE: "IfcChimneyType",
  IFCBSPLINESURFACEWITHKNOTS: "IfcBSplineSurfaceWithKnots",
  IFCBSPLINESURFACE: "IfcBSplineSurface",
  IFCADVANCEDBREPWITHVOIDS: "IfcAdvancedBrepWithVoids",
  IFCADVANCEDBREP: "IfcAdvancedBrep",
  IFCTRIANGULATEDFACESET: "IfcTriangulatedFaceSet",
  IFCTOROIDALSURFACE: "IfcToroidalSurface",
  IFCTESSELLATEDFACESET: "IfcTessellatedFaceSet",
  IFCTASKTYPE: "IfcTaskType",
  IFCSURFACECURVE: "IfcSurfaceCurve",
  IFCSUBCONTRACTRESOURCETYPE: "IfcSubContractResourceType",
  IFCSTRUCTURALSURFACEREACTION: "IfcStructuralSurfaceReaction",
  IFCSPHERICALSURFACE: "IfcSphericalSurface",
  IFCSPATIALZONETYPE: "IfcSpatialZoneType",
  IFCSPATIALZONE: "IfcSpatialZone",
  IFCSPATIALELEMENTTYPE: "IfcSpatialElementType",
  IFCSPATIALELEMENT: "IfcSpatialElement",
  IFCSIMPLEPROPERTYTEMPLATE: "IfcSimplePropertyTemplate",
  IFCREVOLVEDAREASOLIDTAPERED: "IfcRevolvedAreaSolidTapered",
  IFCREPARAMETRISEDCOMPOSITECURVESEGMENT: "IfcReparametrisedCompositeCurveSegment",
  IFCRELSPACEBOUNDARY2NDLEVEL: "IfcRelSpaceBoundary2ndLevel",
  IFCRELSPACEBOUNDARY1STLEVEL: "IfcRelSpaceBoundary1stLevel",
  IFCRELINTERFERESELEMENTS: "IfcRelInterferesElements",
  IFCRELDEFINESBYTEMPLATE: "IfcRelDefinesByTemplate",
  IFCRELDEFINESBYOBJECT: "IfcRelDefinesByObject",
  IFCRELDECLARES: "IfcRelDeclares",
  IFCRELASSIGNSTOGROUPBYFACTOR: "IfcRelAssignsToGroupByFactor",
  IFCPROPERTYTEMPLATE: "IfcPropertyTemplate",
  IFCPROPERTYSETTEMPLATE: "IfcPropertySetTemplate",
  IFCPROJECTLIBRARY: "IfcProjectLibrary",
  IFCPROCEDURETYPE: "IfcProcedureType",
  IFCPREDEFINEDPROPERTYSET: "IfcPredefinedPropertySet",
  IFCPCURVE: "IfcPCurve",
  IFCLABORRESOURCETYPE: "IfcLaborResourceType",
  IFCINDEXEDPOLYGONALFACEWITHVOIDS: "IfcIndexedPolygonalFaceWithVoids",
  IFCINDEXEDPOLYGONALFACE: "IfcIndexedPolygonalFace",
  IFCGEOGRAPHICELEMENTTYPE: "IfcGeographicElementType",
  IFCFIXEDREFERENCESWEPTAREASOLID: "IfcFixedReferenceSweptAreaSolid",
  IFCEXTRUDEDAREASOLIDTAPERED: "IfcExtrudedAreaSolidTapered",
  IFCEVENTTYPE: "IfcEventType",
  IFCCURVEBOUNDEDSURFACE: "IfcCurveBoundedSurface",
  IFCCREWRESOURCETYPE: "IfcCrewResourceType",
  IFCCONTEXT: "IfcContext",
  IFCCONSTRUCTIONRESOURCETYPE: "IfcConstructionResourceType",
  IFCCARTESIANPOINTLIST3D: "IfcCartesianPointList3D",
  IFCCARTESIANPOINTLIST2D: "IfcCartesianPointList2D",
  IFCCARTESIANPOINTLIST: "IfcCartesianPointList",
  IFCADVANCEDFACE: "IfcAdvancedFace",
  IFCTYPERESOURCE: "IfcTypeResource",
  IFCTYPEPROCESS: "IfcTypeProcess",
  IFCTESSELLATEDITEM: "IfcTessellatedItem",
  IFCSWEPTDISKSOLIDPOLYGONAL: "IfcSweptDiskSolidPolygonal",
  IFCRESOURCETIME: "IfcResourceTime",
  IFCRESOURCECONSTRAINTRELATIONSHIP: "IfcResourceConstraintRelationship",
  IFCRESOURCEAPPROVALRELATIONSHIP: "IfcResourceApprovalRelationship",
  IFCQUANTITYSET: "IfcQuantitySet",
  IFCPROPERTYTEMPLATEDEFINITION: "IfcPropertyTemplateDefinition",
  IFCPREDEFINEDPROPERTIES: "IfcPredefinedProperties",
  IFCMIRROREDPROFILEDEF: "IfcMirroredProfileDef",
  IFCMATERIALRELATIONSHIP: "IfcMaterialRelationship",
  IFCMATERIALPROFILESETUSAGETAPERING: "IfcMaterialProfileSetUsageTapering",
  IFCMATERIALPROFILESETUSAGE: "IfcMaterialProfileSetUsage",
  IFCMATERIALCONSTITUENTSET: "IfcMaterialConstituentSet",
  IFCMATERIALCONSTITUENT: "IfcMaterialConstituent",
  IFCLAGTIME: "IfcLagTime",
  IFCINDEXEDTRIANGLETEXTUREMAP: "IfcIndexedTriangleTextureMap",
  IFCINDEXEDTEXTUREMAP: "IfcIndexedTextureMap",
  IFCINDEXEDCOLOURMAP: "IfcIndexedColourMap",
  IFCEXTERNALREFERENCERELATIONSHIP: "IfcExternalReferenceRelationship",
  IFCEXTENDEDPROPERTIES: "IfcExtendedProperties",
  IFCEVENTTIME: "IfcEventTime",
  IFCCONVERSIONBASEDUNITWITHOFFSET: "IfcConversionBasedUnitWithOffset",
  IFCCOLOURRGBLIST: "IfcColourRgbList",
  IFCWORKTIME: "IfcWorkTime",
  IFCTIMEPERIOD: "IfcTimePeriod",
  IFCTEXTUREVERTEXLIST: "IfcTextureVertexList",
  IFCTASKTIMERECURRING: "IfcTaskTimeRecurring",
  IFCTASKTIME: "IfcTaskTime",
  IFCTABLECOLUMN: "IfcTableColumn",
  IFCSURFACEREINFORCEMENTAREA: "IfcSurfaceReinforcementArea",
  IFCSTRUCTURALLOADORRESULT: "IfcStructuralLoadOrResult",
  IFCSTRUCTURALLOADCONFIGURATION: "IfcStructuralLoadConfiguration",
  IFCSCHEDULINGTIME: "IfcSchedulingTime",
  IFCRESOURCELEVELRELATIONSHIP: "IfcResourceLevelRelationship",
  IFCREFERENCE: "IfcReference",
  IFCRECURRENCEPATTERN: "IfcRecurrencePattern",
  IFCPROPERTYABSTRACTION: "IfcPropertyAbstraction",
  IFCPROJECTEDCRS: "IfcProjectedCrs",
  IFCPRESENTATIONITEM: "IfcPresentationItem",
  IFCMATERIALUSAGEDEFINITION: "IfcMaterialUsageDefinition",
  IFCMATERIALPROFILEWITHOFFSETS: "IfcMaterialProfileWithOffsets",
  IFCMATERIALPROFILESET: "IfcMaterialProfileSet",
  IFCMATERIALPROFILE: "IfcMaterialProfile",
  IFCMATERIALLAYERWITHOFFSETS: "IfcMaterialLayerWithOffsets",
  IFCMATERIALDEFINITION: "IfcMaterialDefinition",
  IFCMAPCONVERSION: "IfcMapConversion",
  IFCEXTERNALINFORMATION: "IfcExternalInformation",
  IFCCOORDINATEREFERENCESYSTEM: "IfcCoordinateReferenceSystem",
  IFCCOORDINATEOPERATION: "IfcCoordinateOperation",
  IFCCONNECTIONVOLUMEGEOMETRY: "IfcConnectionVolumeGeometry",
  IFCREINFORCINGBAR: "IfcReinforcingBar",
  IFCELECTRICDISTRIBUTIONPOINT: "IfcElectricDistributionPoint",
  IFCDISTRIBUTIONCONTROLELEMENT: "IfcDistributionControlElement",
  IFCDISTRIBUTIONCHAMBERELEMENT: "IfcDistributionChamberElement",
  IFCCONTROLLERTYPE: "IfcControllerType",
  IFCCHAMFEREDGEFEATURE: "IfcChamferEdgeFeature",
  IFCBEAM: "IfcBeam",
  IFCALARMTYPE: "IfcAlarmType",
  IFCACTUATORTYPE: "IfcActuatorType",
  IFCWINDOW: "IfcWindow",
  IFCWALLSTANDARDCASE: "IfcWallStandardCase",
  IFCWALL: "IfcWall",
  IFCVIBRATIONISOLATORTYPE: "IfcVibrationIsolatorType",
  IFCTENDONANCHOR: "IfcTendonAnchor",
  IFCTENDON: "IfcTendon",
  IFCSTRUCTURALANALYSISMODEL: "IfcStructuralAnalysisModel",
  IFCSTAIRFLIGHT: "IfcStairFlight",
  IFCSTAIR: "IfcStair",
  IFCSLAB: "IfcSlab",
  IFCSENSORTYPE: "IfcSensorType",
  IFCROUNDEDEDGEFEATURE: "IfcRoundedEdgeFeature",
  IFCROOF: "IfcRoof",
  IFCREINFORCINGMESH: "IfcReinforcingMesh",
  IFCREINFORCINGELEMENT: "IfcReinforcingElement",
  IFCRATIONALBEZIERCURVE: "IfcRationalBezierCurve",
  IFCRAMPFLIGHT: "IfcRampFlight",
  IFCRAMP: "IfcRamp",
  IFCRAILING: "IfcRailing",
  IFCPLATE: "IfcPlate",
  IFCPILE: "IfcPile",
  IFCMEMBER: "IfcMember",
  IFCFOOTING: "IfcFooting",
  IFCFLOWTREATMENTDEVICE: "IfcFlowTreatmentDevice",
  IFCFLOWTERMINAL: "IfcFlowTerminal",
  IFCFLOWSTORAGEDEVICE: "IfcFlowStorageDevice",
  IFCFLOWSEGMENT: "IfcFlowSegment",
  IFCFLOWMOVINGDEVICE: "IfcFlowMovingDevice",
  IFCFLOWINSTRUMENTTYPE: "IfcFlowInstrumentType",
  IFCFLOWFITTING: "IfcFlowFitting",
  IFCFLOWCONTROLLER: "IfcFlowController",
  IFCFIRESUPPRESSIONTERMINALTYPE: "IfcFireSuppressionTerminalType",
  IFCFILTERTYPE: "IfcFilterType",
  IFCFANTYPE: "IfcFanType",
  IFCENERGYCONVERSIONDEVICE: "IfcEnergyConversionDevice",
  IFCELECTRICALELEMENT: "IfcElectricalElement",
  IFCELECTRICALCIRCUIT: "IfcElectricalCircuit",
  IFCELECTRICTIMECONTROLTYPE: "IfcElectricTimeControlType",
  IFCELECTRICMOTORTYPE: "IfcElectricMotorType",
  IFCELECTRICHEATERTYPE: "IfcElectricHeaterType",
  IFCELECTRICGENERATORTYPE: "IfcElectricGeneratorType",
  IFCELECTRICFLOWSTORAGEDEVICETYPE: "IfcElectricFlowStorageDeviceType",
  IFCELECTRICAPPLIANCETYPE: "IfcElectricApplianceType",
  IFCEDGEFEATURE: "IfcEdgeFeature",
  IFCDUCTSILENCERTYPE: "IfcDuctSilencerType",
  IFCDUCTSEGMENTTYPE: "IfcDuctSegmentType",
  IFCDUCTFITTINGTYPE: "IfcDuctFittingType",
  IFCDOOR: "IfcDoor",
  IFCDISTRIBUTIONPORT: "IfcDistributionPort",
  IFCDISTRIBUTIONFLOWELEMENT: "IfcDistributionFlowElement",
  IFCDISTRIBUTIONELEMENT: "IfcDistributionElement",
  IFCDISTRIBUTIONCONTROLELEMENTTYPE: "IfcDistributionControlElementType",
  IFCDISTRIBUTIONCHAMBERELEMENTTYPE: "IfcDistributionChamberElementType",
  IFCDISCRETEACCESSORYTYPE: "IfcDiscreteAccessoryType",
  IFCDISCRETEACCESSORY: "IfcDiscreteAccessory",
  IFCDIAMETERDIMENSION: "IfcDiameterDimension",
  IFCDAMPERTYPE: "IfcDamperType",
  IFCCURTAINWALL: "IfcCurtainWall",
  IFCCOVERING: "IfcCovering",
  IFCCOOLINGTOWERTYPE: "IfcCoolingTowerType",
  IFCCOOLEDBEAMTYPE: "IfcCooledBeamType",
  IFCCONSTRUCTIONPRODUCTRESOURCE: "IfcConstructionProductResource",
  IFCCONSTRUCTIONMATERIALRESOURCE: "IfcConstructionMaterialResource",
  IFCCONSTRUCTIONEQUIPMENTRESOURCE: "IfcConstructionEquipmentResource",
  IFCCONDITIONCRITERION: "IfcConditionCriterion",
  IFCCONDITION: "IfcCondition",
  IFCCONDENSERTYPE: "IfcCondenserType",
  IFCCOMPRESSORTYPE: "IfcCompressorType",
  IFCCOLUMN: "IfcColumn",
  IFCCOILTYPE: "IfcCoilType",
  IFCCIRCLE: "IfcCircle",
  IFCCHILLERTYPE: "IfcChillerType",
  IFCCABLESEGMENTTYPE: "IfcCableSegmentType",
  IFCCABLECARRIERSEGMENTTYPE: "IfcCableCarrierSegmentType",
  IFCCABLECARRIERFITTINGTYPE: "IfcCableCarrierFittingType",
  IFCBUILDINGELEMENTPROXYTYPE: "IfcBuildingElementProxyType",
  IFCBUILDINGELEMENTPROXY: "IfcBuildingElementProxy",
  IFCBUILDINGELEMENTPART: "IfcBuildingElementPart",
  IFCBUILDINGELEMENTCOMPONENT: "IfcBuildingElementComponent",
  IFCBUILDINGELEMENT: "IfcBuildingElement",
  IFCBOILERTYPE: "IfcBoilerType",
  IFCBEZIERCURVE: "IfcBezierCurve",
  IFCBEAMTYPE: "IfcBeamType",
  IFCBSPLINECURVE: "IfcBSplineCurve",
  IFCASSET: "IfcAsset",
  IFCANGULARDIMENSION: "IfcAngularDimension",
  IFCAIRTOAIRHEATRECOVERYTYPE: "IfcAirToAirHeatRecoveryType",
  IFCAIRTERMINALTYPE: "IfcAirTerminalType",
  IFCAIRTERMINALBOXTYPE: "IfcAirTerminalBoxType",
  IFCACTIONREQUEST: "IfcActionRequest",
  IFC2DCOMPOSITECURVE: "Ifc2DCompositeCurve",
  IFCZONE: "IfcZone",
  IFCWORKSCHEDULE: "IfcWorkSchedule",
  IFCWORKPLAN: "IfcWorkPlan",
  IFCWORKCONTROL: "IfcWorkControl",
  IFCWASTETERMINALTYPE: "IfcWasteTerminalType",
  IFCWALLTYPE: "IfcWallType",
  IFCVIRTUALELEMENT: "IfcVirtualElement",
  IFCVALVETYPE: "IfcValveType",
  IFCUNITARYEQUIPMENTTYPE: "IfcUnitaryEquipmentType",
  IFCTUBEBUNDLETYPE: "IfcTubeBundleType",
  IFCTRIMMEDCURVE: "IfcTrimmedCurve",
  IFCTRANSPORTELEMENT: "IfcTransportElement",
  IFCTRANSFORMERTYPE: "IfcTransformerType",
  IFCTIMESERIESSCHEDULE: "IfcTimeSeriesSchedule",
  IFCTANKTYPE: "IfcTankType",
  IFCSYSTEM: "IfcSystem",
  IFCSWITCHINGDEVICETYPE: "IfcSwitchingDeviceType",
  IFCSUBCONTRACTRESOURCE: "IfcSubContractResource",
  IFCSTRUCTURALSURFACECONNECTION: "IfcStructuralSurfaceConnection",
  IFCSTRUCTURALRESULTGROUP: "IfcStructuralResultGroup",
  IFCSTRUCTURALPOINTREACTION: "IfcStructuralPointReaction",
  IFCSTRUCTURALPOINTCONNECTION: "IfcStructuralPointConnection",
  IFCSTRUCTURALPOINTACTION: "IfcStructuralPointAction",
  IFCSTRUCTURALPLANARACTIONVARYING: "IfcStructuralPlanarActionVarying",
  IFCSTRUCTURALPLANARACTION: "IfcStructuralPlanarAction",
  IFCSTRUCTURALLOADGROUP: "IfcStructuralLoadGroup",
  IFCSTRUCTURALLINEARACTIONVARYING: "IfcStructuralLinearActionVarying",
  IFCSTRUCTURALLINEARACTION: "IfcStructuralLinearAction",
  IFCSTRUCTURALCURVEMEMBERVARYING: "IfcStructuralCurveMemberVarying",
  IFCSTRUCTURALCURVEMEMBER: "IfcStructuralCurveMember",
  IFCSTRUCTURALCURVECONNECTION: "IfcStructuralCurveConnection",
  IFCSTRUCTURALCONNECTION: "IfcStructuralConnection",
  IFCSTRUCTURALACTION: "IfcStructuralAction",
  IFCSTAIRFLIGHTTYPE: "IfcStairFlightType",
  IFCSTACKTERMINALTYPE: "IfcStackTerminalType",
  IFCSPACETYPE: "IfcSpaceType",
  IFCSPACEPROGRAM: "IfcSpaceProgram",
  IFCSPACEHEATERTYPE: "IfcSpaceHeaterType",
  IFCSPACE: "IfcSpace",
  IFCSLABTYPE: "IfcSlabType",
  IFCSITE: "IfcSite",
  IFCSERVICELIFE: "IfcServiceLife",
  IFCSCHEDULETIMECONTROL: "IfcScheduleTimeControl",
  IFCSANITARYTERMINALTYPE: "IfcSanitaryTerminalType",
  IFCRELASSIGNSTASKS: "IfcRelAssignsTasks",
  IFCRELAGGREGATES: "IfcRelAggregates",
  IFCRAMPFLIGHTTYPE: "IfcRampFlightType",
  IFCRAILINGTYPE: "IfcRailingType",
  IFCRADIUSDIMENSION: "IfcRadiusDimension",
  IFCPUMPTYPE: "IfcPumpType",
  IFCPROTECTIVEDEVICETYPE: "IfcProtectiveDeviceType",
  IFCPROJECTIONELEMENT: "IfcProjectionElement",
  IFCPROJECTORDERRECORD: "IfcProjectOrderRecord",
  IFCPROJECTORDER: "IfcProjectOrder",
  IFCPROCEDURE: "IfcProcedure",
  IFCPORT: "IfcPort",
  IFCPOLYLINE: "IfcPolyline",
  IFCPLATETYPE: "IfcPlateType",
  IFCPIPESEGMENTTYPE: "IfcPipeSegmentType",
  IFCPIPEFITTINGTYPE: "IfcPipeFittingType",
  IFCPERMIT: "IfcPermit",
  IFCPERFORMANCEHISTORY: "IfcPerformanceHistory",
  IFCOUTLETTYPE: "IfcOutletType",
  IFCORDERACTION: "IfcOrderAction",
  IFCOPENINGELEMENT: "IfcOpeningElement",
  IFCOCCUPANT: "IfcOccupant",
  IFCMOVE: "IfcMove",
  IFCMOTORCONNECTIONTYPE: "IfcMotorConnectionType",
  IFCMEMBERTYPE: "IfcMemberType",
  IFCMECHANICALFASTENERTYPE: "IfcMechanicalFastenerType",
  IFCMECHANICALFASTENER: "IfcMechanicalFastener",
  IFCLINEARDIMENSION: "IfcLinearDimension",
  IFCLIGHTFIXTURETYPE: "IfcLightFixtureType",
  IFCLAMPTYPE: "IfcLampType",
  IFCLABORRESOURCE: "IfcLaborResource",
  IFCJUNCTIONBOXTYPE: "IfcJunctionBoxType",
  IFCINVENTORY: "IfcInventory",
  IFCHUMIDIFIERTYPE: "IfcHumidifierType",
  IFCHEATEXCHANGERTYPE: "IfcHeatExchangerType",
  IFCGROUP: "IfcGroup",
  IFCGRID: "IfcGrid",
  IFCGASTERMINALTYPE: "IfcGasTerminalType",
  IFCFURNITURESTANDARD: "IfcFurnitureStandard",
  IFCFURNISHINGELEMENT: "IfcFurnishingElement",
  IFCFLOWTREATMENTDEVICETYPE: "IfcFlowTreatmentDeviceType",
  IFCFLOWTERMINALTYPE: "IfcFlowTerminalType",
  IFCFLOWSTORAGEDEVICETYPE: "IfcFlowStorageDeviceType",
  IFCFLOWSEGMENTTYPE: "IfcFlowSegmentType",
  IFCFLOWMOVINGDEVICETYPE: "IfcFlowMovingDeviceType",
  IFCFLOWMETERTYPE: "IfcFlowMeterType",
  IFCFLOWFITTINGTYPE: "IfcFlowFittingType",
  IFCFLOWCONTROLLERTYPE: "IfcFlowControllerType",
  IFCFEATUREELEMENTSUBTRACTION: "IfcFeatureElementSubtraction",
  IFCFEATUREELEMENTADDITION: "IfcFeatureElementAddition",
  IFCFEATUREELEMENT: "IfcFeatureElement",
  IFCFASTENERTYPE: "IfcFastenerType",
  IFCFASTENER: "IfcFastener",
  IFCFACETEDBREPWITHVOIDS: "IfcFacetedBrepWithVoids",
  IFCFACETEDBREP: "IfcFacetedBrep",
  IFCEVAPORATORTYPE: "IfcEvaporatorType",
  IFCEVAPORATIVECOOLERTYPE: "IfcEvaporativeCoolerType",
  IFCEQUIPMENTSTANDARD: "IfcEquipmentStandard",
  IFCEQUIPMENTELEMENT: "IfcEquipmentElement",
  IFCENERGYCONVERSIONDEVICETYPE: "IfcEnergyConversionDeviceType",
  IFCELLIPSE: "IfcEllipse",
  IFCELEMENTCOMPONENTTYPE: "IfcElementComponentType",
  IFCELEMENTCOMPONENT: "IfcElementComponent",
  IFCELEMENTASSEMBLY: "IfcElementAssembly",
  IFCELEMENT: "IfcElement",
  IFCELECTRICALBASEPROPERTIES: "IfcElectricalBaseProperties",
  IFCDISTRIBUTIONFLOWELEMENTTYPE: "IfcDistributionFlowElementType",
  IFCDISTRIBUTIONELEMENTTYPE: "IfcDistributionElementType",
  IFCDIMENSIONCURVEDIRECTEDCALLOUT: "IfcDimensionCurveDirectedCallout",
  IFCCURTAINWALLTYPE: "IfcCurtainWallType",
  IFCCREWRESOURCE: "IfcCrewResource",
  IFCCOVERINGTYPE: "IfcCoveringType",
  IFCCOSTSCHEDULE: "IfcCostSchedule",
  IFCCOSTITEM: "IfcCostItem",
  IFCCONTROL: "IfcControl",
  IFCCONSTRUCTIONRESOURCE: "IfcConstructionResource",
  IFCCONIC: "IfcConic",
  IFCCOMPOSITECURVE: "IfcCompositeCurve",
  IFCCOLUMNTYPE: "IfcColumnType",
  IFCCIRCLEHOLLOWPROFILEDEF: "IfcCircleHollowProfileDef",
  IFCBUILDINGSTOREY: "IfcBuildingStorey",
  IFCBUILDINGELEMENTTYPE: "IfcBuildingElementType",
  IFCBUILDING: "IfcBuilding",
  IFCBOUNDEDCURVE: "IfcBoundedCurve",
  IFCBOOLEANCLIPPINGRESULT: "IfcBooleanClippingResult",
  IFCBLOCK: "IfcBlock",
  IFCASYMMETRICISHAPEPROFILEDEF: "IfcAsymmetricIShapeProfileDef",
  IFCANNOTATION: "IfcAnnotation",
  IFCACTOR: "IfcActor",
  IFCTRANSPORTELEMENTTYPE: "IfcTransportElementType",
  IFCTASK: "IfcTask",
  IFCSYSTEMFURNITUREELEMENTTYPE: "IfcSystemFurnitureElementType",
  IFCSURFACEOFREVOLUTION: "IfcSurfaceOfRevolution",
  IFCSURFACEOFLINEAREXTRUSION: "IfcSurfaceOfLinearExtrusion",
  IFCSURFACECURVESWEPTAREASOLID: "IfcSurfaceCurveSweptAreaSolid",
  IFCSTRUCTUREDDIMENSIONCALLOUT: "IfcStructuredDimensionCallout",
  IFCSTRUCTURALSURFACEMEMBERVARYING: "IfcStructuralSurfaceMemberVarying",
  IFCSTRUCTURALSURFACEMEMBER: "IfcStructuralSurfaceMember",
  IFCSTRUCTURALREACTION: "IfcStructuralReaction",
  IFCSTRUCTURALMEMBER: "IfcStructuralMember",
  IFCSTRUCTURALITEM: "IfcStructuralItem",
  IFCSTRUCTURALACTIVITY: "IfcStructuralActivity",
  IFCSPHERE: "IfcSphere",
  IFCSPATIALSTRUCTUREELEMENTTYPE: "IfcSpatialStructureElementType",
  IFCSPATIALSTRUCTUREELEMENT: "IfcSpatialStructureElement",
  IFCRIGHTCIRCULARCYLINDER: "IfcRightCircularCylinder",
  IFCRIGHTCIRCULARCONE: "IfcRightCircularCone",
  IFCREVOLVEDAREASOLID: "IfcRevolvedAreaSolid",
  IFCRESOURCE: "IfcResource",
  IFCRELVOIDSELEMENT: "IfcRelVoidsElement",
  IFCRELSPACEBOUNDARY: "IfcRelSpaceBoundary",
  IFCRELSERVICESBUILDINGS: "IfcRelServicesBuildings",
  IFCRELSEQUENCE: "IfcRelSequence",
  IFCRELSCHEDULESCOSTITEMS: "IfcRelSchedulesCostItems",
  IFCRELREFERENCEDINSPATIALSTRUCTURE: "IfcRelReferencedInSpatialStructure",
  IFCRELPROJECTSELEMENT: "IfcRelProjectsElement",
  IFCRELOVERRIDESPROPERTIES: "IfcRelOverridesProperties",
  IFCRELOCCUPIESSPACES: "IfcRelOccupiesSpaces",
  IFCRELNESTS: "IfcRelNests",
  IFCRELINTERACTIONREQUIREMENTS: "IfcRelInteractionRequirements",
  IFCRELFLOWCONTROLELEMENTS: "IfcRelFlowControlElements",
  IFCRELFILLSELEMENT: "IfcRelFillsElement",
  IFCRELDEFINESBYTYPE: "IfcRelDefinesByType",
  IFCRELDEFINESBYPROPERTIES: "IfcRelDefinesByProperties",
  IFCRELDEFINES: "IfcRelDefines",
  IFCRELDECOMPOSES: "IfcRelDecomposes",
  IFCRELCOVERSSPACES: "IfcRelCoversSpaces",
  IFCRELCOVERSBLDGELEMENTS: "IfcRelCoversBldgElements",
  IFCRELCONTAINEDINSPATIALSTRUCTURE: "IfcRelContainedInSpatialStructure",
  IFCRELCONNECTSWITHREALIZINGELEMENTS: "IfcRelConnectsWithRealizingElements",
  IFCRELCONNECTSWITHECCENTRICITY: "IfcRelConnectsWithEccentricity",
  IFCRELCONNECTSSTRUCTURALMEMBER: "IfcRelConnectsStructuralMember",
  IFCRELCONNECTSSTRUCTURALELEMENT: "IfcRelConnectsStructuralElement",
  IFCRELCONNECTSSTRUCTURALACTIVITY: "IfcRelConnectsStructuralActivity",
  IFCRELCONNECTSPORTS: "IfcRelConnectsPorts",
  IFCRELCONNECTSPORTTOELEMENT: "IfcRelConnectsPortToElement",
  IFCRELCONNECTSPATHELEMENTS: "IfcRelConnectsPathElements",
  IFCRELCONNECTSELEMENTS: "IfcRelConnectsElements",
  IFCRELCONNECTS: "IfcRelConnects",
  IFCRELASSOCIATESPROFILEPROPERTIES: "IfcRelAssociatesProfileProperties",
  IFCRELASSOCIATESMATERIAL: "IfcRelAssociatesMaterial",
  IFCRELASSOCIATESLIBRARY: "IfcRelAssociatesLibrary",
  IFCRELASSOCIATESDOCUMENT: "IfcRelAssociatesDocument",
  IFCRELASSOCIATESCONSTRAINT: "IfcRelAssociatesConstraint",
  IFCRELASSOCIATESCLASSIFICATION: "IfcRelAssociatesClassification",
  IFCRELASSOCIATESAPPROVAL: "IfcRelAssociatesApproval",
  IFCRELASSOCIATESAPPLIEDVALUE: "IfcRelAssociatesAppliedValue",
  IFCRELASSOCIATES: "IfcRelAssociates",
  IFCRELASSIGNSTORESOURCE: "IfcRelAssignsToResource",
  IFCRELASSIGNSTOPROJECTORDER: "IfcRelAssignsToProjectOrder",
  IFCRELASSIGNSTOPRODUCT: "IfcRelAssignsToProduct",
  IFCRELASSIGNSTOPROCESS: "IfcRelAssignsToProcess",
  IFCRELASSIGNSTOGROUP: "IfcRelAssignsToGroup",
  IFCRELASSIGNSTOCONTROL: "IfcRelAssignsToControl",
  IFCRELASSIGNSTOACTOR: "IfcRelAssignsToActor",
  IFCRELASSIGNS: "IfcRelAssigns",
  IFCRECTANGULARTRIMMEDSURFACE: "IfcRectangularTrimmedSurface",
  IFCRECTANGULARPYRAMID: "IfcRectangularPyramid",
  IFCRECTANGLEHOLLOWPROFILEDEF: "IfcRectangleHollowProfileDef",
  IFCPROXY: "IfcProxy",
  IFCPROPERTYSET: "IfcPropertySet",
  IFCPROJECTIONCURVE: "IfcProjectionCurve",
  IFCPROJECT: "IfcProject",
  IFCPRODUCT: "IfcProduct",
  IFCPROCESS: "IfcProcess",
  IFCPLANE: "IfcPlane",
  IFCPLANARBOX: "IfcPlanarBox",
  IFCPERMEABLECOVERINGPROPERTIES: "IfcPermeableCoveringProperties",
  IFCOFFSETCURVE3D: "IfcOffsetCurve3D",
  IFCOFFSETCURVE2D: "IfcOffsetCurve2D",
  IFCOBJECT: "IfcObject",
  IFCMANIFOLDSOLIDBREP: "IfcManifoldSolidBrep",
  IFCLINE: "IfcLine",
  IFCLSHAPEPROFILEDEF: "IfcLShapeProfileDef",
  IFCISHAPEPROFILEDEF: "IfcIShapeProfileDef",
  IFCGEOMETRICCURVESET: "IfcGeometricCurveSet",
  IFCFURNITURETYPE: "IfcFurnitureType",
  IFCFURNISHINGELEMENTTYPE: "IfcFurnishingElementType",
  IFCFLUIDFLOWPROPERTIES: "IfcFluidFlowProperties",
  IFCFILLAREASTYLETILES: "IfcFillAreaStyleTiles",
  IFCFILLAREASTYLETILESYMBOLWITHSTYLE: "IfcFillAreaStyleTileSymbolWithStyle",
  IFCFILLAREASTYLEHATCHING: "IfcFillAreaStyleHatching",
  IFCFACEBASEDSURFACEMODEL: "IfcFaceBasedSurfaceModel",
  IFCEXTRUDEDAREASOLID: "IfcExtrudedAreaSolid",
  IFCENERGYPROPERTIES: "IfcEnergyProperties",
  IFCELLIPSEPROFILEDEF: "IfcEllipseProfileDef",
  IFCELEMENTARYSURFACE: "IfcElementarySurface",
  IFCELEMENTTYPE: "IfcElementType",
  IFCELEMENTQUANTITY: "IfcElementQuantity",
  IFCEDGELOOP: "IfcEdgeLoop",
  IFCDRAUGHTINGPREDEFINEDCURVEFONT: "IfcDraughtingPredefinedCurveFont",
  IFCDRAUGHTINGPREDEFINEDCOLOUR: "IfcDraughtingPredefinedColour",
  IFCDRAUGHTINGCALLOUT: "IfcDraughtingCallout",
  IFCDOORSTYLE: "IfcDoorStyle",
  IFCDOORPANELPROPERTIES: "IfcDoorPanelProperties",
  IFCDOORLININGPROPERTIES: "IfcDoorLiningProperties",
  IFCDIRECTION: "IfcDirection",
  IFCDIMENSIONCURVETERMINATOR: "IfcDimensionCurveTerminator",
  IFCDIMENSIONCURVE: "IfcDimensionCurve",
  IFCDEFINEDSYMBOL: "IfcDefinedSymbol",
  IFCCURVEBOUNDEDPLANE: "IfcCurveBoundedPlane",
  IFCCURVE: "IfcCurve",
  IFCCSGSOLID: "IfcCsgSolid",
  IFCCSGPRIMITIVE3D: "IfcCsgPrimitive3D",
  IFCCRANERAILFSHAPEPROFILEDEF: "IfcCraneRailFShapeProfileDef",
  IFCCRANERAILASHAPEPROFILEDEF: "IfcCraneRailAShapeProfileDef",
  IFCCOMPOSITECURVESEGMENT: "IfcCompositeCurveSegment",
  IFCCLOSEDSHELL: "IfcClosedShell",
  IFCCIRCLEPROFILEDEF: "IfcCircleProfileDef",
  IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM: "IfcCartesianTransformationOperator3DNonUniform",
  IFCCARTESIANTRANSFORMATIONOPERATOR3D: "IfcCartesianTransformationOperator3D",
  IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM: "IfcCartesianTransformationOperator2DNonUniform",
  IFCCARTESIANTRANSFORMATIONOPERATOR2D: "IfcCartesianTransformationOperator2D",
  IFCCARTESIANTRANSFORMATIONOPERATOR: "IfcCartesianTransformationOperator",
  IFCCARTESIANPOINT: "IfcCartesianPoint",
  IFCCSHAPEPROFILEDEF: "IfcCShapeProfileDef",
  IFCBOXEDHALFSPACE: "IfcBoxedHalfSpace",
  IFCBOUNDINGBOX: "IfcBoundingBox",
  IFCBOUNDEDSURFACE: "IfcBoundedSurface",
  IFCBOOLEANRESULT: "IfcBooleanResult",
  IFCAXIS2PLACEMENT3D: "IfcAxis2Placement3D",
  IFCAXIS2PLACEMENT2D: "IfcAxis2Placement2D",
  IFCAXIS1PLACEMENT: "IfcAxis1Placement",
  IFCANNOTATIONSURFACE: "IfcAnnotationSurface",
  IFCANNOTATIONFILLAREAOCCURRENCE: "IfcAnnotationFillAreaOccurrence",
  IFCANNOTATIONFILLAREA: "IfcAnnotationFillArea",
  IFCANNOTATIONCURVEOCCURRENCE: "IfcAnnotationCurveOccurrence",
  IFCZSHAPEPROFILEDEF: "IfcZShapeProfileDef",
  IFCWINDOWSTYLE: "IfcWindowStyle",
  IFCWINDOWPANELPROPERTIES: "IfcWindowPanelProperties",
  IFCWINDOWLININGPROPERTIES: "IfcWindowLiningProperties",
  IFCVERTEXLOOP: "IfcVertexLoop",
  IFCVECTOR: "IfcVector",
  IFCUSHAPEPROFILEDEF: "IfcUShapeProfileDef",
  IFCTYPEPRODUCT: "IfcTypeProduct",
  IFCTYPEOBJECT: "IfcTypeObject",
  IFCTWODIRECTIONREPEATFACTOR: "IfcTwoDirectionRepeatFactor",
  IFCTRAPEZIUMPROFILEDEF: "IfcTrapeziumProfileDef",
  IFCTEXTLITERALWITHEXTENT: "IfcTextLiteralWithExtent",
  IFCTEXTLITERAL: "IfcTextLiteral",
  IFCTERMINATORSYMBOL: "IfcTerminatorSymbol",
  IFCTSHAPEPROFILEDEF: "IfcTShapeProfileDef",
  IFCSWEPTSURFACE: "IfcSweptSurface",
  IFCSWEPTDISKSOLID: "IfcSweptDiskSolid",
  IFCSWEPTAREASOLID: "IfcSweptAreaSolid",
  IFCSURFACESTYLERENDERING: "IfcSurfaceStyleRendering",
  IFCSURFACE: "IfcSurface",
  IFCSUBEDGE: "IfcSubedge",
  IFCSTRUCTURALSTEELPROFILEPROPERTIES: "IfcStructuralSteelProfileProperties",
  IFCSTRUCTURALPROFILEPROPERTIES: "IfcStructuralProfileProperties",
  IFCSTRUCTURALLOADSINGLEFORCEWARPING: "IfcStructuralLoadSingleForceWarping",
  IFCSTRUCTURALLOADSINGLEFORCE: "IfcStructuralLoadSingleForce",
  IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION: "IfcStructuralLoadSingleDisplacementDistortion",
  IFCSTRUCTURALLOADSINGLEDISPLACEMENT: "IfcStructuralLoadSingleDisplacement",
  IFCSTRUCTURALLOADPLANARFORCE: "IfcStructuralLoadPlanarForce",
  IFCSTRUCTURALLOADLINEARFORCE: "IfcStructuralLoadLinearForce",
  IFCSPACETHERMALLOADPROPERTIES: "IfcSpaceThermalLoadProperties",
  IFCSOUNDVALUE: "IfcSoundValue",
  IFCSOUNDPROPERTIES: "IfcSoundProperties",
  IFCSOLIDMODEL: "IfcSolidModel",
  IFCSLIPPAGECONNECTIONCONDITION: "IfcSlippageConnectionCondition",
  IFCSHELLBASEDSURFACEMODEL: "IfcShellBasedSurfaceModel",
  IFCSERVICELIFEFACTOR: "IfcServiceLifeFactor",
  IFCSECTIONEDSPINE: "IfcSectionedSpine",
  IFCROUNDEDRECTANGLEPROFILEDEF: "IfcRoundedRectangleProfileDef",
  IFCRELATIONSHIP: "IfcRelationship",
  IFCREINFORCEMENTDEFINITIONPROPERTIES: "IfcReinforcementDefinitionProperties",
  IFCREGULARTIMESERIES: "IfcRegularTimeSeries",
  IFCRECTANGLEPROFILEDEF: "IfcRectangleProfileDef",
  IFCPROPERTYTABLEVALUE: "IfcPropertyTableValue",
  IFCPROPERTYSINGLEVALUE: "IfcPropertySingleValue",
  IFCPROPERTYSETDEFINITION: "IfcPropertySetDefinition",
  IFCPROPERTYREFERENCEVALUE: "IfcPropertyReferenceValue",
  IFCPROPERTYLISTVALUE: "IfcPropertyListValue",
  IFCPROPERTYENUMERATEDVALUE: "IfcPropertyEnumeratedValue",
  IFCPROPERTYDEFINITION: "IfcPropertyDefinition",
  IFCPROPERTYBOUNDEDVALUE: "IfcPropertyBoundedValue",
  IFCPRODUCTDEFINITIONSHAPE: "IfcProductDefinitionShape",
  IFCPREDEFINEDPOINTMARKERSYMBOL: "IfcPredefinedPointMarkerSymbol",
  IFCPREDEFINEDDIMENSIONSYMBOL: "IfcPredefinedDimensionSymbol",
  IFCPREDEFINEDCURVEFONT: "IfcPredefinedCurveFont",
  IFCPREDEFINEDCOLOUR: "IfcPredefinedColour",
  IFCPOLYGONALBOUNDEDHALFSPACE: "IfcPolygonalBoundedHalfSpace",
  IFCPOLYLOOP: "IfcPolyLoop",
  IFCPOINTONSURFACE: "IfcPointOnSurface",
  IFCPOINTONCURVE: "IfcPointOnCurve",
  IFCPOINT: "IfcPoint",
  IFCPLANAREXTENT: "IfcPlanarExtent",
  IFCPLACEMENT: "IfcPlacement",
  IFCPIXELTEXTURE: "IfcPixelTexture",
  IFCPHYSICALCOMPLEXQUANTITY: "IfcPhysicalComplexQuantity",
  IFCPATH: "IfcPath",
  IFCPARAMETERIZEDPROFILEDEF: "IfcParameterizedProfileDef",
  IFCORIENTEDEDGE: "IfcOrientedEdge",
  IFCOPENSHELL: "IfcOpenShell",
  IFCONEDIRECTIONREPEATFACTOR: "IfcOneDirectionRepeatFactor",
  IFCOBJECTDEFINITION: "IfcObjectDefinition",
  IFCMECHANICALCONCRETEMATERIALPROPERTIES: "IfcMechanicalConcreteMaterialProperties",
  IFCMATERIALDEFINITIONREPRESENTATION: "IfcMaterialDefinitionRepresentation",
  IFCMAPPEDITEM: "IfcMappedItem",
  IFCLOOP: "IfcLoop",
  IFCLOCALPLACEMENT: "IfcLocalPlacement",
  IFCLIGHTSOURCESPOT: "IfcLightSourceSpot",
  IFCLIGHTSOURCEPOSITIONAL: "IfcLightSourcePositional",
  IFCLIGHTSOURCEGONIOMETRIC: "IfcLightSourceGoniometric",
  IFCLIGHTSOURCEDIRECTIONAL: "IfcLightSourceDirectional",
  IFCLIGHTSOURCEAMBIENT: "IfcLightSourceAmbient",
  IFCLIGHTSOURCE: "IfcLightSource",
  IFCIRREGULARTIMESERIES: "IfcIrregularTimeSeries",
  IFCIMAGETEXTURE: "IfcImageTexture",
  IFCHYGROSCOPICMATERIALPROPERTIES: "IfcHygroscopicMaterialProperties",
  IFCHALFSPACESOLID: "IfcHalfSpaceSolid",
  IFCGRIDPLACEMENT: "IfcGridPlacement",
  IFCGEOMETRICSET: "IfcGeometricSet",
  IFCGEOMETRICREPRESENTATIONSUBCONTEXT: "IfcGeometricRepresentationSubContext",
  IFCGEOMETRICREPRESENTATIONITEM: "IfcGeometricRepresentationItem",
  IFCGEOMETRICREPRESENTATIONCONTEXT: "IfcGeometricRepresentationContext",
  IFCGENERALPROFILEPROPERTIES: "IfcGeneralProfileProperties",
  IFCGENERALMATERIALPROPERTIES: "IfcGeneralMaterialProperties",
  IFCFUELPROPERTIES: "IfcFuelProperties",
  IFCFILLAREASTYLE: "IfcFillAreaStyle",
  IFCFAILURECONNECTIONCONDITION: "IfcFailureConnectionCondition",
  IFCFACESURFACE: "IfcFaceSurface",
  IFCFACEOUTERBOUND: "IfcFaceOuterBound",
  IFCFACEBOUND: "IfcFaceBound",
  IFCFACE: "IfcFace",
  IFCEXTENDEDMATERIALPROPERTIES: "IfcExtendedMaterialProperties",
  IFCEDGECURVE: "IfcEdgeCurve",
  IFCEDGE: "IfcEdge",
  IFCDRAUGHTINGPREDEFINEDTEXTFONT: "IfcDraughtingPredefinedTextFont",
  IFCDOCUMENTREFERENCE: "IfcDocumentReference",
  IFCDIMENSIONPAIR: "IfcDimensionPair",
  IFCDIMENSIONCALLOUTRELATIONSHIP: "IfcDimensionCalloutRelationship",
  IFCDERIVEDPROFILEDEF: "IfcDerivedProfileDef",
  IFCCURVESTYLE: "IfcCurveStyle",
  IFCCONVERSIONBASEDUNIT: "IfcConversionBasedUnit",
  IFCCONTEXTDEPENDENTUNIT: "IfcContextDependentUnit",
  IFCCONNECTIONPOINTECCENTRICITY: "IfcConnectionPointEccentricity",
  IFCCONNECTIONCURVEGEOMETRY: "IfcConnectionCurveGeometry",
  IFCCONNECTEDFACESET: "IfcConnectedFaceSet",
  IFCCOMPOSITEPROFILEDEF: "IfcCompositeProfileDef",
  IFCCOMPLEXPROPERTY: "IfcComplexProperty",
  IFCCOLOURRGB: "IfcColourRgb",
  IFCCLASSIFICATIONREFERENCE: "IfcClassificationReference",
  IFCCENTERLINEPROFILEDEF: "IfcCenterLineProfileDef",
  IFCBLOBTEXTURE: "IfcBlobTexture",
  IFCARBITRARYPROFILEDEFWITHVOIDS: "IfcArbitraryProfileDefWithVoids",
  IFCARBITRARYOPENPROFILEDEF: "IfcArbitraryOpenProfileDef",
  IFCARBITRARYCLOSEDPROFILEDEF: "IfcArbitraryClosedProfileDef",
  IFCANNOTATIONTEXTOCCURRENCE: "IfcAnnotationTextOccurrence",
  IFCANNOTATIONSYMBOLOCCURRENCE: "IfcAnnotationSymbolOccurrence",
  IFCANNOTATIONSURFACEOCCURRENCE: "IfcAnnotationSurfaceOccurrence",
  IFCANNOTATIONOCCURRENCE: "IfcAnnotationOccurrence",
  IFCWATERPROPERTIES: "IfcWaterProperties",
  IFCVIRTUALGRIDINTERSECTION: "IfcVirtualGridIntersection",
  IFCVERTEXPOINT: "IfcVertexPoint",
  IFCVERTEXBASEDTEXTUREMAP: "IfcVertexBasedTextureMap",
  IFCVERTEX: "IfcVertex",
  IFCUNITASSIGNMENT: "IfcUnitAssignment",
  IFCTOPOLOGYREPRESENTATION: "IfcTopologyRepresentation",
  IFCTOPOLOGICALREPRESENTATIONITEM: "IfcTopologicalRepresentationItem",
  IFCTIMESERIESVALUE: "IfcTimeSeriesValue",
  IFCTIMESERIESREFERENCERELATIONSHIP: "IfcTimeSeriesReferenceRelationship",
  IFCTIMESERIES: "IfcTimeSeries",
  IFCTHERMALMATERIALPROPERTIES: "IfcThermalMaterialProperties",
  IFCTEXTUREVERTEX: "IfcTextureVertex",
  IFCTEXTUREMAP: "IfcTextureMap",
  IFCTEXTURECOORDINATEGENERATOR: "IfcTextureCoordinateGenerator",
  IFCTEXTURECOORDINATE: "IfcTextureCoordinate",
  IFCTEXTSTYLEWITHBOXCHARACTERISTICS: "IfcTextStyleWithBoxCharacteristics",
  IFCTEXTSTYLETEXTMODEL: "IfcTextStyleTextModel",
  IFCTEXTSTYLEFORDEFINEDFONT: "IfcTextStyleForDefinedFont",
  IFCTEXTSTYLEFONTMODEL: "IfcTextStyleFontModel",
  IFCTEXTSTYLE: "IfcTextStyle",
  IFCTELECOMADDRESS: "IfcTelecomAddress",
  IFCTABLEROW: "IfcTableRow",
  IFCTABLE: "IfcTable",
  IFCSYMBOLSTYLE: "IfcSymbolStyle",
  IFCSURFACETEXTURE: "IfcSurfaceTexture",
  IFCSURFACESTYLEWITHTEXTURES: "IfcSurfaceStyleWithTextures",
  IFCSURFACESTYLESHADING: "IfcSurfaceStyleShading",
  IFCSURFACESTYLEREFRACTION: "IfcSurfaceStyleRefraction",
  IFCSURFACESTYLELIGHTING: "IfcSurfaceStyleLighting",
  IFCSURFACESTYLE: "IfcSurfaceStyle",
  IFCSTYLEDREPRESENTATION: "IfcStyledRepresentation",
  IFCSTYLEDITEM: "IfcStyledItem",
  IFCSTYLEMODEL: "IfcStyleModel",
  IFCSTRUCTURALLOADTEMPERATURE: "IfcStructuralLoadTemperature",
  IFCSTRUCTURALLOADSTATIC: "IfcStructuralLoadStatic",
  IFCSTRUCTURALLOAD: "IfcStructuralLoad",
  IFCSTRUCTURALCONNECTIONCONDITION: "IfcStructuralConnectionCondition",
  IFCSIMPLEPROPERTY: "IfcSimpleProperty",
  IFCSHAPEREPRESENTATION: "IfcShapeRepresentation",
  IFCSHAPEMODEL: "IfcShapeModel",
  IFCSHAPEASPECT: "IfcShapeAspect",
  IFCSECTIONREINFORCEMENTPROPERTIES: "IfcSectionReinforcementProperties",
  IFCSECTIONPROPERTIES: "IfcSectionProperties",
  IFCSIUNIT: "IfcSIUnit",
  IFCROOT: "IfcRoot",
  IFCRIBPLATEPROFILEPROPERTIES: "IfcRibPlateProfileProperties",
  IFCREPRESENTATIONMAP: "IfcRepresentationMap",
  IFCREPRESENTATIONITEM: "IfcRepresentationItem",
  IFCREPRESENTATIONCONTEXT: "IfcRepresentationContext",
  IFCREPRESENTATION: "IfcRepresentation",
  IFCRELAXATION: "IfcRelaxation",
  IFCREINFORCEMENTBARPROPERTIES: "IfcReinforcementBarProperties",
  IFCREFERENCESVALUEDOCUMENT: "IfcReferencesValueDocument",
  IFCQUANTITYWEIGHT: "IfcQuantityWeight",
  IFCQUANTITYVOLUME: "IfcQuantityVolume",
  IFCQUANTITYTIME: "IfcQuantityTime",
  IFCQUANTITYLENGTH: "IfcQuantityLength",
  IFCQUANTITYCOUNT: "IfcQuantityCount",
  IFCQUANTITYAREA: "IfcQuantityArea",
  IFCPROPERTYENUMERATION: "IfcPropertyEnumeration",
  IFCPROPERTYDEPENDENCYRELATIONSHIP: "IfcPropertyDependencyRelationship",
  IFCPROPERTYCONSTRAINTRELATIONSHIP: "IfcPropertyConstraintRelationship",
  IFCPROPERTY: "IfcProperty",
  IFCPROFILEPROPERTIES: "IfcProfileProperties",
  IFCPROFILEDEF: "IfcProfileDef",
  IFCPRODUCTSOFCOMBUSTIONPROPERTIES: "IfcProductsOfCombustionProperties",
  IFCPRODUCTREPRESENTATION: "IfcProductRepresentation",
  IFCPRESENTATIONSTYLEASSIGNMENT: "IfcPresentationStyleAssignment",
  IFCPRESENTATIONSTYLE: "IfcPresentationStyle",
  IFCPRESENTATIONLAYERWITHSTYLE: "IfcPresentationLayerWithStyle",
  IFCPRESENTATIONLAYERASSIGNMENT: "IfcPresentationLayerAssignment",
  IFCPREDEFINEDTEXTFONT: "IfcPredefinedTextFont",
  IFCPREDEFINEDTERMINATORSYMBOL: "IfcPredefinedTerminatorSymbol",
  IFCPREDEFINEDSYMBOL: "IfcPredefinedSymbol",
  IFCPREDEFINEDITEM: "IfcPredefinedItem",
  IFCPOSTALADDRESS: "IfcPostalAddress",
  IFCPHYSICALSIMPLEQUANTITY: "IfcPhysicalSimpleQuantity",
  IFCPHYSICALQUANTITY: "IfcPhysicalQuantity",
  IFCPERSONANDORGANIZATION: "IfcPersonAndOrganization",
  IFCPERSON: "IfcPerson",
  IFCOWNERHISTORY: "IfcOwnerHistory",
  IFCORGANIZATIONRELATIONSHIP: "IfcOrganizationRelationship",
  IFCORGANIZATION: "IfcOrganization",
  IFCOPTICALMATERIALPROPERTIES: "IfcOpticalMaterialProperties",
  IFCOBJECTIVE: "IfcObjective",
  IFCOBJECTPLACEMENT: "IfcObjectPlacement",
  IFCNAMEDUNIT: "IfcNamedUnit",
  IFCMONETARYUNIT: "IfcMonetaryUnit",
  IFCMETRIC: "IfcMetric",
  IFCMECHANICALSTEELMATERIALPROPERTIES: "IfcMechanicalSteelMaterialProperties",
  IFCMECHANICALMATERIALPROPERTIES: "IfcMechanicalMaterialProperties",
  IFCMEASUREWITHUNIT: "IfcMeasureWithUnit",
  IFCMATERIALPROPERTIES: "IfcMaterialProperties",
  IFCMATERIALLIST: "IfcMaterialList",
  IFCMATERIALLAYERSETUSAGE: "IfcMaterialLayerSetUsage",
  IFCMATERIALLAYERSET: "IfcMaterialLayerSet",
  IFCMATERIALLAYER: "IfcMaterialLayer",
  IFCMATERIALCLASSIFICATIONRELATIONSHIP: "IfcMaterialClassificationRelationship",
  IFCMATERIAL: "IfcMaterial",
  IFCLOCALTIME: "IfcLocalTime",
  IFCLIGHTINTENSITYDISTRIBUTION: "IfcLightIntensityDistribution",
  IFCLIGHTDISTRIBUTIONDATA: "IfcLightDistributionData",
  IFCLIBRARYREFERENCE: "IfcLibraryReference",
  IFCLIBRARYINFORMATION: "IfcLibraryInformation",
  IFCIRREGULARTIMESERIESVALUE: "IfcIrregularTimeSeriesValue",
  IFCGRIDAXIS: "IfcGridAxis",
  IFCEXTERNALLYDEFINEDTEXTFONT: "IfcExternallyDefinedTextFont",
  IFCEXTERNALLYDEFINEDSYMBOL: "IfcExternallyDefinedSymbol",
  IFCEXTERNALLYDEFINEDSURFACESTYLE: "IfcExternallyDefinedSurfaceStyle",
  IFCEXTERNALLYDEFINEDHATCHSTYLE: "IfcExternallyDefinedHatchStyle",
  IFCEXTERNALREFERENCE: "IfcExternalReference",
  IFCENVIRONMENTALIMPACTVALUE: "IfcEnvironmentalImpactValue",
  IFCDRAUGHTINGCALLOUTRELATIONSHIP: "IfcDraughtingCalloutRelationship",
  IFCDOCUMENTINFORMATIONRELATIONSHIP: "IfcDocumentInformationRelationship",
  IFCDOCUMENTINFORMATION: "IfcDocumentInformation",
  IFCDOCUMENTELECTRONICFORMAT: "IfcDocumentElectronicFormat",
  IFCDIMENSIONALEXPONENTS: "IfcDimensionalExponents",
  IFCDERIVEDUNITELEMENT: "IfcDerivedUnitElement",
  IFCDERIVEDUNIT: "IfcDerivedUnit",
  IFCDATEANDTIME: "IfcDateAndTime",
  IFCCURVESTYLEFONTPATTERN: "IfcCurveStyleFontPattern",
  IFCCURVESTYLEFONTANDSCALING: "IfcCurveStyleFontAndScaling",
  IFCCURVESTYLEFONT: "IfcCurveStyleFont",
  IFCCURRENCYRELATIONSHIP: "IfcCurrencyRelationship",
  IFCCOSTVALUE: "IfcCostValue",
  IFCCOORDINATEDUNIVERSALTIMEOFFSET: "IfcCoordinatedUniversalTimeOffset",
  IFCCONSTRAINTRELATIONSHIP: "IfcConstraintRelationship",
  IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP: "IfcConstraintClassificationRelationship",
  IFCCONSTRAINTAGGREGATIONRELATIONSHIP: "IfcConstraintAggregationRelationship",
  IFCCONSTRAINT: "IfcConstraint",
  IFCCONNECTIONSURFACEGEOMETRY: "IfcConnectionSurfaceGeometry",
  IFCCONNECTIONPORTGEOMETRY: "IfcConnectionPortGeometry",
  IFCCONNECTIONPOINTGEOMETRY: "IfcConnectionPointGeometry",
  IFCCONNECTIONGEOMETRY: "IfcConnectionGeometry",
  IFCCOLOURSPECIFICATION: "IfcColourSpecification",
  IFCCLASSIFICATIONNOTATIONFACET: "IfcClassificationNotationFacet",
  IFCCLASSIFICATIONNOTATION: "IfcClassificationNotation",
  IFCCLASSIFICATIONITEMRELATIONSHIP: "IfcClassificationItemRelationship",
  IFCCLASSIFICATIONITEM: "IfcClassificationItem",
  IFCCLASSIFICATION: "IfcClassification",
  IFCCALENDARDATE: "IfcCalendarDate",
  IFCBOUNDARYNODECONDITIONWARPING: "IfcBoundaryNodeConditionWarping",
  IFCBOUNDARYNODECONDITION: "IfcBoundaryNodeCondition",
  IFCBOUNDARYFACECONDITION: "IfcBoundaryFaceCondition",
  IFCBOUNDARYEDGECONDITION: "IfcBoundaryEdgeCondition",
  IFCBOUNDARYCONDITION: "IfcBoundaryCondition",
  IFCAPPROVALRELATIONSHIP: "IfcApprovalRelationship",
  IFCAPPROVALPROPERTYRELATIONSHIP: "IfcApprovalPropertyRelationship",
  IFCAPPROVALACTORRELATIONSHIP: "IfcApprovalActorRelationship",
  IFCAPPROVAL: "IfcApproval",
  IFCAPPLIEDVALUERELATIONSHIP: "IfcAppliedValueRelationship",
  IFCAPPLIEDVALUE: "IfcAppliedValue",
  IFCAPPLICATION: "IfcApplication",
  IFCADDRESS: "IfcAddress",
  IFCACTORROLE: "IfcActorRole"
};
class tf {
  constructor() {
    y(this, "factor", 1), y(this, "complement", 1);
  }
  apply(t) {
    const s = this.getScaleMatrix().multiply(t);
    t.copy(s);
  }
  setUp(t) {
    var e, s, i;
    this.factor = 1;
    const n = this.getLengthUnits(t);
    if (!n)
      return;
    const r = n == null, o = n.Name === void 0 || n.Name === null;
    r || o || (n.Name.value === "FOOT" && (this.factor = 0.3048), ((e = n.Prefix) == null ? void 0 : e.value) === "MILLI" ? this.complement = 1e-3 : ((s = n.Prefix) == null ? void 0 : s.value) === "CENTI" ? this.complement = 0.01 : ((i = n.Prefix) == null ? void 0 : i.value) === "DECI" && (this.complement = 0.01));
  }
  getLengthUnits(t) {
    try {
      const s = t.GetLineIDsWithType(
        0,
        W.IFCUNITASSIGNMENT
      ).get(0), i = t.GetLine(0, s);
      for (const n of i.Units) {
        if (!n || n.value === null || n.value === void 0)
          continue;
        const r = t.GetLine(0, n.value);
        if (r.UnitType && r.UnitType.value === "LENGTHUNIT")
          return r;
      }
      return null;
    } catch {
      return console.log("Could not get units"), null;
    }
  }
  getScaleMatrix() {
    const t = this.factor;
    return new A.Matrix4().fromArray([
      t,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ]);
  }
}
class El {
  constructor() {
    y(this, "itemsByFloor", {}), y(this, "_units", new tf());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(t) {
    this._units.setUp(t), this.cleanUp();
    try {
      const e = t.GetLineIDsWithType(
        0,
        W.IFCRELCONTAINEDINSPATIALSTRUCTURE
      ), s = /* @__PURE__ */ new Set(), i = t.GetLineIDsWithType(0, W.IFCSPACE);
      for (let c = 0; c < i.size(); c++)
        s.add(i.get(c));
      const n = t.GetLineIDsWithType(0, W.IFCRELAGGREGATES), r = n.size();
      for (let c = 0; c < r; c++) {
        const h = n.get(c), f = t.GetLine(0, h);
        if (!f || !f.RelatingObject || !f.RelatedObjects)
          continue;
        const u = f.RelatingObject.value, d = f.RelatedObjects;
        for (const p of d) {
          const m = p.value;
          s.has(m) && (this.itemsByFloor[m] = u);
        }
      }
      const o = {}, a = e.size();
      for (let c = 0; c < a; c++) {
        const h = e.get(c), f = t.GetLine(0, h);
        if (!f || !f.RelatingStructure || !f.RelatedElements)
          continue;
        const u = f.RelatingStructure.value, d = f.RelatedElements;
        if (s.has(u))
          for (const p of d) {
            o[u] || (o[u] = []);
            const m = p.value;
            o[u].push(m);
          }
        else
          for (const p of d) {
            const m = p.value;
            this.itemsByFloor[m] = u;
          }
      }
      for (const c in o) {
        const h = this.itemsByFloor[c];
        if (h !== void 0) {
          const f = o[c];
          for (const u of f)
            this.itemsByFloor[u] = h;
        }
      }
      for (let c = 0; c < r; c++) {
        const h = n.get(c), f = t.GetLine(0, h);
        if (!f || !f.RelatingObject || !f.RelatedObjects)
          continue;
        const u = f.RelatingObject.value, d = f.RelatedObjects;
        for (const p of d) {
          const m = p.value, E = this.itemsByFloor[u];
          E !== void 0 && (this.itemsByFloor[m] = E);
        }
      }
    } catch {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
}
class oo {
  constructor() {
    y(this, "includeProperties", !0), y(this, "optionalCategories", [W.IFCSPACE]), y(this, "wasm", {
      path: "",
      absolute: !1,
      logLevel: W.LogLevel.LOG_LEVEL_OFF
    }), y(this, "excludedCategories", /* @__PURE__ */ new Set()), y(this, "includedCategories", /* @__PURE__ */ new Set()), y(this, "saveLocations", !1), y(this, "webIfc", {
      COORDINATE_TO_ORIGIN: !0
      // OPTIMIZE_PROFILES: true,
    }), y(this, "autoSetWasm", !0), y(this, "customLocateFileHandler", null);
  }
}
class gl {
  constructor() {
    y(this, "defLineMat", new A.LineBasicMaterial({ color: 16777215 }));
  }
  read(t) {
    const e = t.GetAllAlignments(0), s = t.GetAllCrossSections2D(0), i = t.GetAllCrossSections3D(0), n = {
      IfcAlignment: e,
      IfcCrossSection2D: s,
      IfcCrossSection3D: i
    };
    return this.get(n);
  }
  get(t) {
    if (t.IfcAlignment) {
      const e = /* @__PURE__ */ new Map();
      for (const s of t.IfcAlignment) {
        const i = new Pe.AlignmentObject();
        i.absolute = this.getCurves(s.curve3D, i), i.horizontal = this.getCurves(s.horizontal, i), i.vertical = this.getCurves(s.vertical, i), e.set(e.size, i);
      }
      return { alignments: e, coordinationMatrix: new A.Matrix4() };
    }
  }
  getCurves(t, e) {
    const s = [];
    let i = 0;
    for (const n of t) {
      const r = {};
      if (n.data)
        for (const u of n.data) {
          const [d, p] = u.split(": "), m = parseFloat(p);
          r[d] = m || p;
        }
      const { points: o } = n, a = new Float32Array(o.length * 3);
      for (let u = 0; u < o.length; u++) {
        const { x: d, y: p, z: m } = o[u];
        a[u * 3] = d, a[u * 3 + 1] = p, a[u * 3 + 2] = m || 0;
      }
      const c = new A.BufferAttribute(a, 3), h = new A.EdgesGeometry();
      h.setAttribute("position", c);
      const f = new Pe.CurveMesh(
        i,
        r,
        e,
        h,
        this.defLineMat
      );
      s.push(f.curve), i++;
    }
    return s;
  }
}
class Cl {
  getNameInfo(t) {
    var e;
    const s = {}, { arguments: i } = t.GetHeaderLine(0, W.FILE_NAME) || {};
    if (!i)
      return s;
    const [
      n,
      r,
      o,
      a,
      c,
      h,
      f
    ] = i;
    if (n != null && n.value && (s.name = n.value), r != null && r.value && (s.creationDate = new Date(r.value)), o) {
      s.author = {};
      const [u, d] = o;
      u != null && u.value && (s.author.name = u.value), d != null && d.value && (s.author.email = d.value);
    }
    return a && ((e = a[0]) != null && e.value) && (s.organization = a[0].value), c != null && c.value && (s.preprocessorVersion = c == null ? void 0 : c.value), h != null && h.value && (s.originatingSystem = h == null ? void 0 : h.value), f != null && f.value && (s.authorization = f == null ? void 0 : f.value), s;
  }
  getDescriptionInfo(t) {
    var e;
    const s = {}, { arguments: i } = t.GetHeaderLine(0, W.FILE_DESCRIPTION) || {};
    if (!i)
      return s;
    const [n, r] = i;
    if (Array.isArray(n) && ((e = n[0]) != null && e.value)) {
      const o = n[0].value.match(/\[([^\]]+)\]/);
      o && o[1] && (s.viewDefinition = o[1]);
    }
    return r != null && r.value && (s.implementationLevel = r.value), s;
  }
}
class Tl {
  static get(t, e) {
    const s = [
      W.IFCPROJECT,
      W.IFCSITE,
      W.IFCBUILDING,
      W.IFCBUILDINGSTOREY,
      W.IFCSPACE,
      W.IFCROAD,
      W.IFCFACILITY,
      W.IFCFACILITYPART,
      W.IFCBRIDGE
    ], i = t.data;
    for (const n of s) {
      const r = e.GetLineIDsWithType(0, n), o = r.size();
      for (let a = 0; a < o; a++) {
        const c = r.get(a);
        i.has(c) || i.set(c, [[], [0, n]]);
      }
    }
  }
}
const yl = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014,
  2916149573
]), Rl = class Sl extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), t.add(Sl.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(t, e, s = !1, i = !0) {
    const n = {}, r = new Set(t.GetIfcEntityList(e)), o = /* @__PURE__ */ new Set([
      W.IFCPROJECT,
      W.IFCSITE,
      W.IFCBUILDING,
      W.IFCBUILDINGSTOREY,
      W.IFCSPACE
    ]);
    for (const a of o)
      r.add(a);
    for (const a of r) {
      if (yl.has(a))
        continue;
      const c = o.has(a) && i, h = t.GetLineIDsWithType(e, a);
      for (const f of h)
        try {
          const u = t.GetLine(0, f, c, s);
          n[u.expressID] = u;
        } catch {
          console.log(
            `Could not get property ${f}, with recursive ${c} and indirect ${s}.`
          );
        }
    }
    return n;
  }
};
y(Rl, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
let sf = Rl;
const Al = class zr extends ue {
  constructor(t) {
    super(t), y(this, "onDisposed", new Y()), y(this, "onIfcStartedLoading", new Y()), y(this, "onSetup", new Y()), y(this, "settings", new oo()), y(this, "webIfc", new W.IfcAPI()), y(this, "enabled", !0), y(this, "_material", new A.MeshLambertMaterial()), y(this, "_spatialTree", new El()), y(this, "_metaData", new Cl()), y(this, "_fragmentInstances", /* @__PURE__ */ new Map()), y(this, "_civil", new gl()), y(this, "_visitedFragments", /* @__PURE__ */ new Map()), y(this, "_materialT", new A.MeshLambertMaterial({
      transparent: !0,
      opacity: 0.5
    })), this.components.add(zr.uuid, this), this.settings.excludedCategories.add(W.IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(zr.uuid), this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   *
   * @returns A Promise that resolves to the FragmentsGroup containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const group = await ifcLoader.load(ifcData);
   * ```
   */
  async load(t, e = !0, s = "") {
    const i = performance.now();
    this.onIfcStartedLoading.trigger(), await this.readIfcFile(t);
    const n = await this.getAllGeometries();
    n.name = s;
    const o = await this.components.get(sf).export(this.webIfc, 0);
    n.setLocalProperties(o);
    const a = this.components.get(fe);
    a.groups.set(n.uuid, n);
    for (const c of n.items)
      a.list.set(c.id, c), c.mesh.uuid = c.id, c.group = n;
    a.onFragmentsLoaded.trigger(n), e && a.coordinate([n]);
    for (const [c] of n.data) {
      const h = o[c];
      if (!h || !h.GlobalId)
        continue;
      const f = h.GlobalId.value || h.GlobalId;
      n.globalToExpressIDs.set(f, c);
    }
    return Tl.get(n, this.webIfc), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - i} ms!`), n;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(t) {
    const { path: e, absolute: s, logLevel: i } = this.settings.wasm;
    return this.webIfc.SetWasmPath(e, s), await this.webIfc.Init(this.settings.customLocateFileHandler || void 0), i && this.webIfc.SetLogLevel(i), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch {
      console.log("Web-ifc wasn't disposed.");
    }
    this.webIfc = null, this.webIfc = new W.IfcAPI(), this._visitedFragments.clear(), this._fragmentInstances.clear();
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const t = this.webIfc.GetIfcEntityList(0), e = new Pe.FragmentsGroup();
    e.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const s = [];
    for (const n of t) {
      if (!this.webIfc.IsIfcElement(n) && n !== W.IFCSPACE)
        continue;
      const r = this.settings.includedCategories;
      if (r.size > 0 && !r.has(n))
        continue;
      if (this.settings.excludedCategories.has(n))
        continue;
      const o = this.webIfc.GetLineIDsWithType(0, n), a = o.size();
      for (let c = 0; c < a; c++) {
        const h = o.get(c);
        s.push(h);
        const f = this._spatialTree.itemsByFloor[h] || 0;
        e.data.set(h, [[], [f, n]]);
      }
    }
    this._spatialTree.cleanUp(), this.webIfc.StreamMeshes(0, s, (n) => {
      this.getMesh(n, e);
    });
    for (const n of this._visitedFragments) {
      const { index: r, fragment: o } = n[1];
      e.keyFragments.set(r, o.id);
    }
    for (const n of e.items) {
      const r = this._fragmentInstances.get(n.id);
      if (!r)
        throw new Error("Fragment not found!");
      const o = [];
      for (const [a, c] of r)
        o.push(c);
      n.add(o);
    }
    const i = this.webIfc.GetCoordinationMatrix(0);
    return e.coordinationMatrix.fromArray(i), e.civilData = this._civil.read(this.webIfc), e;
  }
  getMesh(t, e) {
    const s = t.geometries.size(), i = t.expressID;
    for (let n = 0; n < s; n++) {
      const r = t.geometries.get(n), { x: o, y: a, z: c, w: h } = r.color, f = h !== 1, { geometryExpressID: u } = r, d = `${u}-${f}`;
      if (!this._visitedFragments.has(d)) {
        const C = this.getGeometry(this.webIfc, u), F = f ? this._materialT : this._material, O = new Pe.Fragment(C, F, 1);
        e.add(O.mesh), e.items.push(O);
        const P = this._visitedFragments.size;
        this._visitedFragments.set(d, { index: P, fragment: O });
      }
      const p = new A.Color().setRGB(o, a, c, "srgb"), m = new A.Matrix4();
      m.fromArray(r.flatTransformation);
      const E = this._visitedFragments.get(d);
      if (E === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const I = e.data.get(i);
      if (!I)
        throw new Error("Data not found!");
      I[0].push(E.index);
      const { fragment: g } = E;
      this._fragmentInstances.has(g.id) || this._fragmentInstances.set(g.id, /* @__PURE__ */ new Map());
      const T = this._fragmentInstances.get(g.id);
      if (!T)
        throw new Error("Instances not found!");
      if (T.has(i)) {
        const C = T.get(i);
        if (!C)
          throw new Error("Instance not found!");
        C.transforms.push(m), C.colors && C.colors.push(p);
      } else
        T.set(i, { id: i, transforms: [m], colors: [p] });
    }
  }
  getGeometry(t, e) {
    const s = t.GetGeometry(0, e), i = t.GetIndexArray(
      s.GetIndexData(),
      s.GetIndexDataSize()
    ), n = t.GetVertexArray(
      s.GetVertexData(),
      s.GetVertexDataSize()
    ), r = new Float32Array(n.length / 2), o = new Float32Array(n.length / 2);
    for (let f = 0; f < n.length; f += 6)
      r[f / 2] = n[f], r[f / 2 + 1] = n[f + 1], r[f / 2 + 2] = n[f + 2], o[f / 2] = n[f + 3], o[f / 2 + 1] = n[f + 4], o[f / 2 + 2] = n[f + 5];
    const a = new A.BufferGeometry(), c = new A.BufferAttribute(r, 3), h = new A.BufferAttribute(o, 3);
    return a.setAttribute("position", c), a.setAttribute("normal", h), a.setIndex(Array.from(i)), s.delete(), a;
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/@thatopen/components@${nl.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const e = await t.json();
    if (!("web-ifc" in e.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const s = e.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${s}/`, this.settings.wasm.absolute = !0;
    }
  }
};
y(Al, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
let nf = Al;
const rf = {
  // IfcRelAssigns
  IfcRelAssignsToControl: { related: 5, relating: 7 },
  IfcRelAssignsToGroup: { related: 5, relating: 7 },
  IfcRelAssignsToProduct: { related: 5, relating: 7 },
  // IfcRelAssociates
  IfcRelAssociatesClassification: { related: 5, relating: 6 },
  IfcRelAssociatesMaterial: { related: 5, relating: 6 },
  IfcRelAssociatesDocument: { related: 5, relating: 6 },
  // IfcRelConnects
  IfcRelContainedInSpatialStructure: { related: 5, relating: 6 },
  IfcRelFlowControlElements: { related: 5, relating: 6 },
  IfcRelConnectsElements: { related: 7, relating: 6 },
  // IfcRelDeclares
  IfcRelDeclares: { related: 6, relating: 5 },
  // IfcRelDecomposes
  IfcRelAggregates: { related: 6, relating: 5 },
  IfcRelNests: { related: 6, relating: 5 },
  // IfcRelDefines
  IfcRelDefinesByProperties: { related: 5, relating: 6 },
  IfcRelDefinesByType: { related: 5, relating: 6 },
  IfcRelDefinesByTemplate: { related: 5, relating: 6 }
}, of = {
  // IfcRelAssigns
  [W.IFCRELASSIGNSTOCONTROL]: "IfcRelAssignsToControl",
  [W.IFCRELASSIGNSTOGROUP]: "IfcRelAssignsToGroup",
  [W.IFCRELASSIGNSTOPRODUCT]: "IfcRelAssignsToProduct",
  // IfcRelAssociates
  [W.IFCRELASSOCIATESCLASSIFICATION]: "IfcRelAssociatesClassification",
  [W.IFCRELASSOCIATESMATERIAL]: "IfcRelAssociatesMaterial",
  [W.IFCRELASSOCIATESDOCUMENT]: "IfcRelAssociatesDocument",
  // IfcRelConnects
  [W.IFCRELCONTAINEDINSPATIALSTRUCTURE]: "IfcRelContainedInSpatialStructure",
  [W.IFCRELCONNECTSELEMENTS]: "IfcRelConnectsElements",
  [W.IFCRELFLOWCONTROLELEMENTS]: "IfcRelFlowControlElements",
  // IfcRelDeclares
  [W.IFCRELDECLARES]: "IfcRelDeclares",
  // IfcRelDecomposes
  [W.IFCRELAGGREGATES]: "IfcRelAggregates",
  [W.IFCRELNESTS]: "IfcRelNests",
  // IfcRelDefines
  [W.IFCRELDEFINESBYPROPERTIES]: "IfcRelDefinesByProperties",
  [W.IFCRELDEFINESBYTYPE]: "IfcRelDefinesByType",
  [W.IFCRELDEFINESBYTEMPLATE]: "IfcRelDefinesByTemplate"
}, Fl = class os extends ue {
  constructor(t) {
    super(t), y(this, "onDisposed", new Y()), y(this, "onRequestFile", new Y()), y(this, "ifcToExport", null), y(this, "onElementToPset", new Y()), y(this, "onPropToPset", new Y()), y(this, "onPsetRemoved", new Y()), y(this, "onDataChanged", new Y()), y(this, "wasm", {
      path: "/",
      absolute: !1
    }), y(this, "enabled", !0), y(this, "attributeListeners", {}), y(this, "selectedModel"), y(this, "changeMap", {}), this.components.add(os.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.selectedModel = void 0, this.attributeListeners = {}, this.changeMap = {}, this.onElementToPset.reset(), this.onPropToPset.reset(), this.onPsetRemoved.reset(), this.onDataChanged.reset(), this.onDisposed.trigger(os.uuid), this.onDisposed.reset();
  }
  /**
   * Static method to retrieve the IFC schema from a given model.
   *
   * @param model - The FragmentsGroup model from which to retrieve the IFC schema.
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @returns The IFC schema associated with the given model.
   */
  static getIFCSchema(t) {
    const e = t.ifcMetadata.schema;
    if (!e)
      throw new Error("IFC Schema not found");
    return e.startsWith("IFC2X3") ? "IFC2X3" : e.startsWith("IFC4") && e.replace("IFC4", "") === "" ? "IFC4" : e.startsWith("IFC4X3") ? "IFC4X3" : e;
  }
  /**
   * Method to add or update entity attributes in the model.
   *
   * @param model - The FragmentsGroup model in which to set the properties.
   * @param dataToSave - An array of objects representing the properties to be saved.
   * Each object must have an `expressID` property, which is the express ID of the entity in the model.
   * The rest of the properties will be set as the properties of the entity.
   *
   * @returns A promise that resolves when all the properties have been set.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `dataToSave` array.
   */
  async setData(t, ...e) {
    for (const s of e) {
      const { expressID: i } = s;
      (!i || i === -1) && (s.expressID = this.getNewExpressID(t)), await t.setProperties(s.expressID, s), this.registerChange(t, s.expressID);
    }
  }
  /**
   * Creates a new Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the Pset.
   * @param name - The name of the Pset.
   * @param description - (Optional) The description of the Pset.
   *
   * @returns A promise that resolves with an object containing the newly created Pset and its relation.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  async newPset(t, e, s) {
    const i = os.getIFCSchema(t), { handle: n } = await this.getOwnerHistory(t), r = this.newGUID(t), o = new W[i].IfcLabel(e), a = s ? new W[i].IfcText(s) : null, c = new W[i].IfcPropertySet(
      r,
      n,
      o,
      a,
      []
    );
    return c.expressID = this.getNewExpressID(t), await this.setData(t, c), { pset: c };
  }
  /**
   * Removes a Property Set (Pset) from the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the Pset.
   * @param psetID - The express IDs of the Psets to be removed.
   *
   * @returns A promise that resolves when all the Psets have been removed.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `psetID` array.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async removePset(t, ...e) {
    for (const s of e) {
      const i = await t.getProperties(s);
      if ((i == null ? void 0 : i.type) !== W.IFCPROPERTYSET)
        continue;
      const n = await cs.getPsetRel(t, s);
      if (n && (await t.setProperties(n, null), this.registerChange(t, n)), i) {
        for (const r of i.HasProperties)
          await t.setProperties(r.value, null);
        await t.setProperties(s, null), this.onPsetRemoved.trigger({ model: t, psetID: s }), this.registerChange(t, s);
      }
    }
  }
  /**
   * Creates a new single-value property of type string in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a string property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a string.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleStringProperty(t, e, s, i) {
    return this.newSingleProperty(t, e, s, i);
  }
  /**
   * Creates a new single-value property of type numeric in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a numeric property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a number.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleNumericProperty(t, e, s, i) {
    return this.newSingleProperty(t, e, s, i);
  }
  /**
   * Creates a new single-value property of type boolean in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a boolean property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a boolean.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleBooleanProperty(t, e, s, i) {
    return this.newSingleProperty(t, e, s, i);
  }
  /**
   * Removes a property from a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the property.
   * @param psetID - The express ID of the Pset from which to remove the property.
   * @param propID - The express ID of the property to be removed.
   *
   * @returns A promise that resolves when the property has been removed.
   *
   * @throws Will throw an error if the Pset or the property to be removed are not found in the model.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   */
  async removePsetProp(t, e, s) {
    const i = await t.getProperties(e), n = await t.getProperties(s);
    !i || !n || i.type === W.IFCPROPERTYSET && n && (i.HasProperties = i.HasProperties.filter((r) => r.value !== s), await t.setProperties(s, null), this.registerChange(t, e, s));
  }
  /**
   * @deprecated Use indexer.addEntitiesRelation instead. This will be removed in future releases.
   */
  addElementToPset(t, e, ...s) {
    this.components.get(et).addEntitiesRelation(
      t,
      e,
      { type: W.IFCRELDEFINESBYPROPERTIES, inv: "DefinesOcurrence" },
      ...s
    );
  }
  /**
   * Adds elements to a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to add the elements.
   * @param psetID - The express ID of the Pset to which to add the elements.
   * @param elementID - The express IDs of the elements to be added.
   *
   * @returns A promise that resolves when all the elements have been added.
   *
   * @throws Will throw an error if the Pset or the elements to be added are not found in the model.
   * @throws Will throw an error if the Pset to be added to is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async addPropToPset(t, e, ...s) {
    const i = await t.getProperties(e);
    if (i) {
      for (const n of s) {
        if (i.HasProperties.includes(n))
          continue;
        const r = new W.Handle(n);
        i.HasProperties.push(r), this.onPropToPset.trigger({ model: t, psetID: e, propID: n });
      }
      this.registerChange(t, e);
    }
  }
  /**
   * Creates a new instance of a relationship between entities in the IFC model.
   *
   * @param model - The FragmentsGroup model in which to create the relationship.
   * @param type - The type of the relationship to create.
   * @param relatingID - The express ID of the entity that is related to the other entities.
   * @param relatedIDs - The express IDs of the entities that are related to the relating entity.
   *
   * @returns A promise that resolves with the newly created relationship.
   *
   * @throws Will throw an error if the relationship type is unsupported.
   */
  async createIfcRel(t, e, s, i) {
    const n = of[e];
    if (!n)
      throw new Error(`IfcPropertiesManager: ${n} is unsoported.`);
    const r = os.getIFCSchema(t), o = rf[n], a = W[r][n];
    if (!(o && a))
      throw new Error(`IfcPropertiesManager: ${n} is unsoported.`);
    const c = [new W[r].IfcGloballyUniqueId(zt.create())], { related: h, relating: f } = o, d = [...new Set(i)].map(
      (E) => new W.Handle(E)
    ), p = (E, I) => {
      for (let g = E; g < I - 1; g++)
        c.push(null);
    };
    h < f ? (p(1, h), c.push(d), p(h, f), c.push(new W.Handle(s))) : (p(1, f), p(f, h), c.push(new W.Handle(s)), c.push(d));
    const m = new a(...c);
    return await this.setData(t, m), m;
  }
  /**
   * Saves the changes made to the model to a new IFC file.
   *
   * @param model - The FragmentsGroup model from which to save the changes.
   * @param ifcToSaveOn - The Uint8Array representing the original IFC file.
   *
   * @returns A promise that resolves with the modified IFC data as a Uint8Array.
   *
   * @throws Will throw an error if any issues occur during the saving process.
   */
  async saveToIfc(t, e) {
    const s = this.components.get(nf), i = s.webIfc, n = await s.readIfcFile(e);
    await this.components.get(et).applyRelationChanges();
    const o = this.changeMap[t.uuid] ?? [];
    for (const c of o) {
      const h = await t.getProperties(c);
      h ? i.WriteLine(n, h) : i.GetLine(n, c) && i.DeleteLine(n, c);
    }
    const a = i.SaveModel(n);
    return s.webIfc.CloseModel(n), s.cleanUp(), a;
  }
  /**
   * Retrieves all the entities of a specific type from the model and returns their express IDs wrapped in Handles.
   * This is used to make references of an entity inside another entity attributes.
   *
   * @param model - The FragmentsGroup model from which to retrieve the entities.
   * @param type - The type of the entities to retrieve. This should be the express ID of the IFC type.
   *
   * @returns A promise that resolves with an array of Handles, each containing the express ID of an entity of the specified type.
   * @returns null if the model doesn't have any entity of that type
   */
  async getEntityRef(t, e) {
    const s = await t.getAllPropertiesOfType(e);
    if (!s)
      return null;
    const i = [];
    for (const n in s) {
      const r = new W.Handle(Number(n));
      i.push(r);
    }
    return i;
  }
  /**
   * Sets an attribute listener for a specific attribute of an entity in the model.
   * The listener will trigger an event whenever the attribute's value changes.
   *
   * @param model - The FragmentsGroup model in which to set the attribute listener.
   * @param expressID - The express ID of the entity for which to set the listener.
   * @param attributeName - The name of the attribute for which to set the listener.
   *
   * @returns The event that will be triggered when the attribute's value changes.
   *
   * @throws Will throw an error if the entity with the given expressID doesn't exist.
   * @throws Will throw an error if the attribute is an array or null, and it can't have a listener.
   * @throws Will throw an error if the attribute has a badly defined handle.
   */
  async setAttributeListener(t, e, s) {
    this.attributeListeners[t.uuid] || (this.attributeListeners[t.uuid] = {});
    const i = this.attributeListeners[t.uuid][e] ? this.attributeListeners[t.uuid][e][s] : null;
    if (i)
      return i;
    const n = await t.getProperties(e);
    if (!n)
      throw new Error(`Entity with expressID ${e} doesn't exists.`);
    const r = n[s];
    if (Array.isArray(r) || !r)
      throw new Error(
        `Attribute ${s} is array or null, and it can't have a listener.`
      );
    const o = r.value;
    if (o === void 0 || o == null)
      throw new Error(`Attribute ${s} has a badly defined handle.`);
    const a = new Y();
    return Object.defineProperty(n[s], "value", {
      get() {
        return this._value;
      },
      async set(c) {
        this._value = c, a.trigger(c);
      }
    }), n[s].value = o, this.attributeListeners[t.uuid][e] || (this.attributeListeners[t.uuid][e] = {}), this.attributeListeners[t.uuid][e][s] = a, a;
  }
  getNewExpressID(t) {
    return t.ifcMetadata.maxExpressID++, t.ifcMetadata.maxExpressID;
  }
  newGUID(t) {
    const e = os.getIFCSchema(t);
    return new W[e].IfcGloballyUniqueId(zt.create());
  }
  async getOwnerHistory(t) {
    const e = await t.getAllPropertiesOfType(
      W.IFCOWNERHISTORY
    );
    if (!e)
      throw new Error("No OwnerHistory was found.");
    const s = Object.keys(e).map((r) => parseInt(r, 10)), i = e[s[0]], n = new W.Handle(i.expressID);
    return { entity: i, handle: n };
  }
  registerChange(t, ...e) {
    this.changeMap[t.uuid] || (this.changeMap[t.uuid] = /* @__PURE__ */ new Set());
    for (const s of e)
      this.changeMap[t.uuid].add(s), this.onDataChanged.trigger({ model: t, expressID: s });
  }
  async newSingleProperty(t, e, s, i) {
    const n = os.getIFCSchema(t), r = new W[n].IfcIdentifier(s), o = new W[n][e](i), a = new W[n].IfcPropertySingleValue(
      r,
      null,
      o,
      null
    );
    return a.expressID = this.getNewExpressID(t), await this.setData(t, a), a;
  }
};
y(Fl, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
let af = Fl;
const wl = class kr extends ue {
  constructor(t) {
    super(t), y(this, "onDisposed", new Y()), y(this, "onRelationsIndexed", new Y()), y(this, "relationMaps", {}), y(this, "enabled", !0), y(this, "_relToAttributesMap", na), y(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements",
      "HasControlElements",
      "AssignedToFlowElement",
      "ConnectedTo",
      "ConnectedFrom",
      "ReferencedBy",
      "Declares",
      "HasContext",
      "Controls",
      "IsNestedBy",
      "Nests",
      "DocumentRefForObjects"
    ]), y(this, "_ifcRels", [
      W.IFCRELAGGREGATES,
      W.IFCRELASSOCIATESMATERIAL,
      W.IFCRELASSOCIATESCLASSIFICATION,
      W.IFCRELASSIGNSTOGROUP,
      W.IFCRELDEFINESBYPROPERTIES,
      W.IFCRELDEFINESBYTYPE,
      W.IFCRELDEFINESBYTEMPLATE,
      W.IFCRELCONTAINEDINSPATIALSTRUCTURE,
      W.IFCRELFLOWCONTROLELEMENTS,
      W.IFCRELCONNECTSELEMENTS,
      W.IFCRELASSIGNSTOPRODUCT,
      W.IFCRELDECLARES,
      W.IFCRELASSIGNSTOCONTROL,
      W.IFCRELNESTS,
      W.IFCRELASSOCIATESDOCUMENT
    ]), y(this, "onFragmentsDisposed", (s) => {
      delete this.relationMaps[s.groupID];
    }), y(this, "_changeMap", {}), y(this, "onEntitiesRelated", new Y()), this.components.add(kr.uuid, this), t.get(fe).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(t, e, s, i) {
    const n = Object.keys(e).find(
      (h) => h.startsWith("Relating")
    ), r = Object.keys(e).find(
      (h) => h.startsWith("Related")
    );
    if (!(n && r))
      return;
    const o = e[n].value, a = e[r].map((h) => h.value), c = this.getEntityRelations(
      t,
      o,
      i
    );
    for (const h of a)
      c.push(h);
    for (const h of a)
      this.getEntityRelations(t, h, s).push(o);
  }
  getAttributeIndex(t) {
    const e = this._inverseAttributes.indexOf(t);
    if (e === -1)
      throw new Error(
        `IfcRelationsIndexer: ${t} is not a valid IFC Inverse Attribute name or its not supported yet by this component.`
      );
    return e;
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(t, e) {
    this.relationMaps[t.uuid] = e, this.onRelationsIndexed.trigger({
      modelID: t.uuid,
      relationsMap: e
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(t, e) {
    if (!t.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let s = this.relationMaps[t.uuid];
    s || (s = /* @__PURE__ */ new Map(), this.relationMaps[t.uuid] = s);
    const i = t.getLocalProperties();
    if (!i)
      return s;
    const n = (e == null ? void 0 : e.relationsToProcess) ?? this._ifcRels;
    for (const [r, o] of Object.entries(i)) {
      if (!n.includes(o.type))
        continue;
      const a = this._relToAttributesMap.get(o.type);
      if (!a)
        continue;
      const { forRelated: c, forRelating: h } = a;
      this.indexRelations(s, o, c, h);
    }
    return this.setRelationMap(t, s), s;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(t, e) {
    const s = /* @__PURE__ */ new Map();
    for (const i of this._ifcRels) {
      const n = this._relToAttributesMap.get(i);
      if (!n)
        continue;
      const { forRelated: r, forRelating: o } = n, a = t.GetLineIDsWithType(e, i);
      for (let c = 0; c < a.size(); c++) {
        const h = await t.properties.getItemProperties(
          e,
          a.get(c)
        );
        this.indexRelations(s, h, r, o);
      }
    }
    return this.onRelationsIndexed.trigger({
      modelID: e.toString(),
      relationsMap: s
    }), s;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity, or its UUID.
   * @param expressID The unique identifier of the entity within the model.
   * @param attribute The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities. If the array is empty, no relations were found.
   */
  getEntityRelations(t, e, s) {
    const i = this.getAttributeIndex(s);
    let n;
    if (t instanceof Jn ? n = this.relationMaps[t.uuid] : typeof t == "string" ? n = this.relationMaps[t] : n = t, !n && (t instanceof Jn || typeof t == "string")) {
      n = /* @__PURE__ */ new Map();
      const a = t instanceof Jn ? t.uuid : t;
      this.relationMaps[a] = n;
    }
    let r = n.get(e);
    r || (r = /* @__PURE__ */ new Map(), n.set(e, r));
    let o = r.get(i);
    return o || (o = [], r.set(i, o)), o;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(t) {
    const e = {};
    for (const [s, i] of t.entries()) {
      e[s] || (e[s] = {});
      for (const [n, r] of i.entries())
        e[s][n] = r;
    }
    return JSON.stringify(e);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(t) {
    const e = this.relationMaps[t.uuid];
    return e ? this.serializeRelations(e) : null;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const t = {};
    for (const e in this.relationMaps) {
      const s = this.relationMaps[e], i = {};
      for (const [n, r] of s.entries()) {
        i[n] || (i[n] = {});
        for (const [o, a] of r.entries())
          i[n][o] = a;
      }
      t[e] = i;
    }
    return JSON.stringify(t);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(t) {
    const e = JSON.parse(t), s = /* @__PURE__ */ new Map();
    for (const i in e) {
      const n = e[i], r = /* @__PURE__ */ new Map();
      for (const o in n)
        r.set(Number(o), n[o]);
      s.set(Number(i), r);
    }
    return s;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.relationMaps = {}, this.components.get(fe).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(kr.uuid), this.onDisposed.reset();
  }
  /**
   * Retrieves the entities within a model that have a specific relation with a given entity.
   *
   * @param model - The BIM model to search for related entities.
   * @param inv - The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @param expressID - The expressID of the entity within the model.
   *
   * @returns A `Set` with the expressIDs of the entities that have the specified relation with the given entity.
   *
   * @throws An error if the model relations are not indexed or if the inverse attribute name is invalid.
   */
  getEntitiesWithRelation(t, e, s) {
    const i = this.relationMaps[t.uuid];
    if (!i)
      throw new Error(
        "IfcRelationsIndexer: the model relations are not indexed!"
      );
    const n = /* @__PURE__ */ new Set();
    for (const [r, o] of i) {
      const a = this.getAttributeIndex(e), c = o.get(a);
      c && c.includes(s) && n.add(r);
    }
    return n;
  }
  /**
   * Adds relations between an entity and other entities in a BIM model.
   *
   * @param model - The BIM model to which the relations will be added.
   * @param expressID - The expressID of the entity within the model.
   * @param relationName - The IFC schema inverse attribute of the relation to add (e.g., "IsDefinedBy", "ContainsElements").
   * @param relIDs - The expressIDs of the related entities within the model.
   * @deprecated Use addEntitiesRelation instead. This will be removed in future versions.
   *
   * @throws An error if the relation name is not a valid relation name.
   */
  addEntityRelations(t, e, s, ...i) {
    const n = this.getEntityRelations(
      t,
      e,
      s
    );
    if (n)
      n.push(...i);
    else {
      const r = this.getAttributeIndex(s), o = this.relationMaps[t.uuid].get(e);
      o == null || o.set(r, i);
    }
  }
  /**
   * Converts the relations made into actual IFC data.
   *
   * @remarks This function iterates through the changes made to the relations and applies them to the corresponding BIM model.
   * It only make sense to use it if the relations need to be write in the IFC file.
   *
   * @returns A promise that resolves when all the relation changes have been applied.
   */
  async applyRelationChanges() {
    const t = this.components.get(fe), e = this.components.get(af);
    for (const s in this._changeMap) {
      const i = t.groups.get(s);
      if (!i)
        continue;
      const n = this._changeMap[s];
      for (const [r, o] of n)
        for (const [a, c] of o) {
          const { related: h, relID: f } = c;
          if (f) {
            const u = await i.getProperties(f);
            if (!u)
              continue;
            const d = Object.keys(u), p = d.find((E) => E.startsWith("Related")), m = d.find((E) => E.startsWith("Relating"));
            if (!(p && m))
              continue;
            u[p] = [...h].map((E) => new W.Handle(E)), u[m] = new W.Handle(a), await e.setData(i, u);
          } else {
            const u = await e.createIfcRel(
              i,
              r,
              a,
              [...h]
            );
            if (!u)
              continue;
            c.relID = u.expressID;
          }
        }
    }
  }
  addEntitiesRelation(t, e, s, ...i) {
    const { type: n, inv: r } = s;
    let o = this.relationMaps[t.uuid];
    if (o || (o = /* @__PURE__ */ new Map(), this.relationMaps[t.uuid] = o), !this._ifcRels.includes(n))
      return;
    const a = na.get(n);
    if (!a)
      return;
    const { forRelated: c, forRelating: h } = a;
    if (!(c === r || h === r))
      return;
    let f = this._changeMap[t.uuid];
    f || (f = new mt(), this._changeMap[t.uuid] = f);
    const u = h === r ? [e] : i, d = c === r ? [e] : i;
    let p = f.get(n);
    p || (p = new mt(), p.onItemSet.add(
      () => this.onEntitiesRelated.trigger({
        invAttribute: r,
        relType: n,
        relatingIDs: u,
        relatedIDs: d
      })
    ), p.onItemUpdated.add(
      () => this.onEntitiesRelated.trigger({
        invAttribute: r,
        relType: n,
        relatingIDs: u,
        relatedIDs: d
      })
    ), f.set(n, p));
    for (const m of u) {
      let E = p.get(m);
      E || (E = { related: new qt() }, p.set(m, E)), E.related.add(...d);
    }
    for (const m of u)
      this.getEntityRelations(t, m, h).push(...d);
    for (const m of d)
      this.getEntityRelations(t, m, c).push(...u);
  }
  /**
   * Gets the children of the given element recursively. E.g. in a model with project - site - building - storeys - rooms, passing a storey will include all its children and the children of the rooms contained in it.
   *
   * @param model The BIM model whose children to get.
   * @param expressID The expressID of the item whose children to get.
   * @param found An optional parameter that includes a set of expressIDs where the found element IDs will be added.
   *
   * @returns A `Set` with the expressIDs of the found items.
   */
  getEntityChildren(t, e, s = /* @__PURE__ */ new Set()) {
    if (s.add(e), this.relationMaps[t.uuid] === void 0)
      throw new Error(
        "The provided model has no indices. You have to generate them first."
      );
    const n = this.getEntityRelations(
      t,
      e,
      "IsDecomposedBy"
    );
    if (n)
      for (const o of n)
        this.getEntityChildren(t, o, s);
    const r = this.getEntityRelations(t, e, "ContainsElements");
    if (r)
      for (const o of r)
        this.getEntityChildren(t, o, s);
    return s;
  }
};
y(wl, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
let et = wl;
const vl = class Ol extends ue {
  constructor(t) {
    super(t), y(this, "onDisposed", new Y()), y(this, "onFragmentsLoaded", new Y()), y(this, "onFragmentsDisposed", new Y()), y(this, "list", new mt()), y(this, "groups", new mt()), y(this, "baseCoordinationModel", ""), y(this, "baseCoordinationMatrix", new A.Matrix4()), y(this, "enabled", !0), y(this, "_loader", new Uc()), this.components.add(Ol.uuid, this);
  }
  /**
   * Getter for the meshes of all fragments in the FragmentsManager.
   * It iterates over the fragments in the list and pushes their meshes into an array.
   * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
   */
  get meshes() {
    const t = [];
    for (const [e, s] of this.list)
      t.push(s.mesh);
    return t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.groups)
      e.dispose(!0);
    this.baseCoordinationModel = "", this.groups.clear(), this.list.clear(), this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Dispose of a specific fragment group.
   * This method removes the group from the groups map, deletes all fragments within the group from the list,
   * disposes of the group, and triggers the onFragmentsDisposed event.
   *
   * @param group - The fragment group to be disposed.
   */
  disposeGroup(t) {
    const { uuid: e } = t, s = [];
    for (const i of t.items)
      s.push(i.id), this.list.delete(i.id);
    t.dispose(!0), this.groups.delete(t.uuid), this.groups.size === 0 && (this.baseCoordinationModel = "", this.baseCoordinationMatrix = new A.Matrix4()), this.onFragmentsDisposed.trigger({
      groupID: e,
      fragmentIDs: s
    });
  }
  /**
   * Loads a binary file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.isStreamed - Optional setting to determine whether this model is streamed or not.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(t, e) {
    const i = { ...{ coordinate: !0 }, ...e }, { coordinate: n, name: r, properties: o, relationsMap: a } = i, c = this._loader.import(t);
    e && (c.isStreamed = e.isStreamed || !1), r && (c.name = r);
    for (const h of c.items)
      h.group = c, this.list.set(h.id, h);
    return n && this.coordinate([c]), this.groups.set(c.uuid, c), o && c.setLocalProperties(o), a && this.components.get(et).setRelationMap(c, a), this.onFragmentsLoaded.trigger(c), c;
  }
  /**
   * Export the specified fragmentsgroup to binary data.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(t) {
    return this._loader.export(t);
  }
  /**
   * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
   * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
   * @returns A map of model IDs to sets of express IDs.
   */
  getModelIdMap(t) {
    const e = {};
    for (const s in t) {
      const i = this.list.get(s);
      if (!(i && i.group))
        continue;
      const n = i.group;
      n.uuid in e || (e[n.uuid] = /* @__PURE__ */ new Set());
      const r = t[s];
      for (const o of r)
        e[n.uuid].add(o);
    }
    return e;
  }
  /**
   * Converts a map of model IDs to sets of express IDs to a fragment ID map.
   * @param modelIdMap - A map of model IDs to their corresponding express IDs.
   * @returns A fragment ID map.
   * @remarks
   * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
   * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
   * The fragment ID maps are then merged into a single map and returned.
   * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
   */
  modelIdToFragmentIdMap(t) {
    let e = {};
    for (const s in t) {
      const i = this.groups.get(s);
      if (!i)
        continue;
      const n = t[s], r = i.getFragmentMap(n);
      e = { ...e, ...r };
    }
    return e;
  }
  /**
   * Converts a collection of IFC GUIDs to a fragmentIdMap.
   *
   * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
   *
   * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
   */
  guidToFragmentIdMap(t) {
    const e = {};
    for (const [i, n] of this.groups) {
      i in e || (e[i] = /* @__PURE__ */ new Set());
      for (const r of t) {
        const o = n.globalToExpressIDs.get(r);
        o && e[i].add(o);
      }
    }
    return this.modelIdToFragmentIdMap(e);
  }
  /**
   * Converts a fragment ID map to a collection of IFC GUIDs.
   *
   * @param fragmentIdMap - A fragment ID map to be converted to a collection of IFC GUIDs.
   *
   * @returns An array of IFC GUIDs.
   */
  fragmentIdMapToGuids(t) {
    const e = [], s = this.getModelIdMap(t);
    for (const i in s) {
      const n = this.groups.get(i);
      if (!n)
        continue;
      const r = s[i];
      for (const o of r)
        for (const [a, c] of n.globalToExpressIDs.entries())
          if (c === o) {
            e.push(a);
            break;
          }
    }
    return e;
  }
  /**
   * Applies coordinate transformation to the provided models.
   * If no models are provided, all groups are used.
   * The first model in the list becomes the base model for coordinate transformation.
   * All other models are then transformed to match the base model's coordinate system.
   *
   * @param models - The models to apply coordinate transformation to.
   * If not provided, all models are used.
   */
  coordinate(t = Array.from(this.groups.values())) {
    if (this.baseCoordinationModel.length === 0) {
      const s = t.pop();
      if (!s)
        return;
      this.baseCoordinationModel = s.uuid, this.baseCoordinationMatrix = s.coordinationMatrix.clone();
    }
    if (t.length)
      for (const s of t)
        s.coordinationMatrix.equals(this.baseCoordinationMatrix) || (s.position.set(0, 0, 0), s.rotation.set(0, 0, 0), s.scale.set(1, 1, 1), s.updateMatrix(), this.applyBaseCoordinateSystem(s, s.coordinationMatrix));
  }
  /**
   * Applies the base coordinate system to the provided object.
   *
   * This function takes an object and its original coordinate system as input.
   * It then inverts the original coordinate system and applies the base coordinate system
   * to the object. This ensures that the object's position, rotation, and scale are
   * transformed to match the base coordinate system (which is taken from the first model loaded).
   *
   * @param object - The object to which the base coordinate system will be applied.
   * This should be an instance of THREE.Object3D.
   *
   * @param originalCoordinateSystem - The original coordinate system of the object.
   * This should be a THREE.Matrix4 representing the object's transformation matrix.
   */
  applyBaseCoordinateSystem(t, e) {
    e && t.applyMatrix4(e.clone().invert()), t.applyMatrix4(this.baseCoordinationMatrix);
  }
  /**
   * Creates a copy of the whole model or a part of it.
   *
   * @param model - The model to clone.
   * @param items - Optional - The part of the model to be cloned. If not given, the whole group is cloned.
   *
   */
  clone(t, e) {
    const s = t.cloneGroup(e);
    this.groups.set(s.uuid, s);
    for (const i of s.items)
      this.list.set(i.id, i);
    return s;
  }
};
y(vl, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
let fe = vl;
function nn(l) {
  throw new Error('Could not dynamically require "' + l + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Pl = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(l, t) {
  (function(e) {
    l.exports = e();
  })(function() {
    return function e(s, i, n) {
      function r(c, h) {
        if (!i[c]) {
          if (!s[c]) {
            var f = typeof nn == "function" && nn;
            if (!h && f)
              return f(c, !0);
            if (o)
              return o(c, !0);
            var u = new Error("Cannot find module '" + c + "'");
            throw u.code = "MODULE_NOT_FOUND", u;
          }
          var d = i[c] = { exports: {} };
          s[c][0].call(d.exports, function(p) {
            var m = s[c][1][p];
            return r(m || p);
          }, d, d.exports, e, s, i, n);
        }
        return i[c].exports;
      }
      for (var o = typeof nn == "function" && nn, a = 0; a < n.length; a++)
        r(n[a]);
      return r;
    }({ 1: [function(e, s, i) {
      var n = e("./utils"), r = e("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(a) {
        for (var c, h, f, u, d, p, m, E = [], I = 0, g = a.length, T = g, C = n.getTypeOf(a) !== "string"; I < a.length; )
          T = g - I, f = C ? (c = a[I++], h = I < g ? a[I++] : 0, I < g ? a[I++] : 0) : (c = a.charCodeAt(I++), h = I < g ? a.charCodeAt(I++) : 0, I < g ? a.charCodeAt(I++) : 0), u = c >> 2, d = (3 & c) << 4 | h >> 4, p = 1 < T ? (15 & h) << 2 | f >> 6 : 64, m = 2 < T ? 63 & f : 64, E.push(o.charAt(u) + o.charAt(d) + o.charAt(p) + o.charAt(m));
        return E.join("");
      }, i.decode = function(a) {
        var c, h, f, u, d, p, m = 0, E = 0, I = "data:";
        if (a.substr(0, I.length) === I)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var g, T = 3 * (a = a.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (a.charAt(a.length - 1) === o.charAt(64) && T--, a.charAt(a.length - 2) === o.charAt(64) && T--, T % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (g = r.uint8array ? new Uint8Array(0 | T) : new Array(0 | T); m < a.length; )
          c = o.indexOf(a.charAt(m++)) << 2 | (u = o.indexOf(a.charAt(m++))) >> 4, h = (15 & u) << 4 | (d = o.indexOf(a.charAt(m++))) >> 2, f = (3 & d) << 6 | (p = o.indexOf(a.charAt(m++))), g[E++] = c, d !== 64 && (g[E++] = h), p !== 64 && (g[E++] = f);
        return g;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, s, i) {
      var n = e("./external"), r = e("./stream/DataWorker"), o = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
      function c(h, f, u, d, p) {
        this.compressedSize = h, this.uncompressedSize = f, this.crc32 = u, this.compression = d, this.compressedContent = p;
      }
      c.prototype = { getContentWorker: function() {
        var h = new r(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), f = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== f.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new r(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(h, f, u) {
        return h.pipe(new o()).pipe(new a("uncompressedSize")).pipe(f.compressWorker(u)).pipe(new a("compressedSize")).withStreamInfo("compression", f);
      }, s.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, s, i) {
      var n = e("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, i.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, s, i) {
      var n = e("./utils"), r = function() {
        for (var o, a = [], c = 0; c < 256; c++) {
          o = c;
          for (var h = 0; h < 8; h++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[c] = o;
        }
        return a;
      }();
      s.exports = function(o, a) {
        return o !== void 0 && o.length ? n.getTypeOf(o) !== "string" ? function(c, h, f, u) {
          var d = r, p = u + f;
          c ^= -1;
          for (var m = u; m < p; m++)
            c = c >>> 8 ^ d[255 & (c ^ h[m])];
          return -1 ^ c;
        }(0 | a, o, o.length, 0) : function(c, h, f, u) {
          var d = r, p = u + f;
          c ^= -1;
          for (var m = u; m < p; m++)
            c = c >>> 8 ^ d[255 & (c ^ h.charCodeAt(m))];
          return -1 ^ c;
        }(0 | a, o, o.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, s, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(e, s, i) {
      var n = null;
      n = typeof Promise < "u" ? Promise : e("lie"), s.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e, s, i) {
      var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", r = e("pako"), o = e("./utils"), a = e("./stream/GenericWorker"), c = n ? "uint8array" : "array";
      function h(f, u) {
        a.call(this, "FlateWorker/" + f), this._pako = null, this._pakoAction = f, this._pakoOptions = u, this.meta = {};
      }
      i.magic = "\b\0", o.inherits(h, a), h.prototype.processChunk = function(f) {
        this.meta = f.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(c, f.data), !1);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new r[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var f = this;
        this._pako.onData = function(u) {
          f.push({ data: u, meta: f.meta });
        };
      }, i.compressWorker = function(f) {
        return new h("Deflate", f);
      }, i.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, s, i) {
      function n(d, p) {
        var m, E = "";
        for (m = 0; m < p; m++)
          E += String.fromCharCode(255 & d), d >>>= 8;
        return E;
      }
      function r(d, p, m, E, I, g) {
        var T, C, F = d.file, O = d.compression, P = g !== c.utf8encode, M = o.transformTo("string", g(F.name)), L = o.transformTo("string", c.utf8encode(F.name)), b = F.comment, B = o.transformTo("string", g(b)), v = o.transformTo("string", c.utf8encode(b)), D = L.length !== F.name.length, R = v.length !== b.length, _ = "", K = "", U = "", Z = F.dir, H = F.date, J = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        p && !m || (J.crc32 = d.crc32, J.compressedSize = d.compressedSize, J.uncompressedSize = d.uncompressedSize);
        var z = 0;
        p && (z |= 8), P || !D && !R || (z |= 2048);
        var k = 0, ae = 0;
        Z && (k |= 16), I === "UNIX" ? (ae = 798, k |= function(ie, Fe) {
          var Le = ie;
          return ie || (Le = Fe ? 16893 : 33204), (65535 & Le) << 16;
        }(F.unixPermissions, Z)) : (ae = 20, k |= function(ie) {
          return 63 & (ie || 0);
        }(F.dosPermissions)), T = H.getUTCHours(), T <<= 6, T |= H.getUTCMinutes(), T <<= 5, T |= H.getUTCSeconds() / 2, C = H.getUTCFullYear() - 1980, C <<= 4, C |= H.getUTCMonth() + 1, C <<= 5, C |= H.getUTCDate(), D && (K = n(1, 1) + n(h(M), 4) + L, _ += "up" + n(K.length, 2) + K), R && (U = n(1, 1) + n(h(B), 4) + v, _ += "uc" + n(U.length, 2) + U);
        var ne = "";
        return ne += `
\0`, ne += n(z, 2), ne += O.magic, ne += n(T, 2), ne += n(C, 2), ne += n(J.crc32, 4), ne += n(J.compressedSize, 4), ne += n(J.uncompressedSize, 4), ne += n(M.length, 2), ne += n(_.length, 2), { fileRecord: f.LOCAL_FILE_HEADER + ne + M + _, dirRecord: f.CENTRAL_FILE_HEADER + n(ae, 2) + ne + n(B.length, 2) + "\0\0\0\0" + n(k, 4) + n(E, 4) + M + _ + B };
      }
      var o = e("../utils"), a = e("../stream/GenericWorker"), c = e("../utf8"), h = e("../crc32"), f = e("../signature");
      function u(d, p, m, E) {
        a.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = p, this.zipPlatform = m, this.encodeFileName = E, this.streamFiles = d, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      o.inherits(u, a), u.prototype.push = function(d) {
        var p = d.meta.percent || 0, m = this.entriesCount, E = this._sources.length;
        this.accumulate ? this.contentBuffer.push(d) : (this.bytesWritten += d.data.length, a.prototype.push.call(this, { data: d.data, meta: { currentFile: this.currentFile, percent: m ? (p + 100 * (m - E - 1)) / m : 100 } }));
      }, u.prototype.openedSource = function(d) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = d.file.name;
        var p = this.streamFiles && !d.file.dir;
        if (p) {
          var m = r(d, p, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: m.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, u.prototype.closedSource = function(d) {
        this.accumulate = !1;
        var p = this.streamFiles && !d.file.dir, m = r(d, p, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(m.dirRecord), p)
          this.push({ data: function(E) {
            return f.DATA_DESCRIPTOR + n(E.crc32, 4) + n(E.compressedSize, 4) + n(E.uncompressedSize, 4);
          }(d), meta: { percent: 100 } });
        else
          for (this.push({ data: m.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, u.prototype.flush = function() {
        for (var d = this.bytesWritten, p = 0; p < this.dirRecords.length; p++)
          this.push({ data: this.dirRecords[p], meta: { percent: 100 } });
        var m = this.bytesWritten - d, E = function(I, g, T, C, F) {
          var O = o.transformTo("string", F(C));
          return f.CENTRAL_DIRECTORY_END + "\0\0\0\0" + n(I, 2) + n(I, 2) + n(g, 4) + n(T, 4) + n(O.length, 2) + O;
        }(this.dirRecords.length, m, d, this.zipComment, this.encodeFileName);
        this.push({ data: E, meta: { percent: 100 } });
      }, u.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, u.prototype.registerPrevious = function(d) {
        this._sources.push(d);
        var p = this;
        return d.on("data", function(m) {
          p.processChunk(m);
        }), d.on("end", function() {
          p.closedSource(p.previous.streamInfo), p._sources.length ? p.prepareNextSource() : p.end();
        }), d.on("error", function(m) {
          p.error(m);
        }), this;
      }, u.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, u.prototype.error = function(d) {
        var p = this._sources;
        if (!a.prototype.error.call(this, d))
          return !1;
        for (var m = 0; m < p.length; m++)
          try {
            p[m].error(d);
          } catch {
          }
        return !0;
      }, u.prototype.lock = function() {
        a.prototype.lock.call(this);
        for (var d = this._sources, p = 0; p < d.length; p++)
          d[p].lock();
      }, s.exports = u;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, s, i) {
      var n = e("../compressions"), r = e("./ZipFileWorker");
      i.generateWorker = function(o, a, c) {
        var h = new r(a.streamFiles, c, a.platform, a.encodeFileName), f = 0;
        try {
          o.forEach(function(u, d) {
            f++;
            var p = function(g, T) {
              var C = g || T, F = n[C];
              if (!F)
                throw new Error(C + " is not a valid compression method !");
              return F;
            }(d.options.compression, a.compression), m = d.options.compressionOptions || a.compressionOptions || {}, E = d.dir, I = d.date;
            d._compressWorker(p, m).withStreamInfo("file", { name: u, dir: E, date: I, comment: d.comment || "", unixPermissions: d.unixPermissions, dosPermissions: d.dosPermissions }).pipe(h);
          }), h.entriesCount = f;
        } catch (u) {
          h.error(u);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, s, i) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var r = new n();
          for (var o in this)
            typeof this[o] != "function" && (r[o] = this[o]);
          return r;
        };
      }
      (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(r, o) {
        return new n().loadAsync(r, o);
      }, n.external = e("./external"), s.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, s, i) {
      var n = e("./utils"), r = e("./external"), o = e("./utf8"), a = e("./zipEntries"), c = e("./stream/Crc32Probe"), h = e("./nodejsUtils");
      function f(u) {
        return new r.Promise(function(d, p) {
          var m = u.decompressed.getContentWorker().pipe(new c());
          m.on("error", function(E) {
            p(E);
          }).on("end", function() {
            m.streamInfo.crc32 !== u.decompressed.crc32 ? p(new Error("Corrupted zip : CRC32 mismatch")) : d();
          }).resume();
        });
      }
      s.exports = function(u, d) {
        var p = this;
        return d = n.extend(d || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: o.utf8decode }), h.isNode && h.isStream(u) ? r.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", u, !0, d.optimizedBinaryString, d.base64).then(function(m) {
          var E = new a(d);
          return E.load(m), E;
        }).then(function(m) {
          var E = [r.Promise.resolve(m)], I = m.files;
          if (d.checkCRC32)
            for (var g = 0; g < I.length; g++)
              E.push(f(I[g]));
          return r.Promise.all(E);
        }).then(function(m) {
          for (var E = m.shift(), I = E.files, g = 0; g < I.length; g++) {
            var T = I[g], C = T.fileNameStr, F = n.resolve(T.fileNameStr);
            p.file(F, T.decompressed, { binary: !0, optimizedBinaryString: !0, date: T.date, dir: T.dir, comment: T.fileCommentStr.length ? T.fileCommentStr : null, unixPermissions: T.unixPermissions, dosPermissions: T.dosPermissions, createFolders: d.createFolders }), T.dir || (p.file(F).unsafeOriginalName = C);
          }
          return E.zipComment.length && (p.comment = E.zipComment), p;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, s, i) {
      var n = e("../utils"), r = e("../stream/GenericWorker");
      function o(a, c) {
        r.call(this, "Nodejs stream input adapter for " + a), this._upstreamEnded = !1, this._bindStream(c);
      }
      n.inherits(o, r), o.prototype._bindStream = function(a) {
        var c = this;
        (this._stream = a).pause(), a.on("data", function(h) {
          c.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          c.isPaused ? this.generatedError = h : c.error(h);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, o.prototype.pause = function() {
        return !!r.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, o.prototype.resume = function() {
        return !!r.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, s.exports = o;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, s, i) {
      var n = e("readable-stream").Readable;
      function r(o, a, c) {
        n.call(this, a), this._helper = o;
        var h = this;
        o.on("data", function(f, u) {
          h.push(f) || h._helper.pause(), c && c(u);
        }).on("error", function(f) {
          h.emit("error", f);
        }).on("end", function() {
          h.push(null);
        });
      }
      e("../utils").inherits(r, n), r.prototype._read = function() {
        this._helper.resume();
      }, s.exports = r;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, s, i) {
      s.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(n, r) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(n, r);
        if (typeof n == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(n, r);
      }, allocBuffer: function(n) {
        if (Buffer.alloc)
          return Buffer.alloc(n);
        var r = new Buffer(n);
        return r.fill(0), r;
      }, isBuffer: function(n) {
        return Buffer.isBuffer(n);
      }, isStream: function(n) {
        return n && typeof n.on == "function" && typeof n.pause == "function" && typeof n.resume == "function";
      } };
    }, {}], 15: [function(e, s, i) {
      function n(F, O, P) {
        var M, L = o.getTypeOf(O), b = o.extend(P || {}, h);
        b.date = b.date || /* @__PURE__ */ new Date(), b.compression !== null && (b.compression = b.compression.toUpperCase()), typeof b.unixPermissions == "string" && (b.unixPermissions = parseInt(b.unixPermissions, 8)), b.unixPermissions && 16384 & b.unixPermissions && (b.dir = !0), b.dosPermissions && 16 & b.dosPermissions && (b.dir = !0), b.dir && (F = I(F)), b.createFolders && (M = E(F)) && g.call(this, M, !0);
        var B = L === "string" && b.binary === !1 && b.base64 === !1;
        P && P.binary !== void 0 || (b.binary = !B), (O instanceof f && O.uncompressedSize === 0 || b.dir || !O || O.length === 0) && (b.base64 = !1, b.binary = !0, O = "", b.compression = "STORE", L = "string");
        var v = null;
        v = O instanceof f || O instanceof a ? O : p.isNode && p.isStream(O) ? new m(F, O) : o.prepareContent(F, O, b.binary, b.optimizedBinaryString, b.base64);
        var D = new u(F, v, b);
        this.files[F] = D;
      }
      var r = e("./utf8"), o = e("./utils"), a = e("./stream/GenericWorker"), c = e("./stream/StreamHelper"), h = e("./defaults"), f = e("./compressedObject"), u = e("./zipObject"), d = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), E = function(F) {
        F.slice(-1) === "/" && (F = F.substring(0, F.length - 1));
        var O = F.lastIndexOf("/");
        return 0 < O ? F.substring(0, O) : "";
      }, I = function(F) {
        return F.slice(-1) !== "/" && (F += "/"), F;
      }, g = function(F, O) {
        return O = O !== void 0 ? O : h.createFolders, F = I(F), this.files[F] || n.call(this, F, null, { dir: !0, createFolders: O }), this.files[F];
      };
      function T(F) {
        return Object.prototype.toString.call(F) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(F) {
        var O, P, M;
        for (O in this.files)
          M = this.files[O], (P = O.slice(this.root.length, O.length)) && O.slice(0, this.root.length) === this.root && F(P, M);
      }, filter: function(F) {
        var O = [];
        return this.forEach(function(P, M) {
          F(P, M) && O.push(M);
        }), O;
      }, file: function(F, O, P) {
        if (arguments.length !== 1)
          return F = this.root + F, n.call(this, F, O, P), this;
        if (T(F)) {
          var M = F;
          return this.filter(function(b, B) {
            return !B.dir && M.test(b);
          });
        }
        var L = this.files[this.root + F];
        return L && !L.dir ? L : null;
      }, folder: function(F) {
        if (!F)
          return this;
        if (T(F))
          return this.filter(function(L, b) {
            return b.dir && F.test(L);
          });
        var O = this.root + F, P = g.call(this, O), M = this.clone();
        return M.root = P.name, M;
      }, remove: function(F) {
        F = this.root + F;
        var O = this.files[F];
        if (O || (F.slice(-1) !== "/" && (F += "/"), O = this.files[F]), O && !O.dir)
          delete this.files[F];
        else
          for (var P = this.filter(function(L, b) {
            return b.name.slice(0, F.length) === F;
          }), M = 0; M < P.length; M++)
            delete this.files[P[M].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(F) {
        var O, P = {};
        try {
          if ((P = o.extend(F || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: r.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type)
            throw new Error("No output type specified.");
          o.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var M = P.comment || this.comment || "";
          O = d.generateWorker(this, P, M);
        } catch (L) {
          (O = new a("error")).error(L);
        }
        return new c(O, P.type || "string", P.mimeType);
      }, generateAsync: function(F, O) {
        return this.generateInternalStream(F).accumulate(O);
      }, generateNodeStream: function(F, O) {
        return (F = F || {}).type || (F.type = "nodebuffer"), this.generateInternalStream(F).toNodejsStream(O);
      } };
      s.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, s, i) {
      s.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, s, i) {
      var n = e("./DataReader");
      function r(o) {
        n.call(this, o);
        for (var a = 0; a < this.data.length; a++)
          o[a] = 255 & o[a];
      }
      e("../utils").inherits(r, n), r.prototype.byteAt = function(o) {
        return this.data[this.zero + o];
      }, r.prototype.lastIndexOfSignature = function(o) {
        for (var a = o.charCodeAt(0), c = o.charCodeAt(1), h = o.charCodeAt(2), f = o.charCodeAt(3), u = this.length - 4; 0 <= u; --u)
          if (this.data[u] === a && this.data[u + 1] === c && this.data[u + 2] === h && this.data[u + 3] === f)
            return u - this.zero;
        return -1;
      }, r.prototype.readAndCheckSignature = function(o) {
        var a = o.charCodeAt(0), c = o.charCodeAt(1), h = o.charCodeAt(2), f = o.charCodeAt(3), u = this.readData(4);
        return a === u[0] && c === u[1] && h === u[2] && f === u[3];
      }, r.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return [];
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, s, i) {
      var n = e("../utils");
      function r(o) {
        this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
      }
      r.prototype = { checkOffset: function(o) {
        this.checkIndex(this.index + o);
      }, checkIndex: function(o) {
        if (this.length < this.zero + o || o < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
      }, setIndex: function(o) {
        this.checkIndex(o), this.index = o;
      }, skip: function(o) {
        this.setIndex(this.index + o);
      }, byteAt: function() {
      }, readInt: function(o) {
        var a, c = 0;
        for (this.checkOffset(o), a = this.index + o - 1; a >= this.index; a--)
          c = (c << 8) + this.byteAt(a);
        return this.index += o, c;
      }, readString: function(o) {
        return n.transformTo("string", this.readData(o));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var o = this.readInt(4);
        return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
      } }, s.exports = r;
    }, { "../utils": 32 }], 19: [function(e, s, i) {
      var n = e("./Uint8ArrayReader");
      function r(o) {
        n.call(this, o);
      }
      e("../utils").inherits(r, n), r.prototype.readData = function(o) {
        this.checkOffset(o);
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, s, i) {
      var n = e("./DataReader");
      function r(o) {
        n.call(this, o);
      }
      e("../utils").inherits(r, n), r.prototype.byteAt = function(o) {
        return this.data.charCodeAt(this.zero + o);
      }, r.prototype.lastIndexOfSignature = function(o) {
        return this.data.lastIndexOf(o) - this.zero;
      }, r.prototype.readAndCheckSignature = function(o) {
        return o === this.readData(4);
      }, r.prototype.readData = function(o) {
        this.checkOffset(o);
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, s, i) {
      var n = e("./ArrayReader");
      function r(o) {
        n.call(this, o);
      }
      e("../utils").inherits(r, n), r.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return new Uint8Array(0);
        var a = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, s, i) {
      var n = e("../utils"), r = e("../support"), o = e("./ArrayReader"), a = e("./StringReader"), c = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      s.exports = function(f) {
        var u = n.getTypeOf(f);
        return n.checkSupport(u), u !== "string" || r.uint8array ? u === "nodebuffer" ? new c(f) : r.uint8array ? new h(n.transformTo("uint8array", f)) : new o(n.transformTo("array", f)) : new a(f);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, s, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, s, i) {
      var n = e("./GenericWorker"), r = e("../utils");
      function o(a) {
        n.call(this, "ConvertWorker to " + a), this.destType = a;
      }
      r.inherits(o, n), o.prototype.processChunk = function(a) {
        this.push({ data: r.transformTo(this.destType, a.data), meta: a.meta });
      }, s.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, s, i) {
      var n = e("./GenericWorker"), r = e("../crc32");
      function o() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(o, n), o.prototype.processChunk = function(a) {
        this.streamInfo.crc32 = r(a.data, this.streamInfo.crc32 || 0), this.push(a);
      }, s.exports = o;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, s, i) {
      var n = e("../utils"), r = e("./GenericWorker");
      function o(a) {
        r.call(this, "DataLengthProbe for " + a), this.propName = a, this.withStreamInfo(a, 0);
      }
      n.inherits(o, r), o.prototype.processChunk = function(a) {
        if (a) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + a.data.length;
        }
        r.prototype.processChunk.call(this, a);
      }, s.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, s, i) {
      var n = e("../utils"), r = e("./GenericWorker");
      function o(a) {
        r.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, a.then(function(h) {
          c.dataIsReady = !0, c.data = h, c.max = h && h.length || 0, c.type = n.getTypeOf(h), c.isPaused || c._tickAndRepeat();
        }, function(h) {
          c.error(h);
        });
      }
      n.inherits(o, r), o.prototype.cleanUp = function() {
        r.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return !!r.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0);
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var a = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            a = this.data.substring(this.index, c);
            break;
          case "uint8array":
            a = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            a = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: a, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, s.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, s, i) {
      function n(r) {
        this.name = r || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(r) {
        this.emit("data", r);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (r) {
          this.emit("error", r);
        }
        return !0;
      }, error: function(r) {
        return !this.isFinished && (this.isPaused ? this.generatedError = r : (this.isFinished = !0, this.emit("error", r), this.previous && this.previous.error(r), this.cleanUp()), !0);
      }, on: function(r, o) {
        return this._listeners[r].push(o), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(r, o) {
        if (this._listeners[r])
          for (var a = 0; a < this._listeners[r].length; a++)
            this._listeners[r][a].call(this, o);
      }, pipe: function(r) {
        return r.registerPrevious(this);
      }, registerPrevious: function(r) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = r.streamInfo, this.mergeStreamInfo(), this.previous = r;
        var o = this;
        return r.on("data", function(a) {
          o.processChunk(a);
        }), r.on("end", function() {
          o.end();
        }), r.on("error", function(a) {
          o.error(a);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var r = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), r = !0), this.previous && this.previous.resume(), !r;
      }, flush: function() {
      }, processChunk: function(r) {
        this.push(r);
      }, withStreamInfo: function(r, o) {
        return this.extraStreamInfo[r] = o, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var r in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, r) && (this.streamInfo[r] = this.extraStreamInfo[r]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var r = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + r : r;
      } }, s.exports = n;
    }, {}], 29: [function(e, s, i) {
      var n = e("../utils"), r = e("./ConvertWorker"), o = e("./GenericWorker"), a = e("../base64"), c = e("../support"), h = e("../external"), f = null;
      if (c.nodestream)
        try {
          f = e("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function u(p, m) {
        return new h.Promise(function(E, I) {
          var g = [], T = p._internalType, C = p._outputType, F = p._mimeType;
          p.on("data", function(O, P) {
            g.push(O), m && m(P);
          }).on("error", function(O) {
            g = [], I(O);
          }).on("end", function() {
            try {
              var O = function(P, M, L) {
                switch (P) {
                  case "blob":
                    return n.newBlob(n.transformTo("arraybuffer", M), L);
                  case "base64":
                    return a.encode(M);
                  default:
                    return n.transformTo(P, M);
                }
              }(C, function(P, M) {
                var L, b = 0, B = null, v = 0;
                for (L = 0; L < M.length; L++)
                  v += M[L].length;
                switch (P) {
                  case "string":
                    return M.join("");
                  case "array":
                    return Array.prototype.concat.apply([], M);
                  case "uint8array":
                    for (B = new Uint8Array(v), L = 0; L < M.length; L++)
                      B.set(M[L], b), b += M[L].length;
                    return B;
                  case "nodebuffer":
                    return Buffer.concat(M);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(T, g), F);
              E(O);
            } catch (P) {
              I(P);
            }
            g = [];
          }).resume();
        });
      }
      function d(p, m, E) {
        var I = m;
        switch (m) {
          case "blob":
          case "arraybuffer":
            I = "uint8array";
            break;
          case "base64":
            I = "string";
        }
        try {
          this._internalType = I, this._outputType = m, this._mimeType = E, n.checkSupport(I), this._worker = p.pipe(new r(I)), p.lock();
        } catch (g) {
          this._worker = new o("error"), this._worker.error(g);
        }
      }
      d.prototype = { accumulate: function(p) {
        return u(this, p);
      }, on: function(p, m) {
        var E = this;
        return p === "data" ? this._worker.on(p, function(I) {
          m.call(E, I.data, I.meta);
        }) : this._worker.on(p, function() {
          n.delay(m, arguments, E);
        }), this;
      }, resume: function() {
        return n.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(p) {
        if (n.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new f(this, { objectMode: this._outputType !== "nodebuffer" }, p);
      } }, s.exports = d;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, s, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var n = new ArrayBuffer(0);
        try {
          i.blob = new Blob([n], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var r = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            r.append(n), i.blob = r.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!e("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, s, i) {
      for (var n = e("./utils"), r = e("./support"), o = e("./nodejsUtils"), a = e("./stream/GenericWorker"), c = new Array(256), h = 0; h < 256; h++)
        c[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      c[254] = c[254] = 1;
      function f() {
        a.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function u() {
        a.call(this, "utf-8 encode");
      }
      i.utf8encode = function(d) {
        return r.nodebuffer ? o.newBufferFrom(d, "utf-8") : function(p) {
          var m, E, I, g, T, C = p.length, F = 0;
          for (g = 0; g < C; g++)
            (64512 & (E = p.charCodeAt(g))) == 55296 && g + 1 < C && (64512 & (I = p.charCodeAt(g + 1))) == 56320 && (E = 65536 + (E - 55296 << 10) + (I - 56320), g++), F += E < 128 ? 1 : E < 2048 ? 2 : E < 65536 ? 3 : 4;
          for (m = r.uint8array ? new Uint8Array(F) : new Array(F), g = T = 0; T < F; g++)
            (64512 & (E = p.charCodeAt(g))) == 55296 && g + 1 < C && (64512 & (I = p.charCodeAt(g + 1))) == 56320 && (E = 65536 + (E - 55296 << 10) + (I - 56320), g++), E < 128 ? m[T++] = E : (E < 2048 ? m[T++] = 192 | E >>> 6 : (E < 65536 ? m[T++] = 224 | E >>> 12 : (m[T++] = 240 | E >>> 18, m[T++] = 128 | E >>> 12 & 63), m[T++] = 128 | E >>> 6 & 63), m[T++] = 128 | 63 & E);
          return m;
        }(d);
      }, i.utf8decode = function(d) {
        return r.nodebuffer ? n.transformTo("nodebuffer", d).toString("utf-8") : function(p) {
          var m, E, I, g, T = p.length, C = new Array(2 * T);
          for (m = E = 0; m < T; )
            if ((I = p[m++]) < 128)
              C[E++] = I;
            else if (4 < (g = c[I]))
              C[E++] = 65533, m += g - 1;
            else {
              for (I &= g === 2 ? 31 : g === 3 ? 15 : 7; 1 < g && m < T; )
                I = I << 6 | 63 & p[m++], g--;
              1 < g ? C[E++] = 65533 : I < 65536 ? C[E++] = I : (I -= 65536, C[E++] = 55296 | I >> 10 & 1023, C[E++] = 56320 | 1023 & I);
            }
          return C.length !== E && (C.subarray ? C = C.subarray(0, E) : C.length = E), n.applyFromCharCode(C);
        }(d = n.transformTo(r.uint8array ? "uint8array" : "array", d));
      }, n.inherits(f, a), f.prototype.processChunk = function(d) {
        var p = n.transformTo(r.uint8array ? "uint8array" : "array", d.data);
        if (this.leftOver && this.leftOver.length) {
          if (r.uint8array) {
            var m = p;
            (p = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), p.set(m, this.leftOver.length);
          } else
            p = this.leftOver.concat(p);
          this.leftOver = null;
        }
        var E = function(g, T) {
          var C;
          for ((T = T || g.length) > g.length && (T = g.length), C = T - 1; 0 <= C && (192 & g[C]) == 128; )
            C--;
          return C < 0 || C === 0 ? T : C + c[g[C]] > T ? C : T;
        }(p), I = p;
        E !== p.length && (r.uint8array ? (I = p.subarray(0, E), this.leftOver = p.subarray(E, p.length)) : (I = p.slice(0, E), this.leftOver = p.slice(E, p.length))), this.push({ data: i.utf8decode(I), meta: d.meta });
      }, f.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = f, n.inherits(u, a), u.prototype.processChunk = function(d) {
        this.push({ data: i.utf8encode(d.data), meta: d.meta });
      }, i.Utf8EncodeWorker = u;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, s, i) {
      var n = e("./support"), r = e("./base64"), o = e("./nodejsUtils"), a = e("./external");
      function c(m) {
        return m;
      }
      function h(m, E) {
        for (var I = 0; I < m.length; ++I)
          E[I] = 255 & m.charCodeAt(I);
        return E;
      }
      e("setimmediate"), i.newBlob = function(m, E) {
        i.checkSupport("blob");
        try {
          return new Blob([m], { type: E });
        } catch {
          try {
            var I = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return I.append(m), I.getBlob(E);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var f = { stringifyByChunk: function(m, E, I) {
        var g = [], T = 0, C = m.length;
        if (C <= I)
          return String.fromCharCode.apply(null, m);
        for (; T < C; )
          E === "array" || E === "nodebuffer" ? g.push(String.fromCharCode.apply(null, m.slice(T, Math.min(T + I, C)))) : g.push(String.fromCharCode.apply(null, m.subarray(T, Math.min(T + I, C)))), T += I;
        return g.join("");
      }, stringifyByChar: function(m) {
        for (var E = "", I = 0; I < m.length; I++)
          E += String.fromCharCode(m[I]);
        return E;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return n.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return n.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function u(m) {
        var E = 65536, I = i.getTypeOf(m), g = !0;
        if (I === "uint8array" ? g = f.applyCanBeUsed.uint8array : I === "nodebuffer" && (g = f.applyCanBeUsed.nodebuffer), g)
          for (; 1 < E; )
            try {
              return f.stringifyByChunk(m, I, E);
            } catch {
              E = Math.floor(E / 2);
            }
        return f.stringifyByChar(m);
      }
      function d(m, E) {
        for (var I = 0; I < m.length; I++)
          E[I] = m[I];
        return E;
      }
      i.applyFromCharCode = u;
      var p = {};
      p.string = { string: c, array: function(m) {
        return h(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return p.string.uint8array(m).buffer;
      }, uint8array: function(m) {
        return h(m, new Uint8Array(m.length));
      }, nodebuffer: function(m) {
        return h(m, o.allocBuffer(m.length));
      } }, p.array = { string: u, array: c, arraybuffer: function(m) {
        return new Uint8Array(m).buffer;
      }, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return o.newBufferFrom(m);
      } }, p.arraybuffer = { string: function(m) {
        return u(new Uint8Array(m));
      }, array: function(m) {
        return d(new Uint8Array(m), new Array(m.byteLength));
      }, arraybuffer: c, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return o.newBufferFrom(new Uint8Array(m));
      } }, p.uint8array = { string: u, array: function(m) {
        return d(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return m.buffer;
      }, uint8array: c, nodebuffer: function(m) {
        return o.newBufferFrom(m);
      } }, p.nodebuffer = { string: u, array: function(m) {
        return d(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return p.nodebuffer.uint8array(m).buffer;
      }, uint8array: function(m) {
        return d(m, new Uint8Array(m.length));
      }, nodebuffer: c }, i.transformTo = function(m, E) {
        if (E = E || "", !m)
          return E;
        i.checkSupport(m);
        var I = i.getTypeOf(E);
        return p[I][m](E);
      }, i.resolve = function(m) {
        for (var E = m.split("/"), I = [], g = 0; g < E.length; g++) {
          var T = E[g];
          T === "." || T === "" && g !== 0 && g !== E.length - 1 || (T === ".." ? I.pop() : I.push(T));
        }
        return I.join("/");
      }, i.getTypeOf = function(m) {
        return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : n.nodebuffer && o.isBuffer(m) ? "nodebuffer" : n.uint8array && m instanceof Uint8Array ? "uint8array" : n.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(m) {
        if (!n[m.toLowerCase()])
          throw new Error(m + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(m) {
        var E, I, g = "";
        for (I = 0; I < (m || "").length; I++)
          g += "\\x" + ((E = m.charCodeAt(I)) < 16 ? "0" : "") + E.toString(16).toUpperCase();
        return g;
      }, i.delay = function(m, E, I) {
        setImmediate(function() {
          m.apply(I || null, E || []);
        });
      }, i.inherits = function(m, E) {
        function I() {
        }
        I.prototype = E.prototype, m.prototype = new I();
      }, i.extend = function() {
        var m, E, I = {};
        for (m = 0; m < arguments.length; m++)
          for (E in arguments[m])
            Object.prototype.hasOwnProperty.call(arguments[m], E) && I[E] === void 0 && (I[E] = arguments[m][E]);
        return I;
      }, i.prepareContent = function(m, E, I, g, T) {
        return a.Promise.resolve(E).then(function(C) {
          return n.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new a.Promise(function(F, O) {
            var P = new FileReader();
            P.onload = function(M) {
              F(M.target.result);
            }, P.onerror = function(M) {
              O(M.target.error);
            }, P.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var F = i.getTypeOf(C);
          return F ? (F === "arraybuffer" ? C = i.transformTo("uint8array", C) : F === "string" && (T ? C = r.decode(C) : I && g !== !0 && (C = function(O) {
            return h(O, n.uint8array ? new Uint8Array(O.length) : new Array(O.length));
          }(C))), C) : a.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, s, i) {
      var n = e("./reader/readerFor"), r = e("./utils"), o = e("./signature"), a = e("./zipEntry"), c = e("./support");
      function h(f) {
        this.files = [], this.loadOptions = f;
      }
      h.prototype = { checkSignature: function(f) {
        if (!this.reader.readAndCheckSignature(f)) {
          this.reader.index -= 4;
          var u = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + r.pretty(u) + ", expected " + r.pretty(f) + ")");
        }
      }, isSignature: function(f, u) {
        var d = this.reader.index;
        this.reader.setIndex(f);
        var p = this.reader.readString(4) === u;
        return this.reader.setIndex(d), p;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var f = this.reader.readData(this.zipCommentLength), u = c.uint8array ? "uint8array" : "array", d = r.transformTo(u, f);
        this.zipComment = this.loadOptions.decodeFileName(d);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var f, u, d, p = this.zip64EndOfCentralSize - 44; 0 < p; )
          f = this.reader.readInt(2), u = this.reader.readInt(4), d = this.reader.readData(u), this.zip64ExtensibleData[f] = { id: f, length: u, value: d };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var f, u;
        for (f = 0; f < this.files.length; f++)
          u = this.files[f], this.reader.setIndex(u.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), u.readLocalPart(this.reader), u.handleUTF8(), u.processAttributes();
      }, readCentralDir: function() {
        var f;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); )
          (f = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(f);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var f = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
        if (f < 0)
          throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(f);
        var u = f;
        if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === r.MAX_VALUE_16BITS || this.diskWithCentralDirStart === r.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === r.MAX_VALUE_16BITS || this.centralDirRecords === r.MAX_VALUE_16BITS || this.centralDirSize === r.MAX_VALUE_32BITS || this.centralDirOffset === r.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (f = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(f), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var d = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (d += 20, d += 12 + this.zip64EndOfCentralSize);
        var p = u - d;
        if (0 < p)
          this.isSignature(u, o.CENTRAL_FILE_HEADER) || (this.reader.zero = p);
        else if (p < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(p) + " bytes.");
      }, prepareReader: function(f) {
        this.reader = n(f);
      }, load: function(f) {
        this.prepareReader(f), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, s.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, s, i) {
      var n = e("./reader/readerFor"), r = e("./utils"), o = e("./compressedObject"), a = e("./crc32"), c = e("./utf8"), h = e("./compressions"), f = e("./support");
      function u(d, p) {
        this.options = d, this.loadOptions = p;
      }
      u.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(d) {
        var p, m;
        if (d.skip(22), this.fileNameLength = d.readInt(2), m = d.readInt(2), this.fileName = d.readData(this.fileNameLength), d.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((p = function(E) {
          for (var I in h)
            if (Object.prototype.hasOwnProperty.call(h, I) && h[I].magic === E)
              return h[I];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + r.pretty(this.compressionMethod) + " unknown (inner file : " + r.transformTo("string", this.fileName) + ")");
        this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, p, d.readData(this.compressedSize));
      }, readCentralPart: function(d) {
        this.versionMadeBy = d.readInt(2), d.skip(2), this.bitFlag = d.readInt(2), this.compressionMethod = d.readString(2), this.date = d.readDate(), this.crc32 = d.readInt(4), this.compressedSize = d.readInt(4), this.uncompressedSize = d.readInt(4);
        var p = d.readInt(2);
        if (this.extraFieldsLength = d.readInt(2), this.fileCommentLength = d.readInt(2), this.diskNumberStart = d.readInt(2), this.internalFileAttributes = d.readInt(2), this.externalFileAttributes = d.readInt(4), this.localHeaderOffset = d.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        d.skip(p), this.readExtraFields(d), this.parseZIP64ExtraField(d), this.fileComment = d.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var d = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), d == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), d == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var d = n(this.extraFields[1].value);
          this.uncompressedSize === r.MAX_VALUE_32BITS && (this.uncompressedSize = d.readInt(8)), this.compressedSize === r.MAX_VALUE_32BITS && (this.compressedSize = d.readInt(8)), this.localHeaderOffset === r.MAX_VALUE_32BITS && (this.localHeaderOffset = d.readInt(8)), this.diskNumberStart === r.MAX_VALUE_32BITS && (this.diskNumberStart = d.readInt(4));
        }
      }, readExtraFields: function(d) {
        var p, m, E, I = d.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); d.index + 4 < I; )
          p = d.readInt(2), m = d.readInt(2), E = d.readData(m), this.extraFields[p] = { id: p, length: m, value: E };
        d.setIndex(I);
      }, handleUTF8: function() {
        var d = f.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var p = this.findExtraFieldUnicodePath();
          if (p !== null)
            this.fileNameStr = p;
          else {
            var m = r.transformTo(d, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(m);
          }
          var E = this.findExtraFieldUnicodeComment();
          if (E !== null)
            this.fileCommentStr = E;
          else {
            var I = r.transformTo(d, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(I);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var d = this.extraFields[28789];
        if (d) {
          var p = n(d.value);
          return p.readInt(1) !== 1 || a(this.fileName) !== p.readInt(4) ? null : c.utf8decode(p.readData(d.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var d = this.extraFields[25461];
        if (d) {
          var p = n(d.value);
          return p.readInt(1) !== 1 || a(this.fileComment) !== p.readInt(4) ? null : c.utf8decode(p.readData(d.length - 5));
        }
        return null;
      } }, s.exports = u;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, s, i) {
      function n(p, m, E) {
        this.name = p, this.dir = E.dir, this.date = E.date, this.comment = E.comment, this.unixPermissions = E.unixPermissions, this.dosPermissions = E.dosPermissions, this._data = m, this._dataBinary = E.binary, this.options = { compression: E.compression, compressionOptions: E.compressionOptions };
      }
      var r = e("./stream/StreamHelper"), o = e("./stream/DataWorker"), a = e("./utf8"), c = e("./compressedObject"), h = e("./stream/GenericWorker");
      n.prototype = { internalStream: function(p) {
        var m = null, E = "string";
        try {
          if (!p)
            throw new Error("No output type specified.");
          var I = (E = p.toLowerCase()) === "string" || E === "text";
          E !== "binarystring" && E !== "text" || (E = "string"), m = this._decompressWorker();
          var g = !this._dataBinary;
          g && !I && (m = m.pipe(new a.Utf8EncodeWorker())), !g && I && (m = m.pipe(new a.Utf8DecodeWorker()));
        } catch (T) {
          (m = new h("error")).error(T);
        }
        return new r(m, E, "");
      }, async: function(p, m) {
        return this.internalStream(p).accumulate(m);
      }, nodeStream: function(p, m) {
        return this.internalStream(p || "nodebuffer").toNodejsStream(m);
      }, _compressWorker: function(p, m) {
        if (this._data instanceof c && this._data.compression.magic === p.magic)
          return this._data.getCompressedWorker();
        var E = this._decompressWorker();
        return this._dataBinary || (E = E.pipe(new a.Utf8EncodeWorker())), c.createWorkerFrom(E, p, m);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof h ? this._data : new o(this._data);
      } };
      for (var f = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], u = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, d = 0; d < f.length; d++)
        n.prototype[f[d]] = u;
      s.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, s, i) {
      (function(n) {
        var r, o, a = n.MutationObserver || n.WebKitMutationObserver;
        if (a) {
          var c = 0, h = new a(p), f = n.document.createTextNode("");
          h.observe(f, { characterData: !0 }), r = function() {
            f.data = c = ++c % 2;
          };
        } else if (n.setImmediate || n.MessageChannel === void 0)
          r = "document" in n && "onreadystatechange" in n.document.createElement("script") ? function() {
            var m = n.document.createElement("script");
            m.onreadystatechange = function() {
              p(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
            }, n.document.documentElement.appendChild(m);
          } : function() {
            setTimeout(p, 0);
          };
        else {
          var u = new n.MessageChannel();
          u.port1.onmessage = p, r = function() {
            u.port2.postMessage(0);
          };
        }
        var d = [];
        function p() {
          var m, E;
          o = !0;
          for (var I = d.length; I; ) {
            for (E = d, d = [], m = -1; ++m < I; )
              E[m]();
            I = d.length;
          }
          o = !1;
        }
        s.exports = function(m) {
          d.push(m) !== 1 || o || r();
        };
      }).call(this, typeof Zi < "u" ? Zi : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, s, i) {
      var n = e("immediate");
      function r() {
      }
      var o = {}, a = ["REJECTED"], c = ["FULFILLED"], h = ["PENDING"];
      function f(I) {
        if (typeof I != "function")
          throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, I !== r && m(this, I);
      }
      function u(I, g, T) {
        this.promise = I, typeof g == "function" && (this.onFulfilled = g, this.callFulfilled = this.otherCallFulfilled), typeof T == "function" && (this.onRejected = T, this.callRejected = this.otherCallRejected);
      }
      function d(I, g, T) {
        n(function() {
          var C;
          try {
            C = g(T);
          } catch (F) {
            return o.reject(I, F);
          }
          C === I ? o.reject(I, new TypeError("Cannot resolve promise with itself")) : o.resolve(I, C);
        });
      }
      function p(I) {
        var g = I && I.then;
        if (I && (typeof I == "object" || typeof I == "function") && typeof g == "function")
          return function() {
            g.apply(I, arguments);
          };
      }
      function m(I, g) {
        var T = !1;
        function C(P) {
          T || (T = !0, o.reject(I, P));
        }
        function F(P) {
          T || (T = !0, o.resolve(I, P));
        }
        var O = E(function() {
          g(F, C);
        });
        O.status === "error" && C(O.value);
      }
      function E(I, g) {
        var T = {};
        try {
          T.value = I(g), T.status = "success";
        } catch (C) {
          T.status = "error", T.value = C;
        }
        return T;
      }
      (s.exports = f).prototype.finally = function(I) {
        if (typeof I != "function")
          return this;
        var g = this.constructor;
        return this.then(function(T) {
          return g.resolve(I()).then(function() {
            return T;
          });
        }, function(T) {
          return g.resolve(I()).then(function() {
            throw T;
          });
        });
      }, f.prototype.catch = function(I) {
        return this.then(null, I);
      }, f.prototype.then = function(I, g) {
        if (typeof I != "function" && this.state === c || typeof g != "function" && this.state === a)
          return this;
        var T = new this.constructor(r);
        return this.state !== h ? d(T, this.state === c ? I : g, this.outcome) : this.queue.push(new u(T, I, g)), T;
      }, u.prototype.callFulfilled = function(I) {
        o.resolve(this.promise, I);
      }, u.prototype.otherCallFulfilled = function(I) {
        d(this.promise, this.onFulfilled, I);
      }, u.prototype.callRejected = function(I) {
        o.reject(this.promise, I);
      }, u.prototype.otherCallRejected = function(I) {
        d(this.promise, this.onRejected, I);
      }, o.resolve = function(I, g) {
        var T = E(p, g);
        if (T.status === "error")
          return o.reject(I, T.value);
        var C = T.value;
        if (C)
          m(I, C);
        else {
          I.state = c, I.outcome = g;
          for (var F = -1, O = I.queue.length; ++F < O; )
            I.queue[F].callFulfilled(g);
        }
        return I;
      }, o.reject = function(I, g) {
        I.state = a, I.outcome = g;
        for (var T = -1, C = I.queue.length; ++T < C; )
          I.queue[T].callRejected(g);
        return I;
      }, f.resolve = function(I) {
        return I instanceof this ? I : o.resolve(new this(r), I);
      }, f.reject = function(I) {
        var g = new this(r);
        return o.reject(g, I);
      }, f.all = function(I) {
        var g = this;
        if (Object.prototype.toString.call(I) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var T = I.length, C = !1;
        if (!T)
          return this.resolve([]);
        for (var F = new Array(T), O = 0, P = -1, M = new this(r); ++P < T; )
          L(I[P], P);
        return M;
        function L(b, B) {
          g.resolve(b).then(function(v) {
            F[B] = v, ++O !== T || C || (C = !0, o.resolve(M, F));
          }, function(v) {
            C || (C = !0, o.reject(M, v));
          });
        }
      }, f.race = function(I) {
        var g = this;
        if (Object.prototype.toString.call(I) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var T = I.length, C = !1;
        if (!T)
          return this.resolve([]);
        for (var F = -1, O = new this(r); ++F < T; )
          P = I[F], g.resolve(P).then(function(M) {
            C || (C = !0, o.resolve(O, M));
          }, function(M) {
            C || (C = !0, o.reject(O, M));
          });
        var P;
        return O;
      };
    }, { immediate: 36 }], 38: [function(e, s, i) {
      var n = {};
      (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), s.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, s, i) {
      var n = e("./zlib/deflate"), r = e("./utils/common"), o = e("./utils/strings"), a = e("./zlib/messages"), c = e("./zlib/zstream"), h = Object.prototype.toString, f = 0, u = -1, d = 0, p = 8;
      function m(I) {
        if (!(this instanceof m))
          return new m(I);
        this.options = r.assign({ level: u, method: p, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, I || {});
        var g = this.options;
        g.raw && 0 < g.windowBits ? g.windowBits = -g.windowBits : g.gzip && 0 < g.windowBits && g.windowBits < 16 && (g.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var T = n.deflateInit2(this.strm, g.level, g.method, g.windowBits, g.memLevel, g.strategy);
        if (T !== f)
          throw new Error(a[T]);
        if (g.header && n.deflateSetHeader(this.strm, g.header), g.dictionary) {
          var C;
          if (C = typeof g.dictionary == "string" ? o.string2buf(g.dictionary) : h.call(g.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(g.dictionary) : g.dictionary, (T = n.deflateSetDictionary(this.strm, C)) !== f)
            throw new Error(a[T]);
          this._dict_set = !0;
        }
      }
      function E(I, g) {
        var T = new m(g);
        if (T.push(I, !0), T.err)
          throw T.msg || a[T.err];
        return T.result;
      }
      m.prototype.push = function(I, g) {
        var T, C, F = this.strm, O = this.options.chunkSize;
        if (this.ended)
          return !1;
        C = g === ~~g ? g : g === !0 ? 4 : 0, typeof I == "string" ? F.input = o.string2buf(I) : h.call(I) === "[object ArrayBuffer]" ? F.input = new Uint8Array(I) : F.input = I, F.next_in = 0, F.avail_in = F.input.length;
        do {
          if (F.avail_out === 0 && (F.output = new r.Buf8(O), F.next_out = 0, F.avail_out = O), (T = n.deflate(F, C)) !== 1 && T !== f)
            return this.onEnd(T), !(this.ended = !0);
          F.avail_out !== 0 && (F.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(r.shrinkBuf(F.output, F.next_out))) : this.onData(r.shrinkBuf(F.output, F.next_out)));
        } while ((0 < F.avail_in || F.avail_out === 0) && T !== 1);
        return C === 4 ? (T = n.deflateEnd(this.strm), this.onEnd(T), this.ended = !0, T === f) : C !== 2 || (this.onEnd(f), !(F.avail_out = 0));
      }, m.prototype.onData = function(I) {
        this.chunks.push(I);
      }, m.prototype.onEnd = function(I) {
        I === f && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = I, this.msg = this.strm.msg;
      }, i.Deflate = m, i.deflate = E, i.deflateRaw = function(I, g) {
        return (g = g || {}).raw = !0, E(I, g);
      }, i.gzip = function(I, g) {
        return (g = g || {}).gzip = !0, E(I, g);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, s, i) {
      var n = e("./zlib/inflate"), r = e("./utils/common"), o = e("./utils/strings"), a = e("./zlib/constants"), c = e("./zlib/messages"), h = e("./zlib/zstream"), f = e("./zlib/gzheader"), u = Object.prototype.toString;
      function d(m) {
        if (!(this instanceof d))
          return new d(m);
        this.options = r.assign({ chunkSize: 16384, windowBits: 0, to: "" }, m || {});
        var E = this.options;
        E.raw && 0 <= E.windowBits && E.windowBits < 16 && (E.windowBits = -E.windowBits, E.windowBits === 0 && (E.windowBits = -15)), !(0 <= E.windowBits && E.windowBits < 16) || m && m.windowBits || (E.windowBits += 32), 15 < E.windowBits && E.windowBits < 48 && !(15 & E.windowBits) && (E.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var I = n.inflateInit2(this.strm, E.windowBits);
        if (I !== a.Z_OK)
          throw new Error(c[I]);
        this.header = new f(), n.inflateGetHeader(this.strm, this.header);
      }
      function p(m, E) {
        var I = new d(E);
        if (I.push(m, !0), I.err)
          throw I.msg || c[I.err];
        return I.result;
      }
      d.prototype.push = function(m, E) {
        var I, g, T, C, F, O, P = this.strm, M = this.options.chunkSize, L = this.options.dictionary, b = !1;
        if (this.ended)
          return !1;
        g = E === ~~E ? E : E === !0 ? a.Z_FINISH : a.Z_NO_FLUSH, typeof m == "string" ? P.input = o.binstring2buf(m) : u.call(m) === "[object ArrayBuffer]" ? P.input = new Uint8Array(m) : P.input = m, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new r.Buf8(M), P.next_out = 0, P.avail_out = M), (I = n.inflate(P, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && L && (O = typeof L == "string" ? o.string2buf(L) : u.call(L) === "[object ArrayBuffer]" ? new Uint8Array(L) : L, I = n.inflateSetDictionary(this.strm, O)), I === a.Z_BUF_ERROR && b === !0 && (I = a.Z_OK, b = !1), I !== a.Z_STREAM_END && I !== a.Z_OK)
            return this.onEnd(I), !(this.ended = !0);
          P.next_out && (P.avail_out !== 0 && I !== a.Z_STREAM_END && (P.avail_in !== 0 || g !== a.Z_FINISH && g !== a.Z_SYNC_FLUSH) || (this.options.to === "string" ? (T = o.utf8border(P.output, P.next_out), C = P.next_out - T, F = o.buf2string(P.output, T), P.next_out = C, P.avail_out = M - C, C && r.arraySet(P.output, P.output, T, C, 0), this.onData(F)) : this.onData(r.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (b = !0);
        } while ((0 < P.avail_in || P.avail_out === 0) && I !== a.Z_STREAM_END);
        return I === a.Z_STREAM_END && (g = a.Z_FINISH), g === a.Z_FINISH ? (I = n.inflateEnd(this.strm), this.onEnd(I), this.ended = !0, I === a.Z_OK) : g !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), !(P.avail_out = 0));
      }, d.prototype.onData = function(m) {
        this.chunks.push(m);
      }, d.prototype.onEnd = function(m) {
        m === a.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, i.Inflate = d, i.inflate = p, i.inflateRaw = function(m, E) {
        return (E = E || {}).raw = !0, p(m, E);
      }, i.ungzip = p;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, s, i) {
      var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(a) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var h = c.shift();
          if (h) {
            if (typeof h != "object")
              throw new TypeError(h + "must be non-object");
            for (var f in h)
              h.hasOwnProperty(f) && (a[f] = h[f]);
          }
        }
        return a;
      }, i.shrinkBuf = function(a, c) {
        return a.length === c ? a : a.subarray ? a.subarray(0, c) : (a.length = c, a);
      };
      var r = { arraySet: function(a, c, h, f, u) {
        if (c.subarray && a.subarray)
          a.set(c.subarray(h, h + f), u);
        else
          for (var d = 0; d < f; d++)
            a[u + d] = c[h + d];
      }, flattenChunks: function(a) {
        var c, h, f, u, d, p;
        for (c = f = 0, h = a.length; c < h; c++)
          f += a[c].length;
        for (p = new Uint8Array(f), c = u = 0, h = a.length; c < h; c++)
          d = a[c], p.set(d, u), u += d.length;
        return p;
      } }, o = { arraySet: function(a, c, h, f, u) {
        for (var d = 0; d < f; d++)
          a[u + d] = c[h + d];
      }, flattenChunks: function(a) {
        return [].concat.apply([], a);
      } };
      i.setTyped = function(a) {
        a ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, r)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o));
      }, i.setTyped(n);
    }, {}], 42: [function(e, s, i) {
      var n = e("./common"), r = !0, o = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        r = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        o = !1;
      }
      for (var a = new n.Buf8(256), c = 0; c < 256; c++)
        a[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function h(f, u) {
        if (u < 65537 && (f.subarray && o || !f.subarray && r))
          return String.fromCharCode.apply(null, n.shrinkBuf(f, u));
        for (var d = "", p = 0; p < u; p++)
          d += String.fromCharCode(f[p]);
        return d;
      }
      a[254] = a[254] = 1, i.string2buf = function(f) {
        var u, d, p, m, E, I = f.length, g = 0;
        for (m = 0; m < I; m++)
          (64512 & (d = f.charCodeAt(m))) == 55296 && m + 1 < I && (64512 & (p = f.charCodeAt(m + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (p - 56320), m++), g += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4;
        for (u = new n.Buf8(g), m = E = 0; E < g; m++)
          (64512 & (d = f.charCodeAt(m))) == 55296 && m + 1 < I && (64512 & (p = f.charCodeAt(m + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (p - 56320), m++), d < 128 ? u[E++] = d : (d < 2048 ? u[E++] = 192 | d >>> 6 : (d < 65536 ? u[E++] = 224 | d >>> 12 : (u[E++] = 240 | d >>> 18, u[E++] = 128 | d >>> 12 & 63), u[E++] = 128 | d >>> 6 & 63), u[E++] = 128 | 63 & d);
        return u;
      }, i.buf2binstring = function(f) {
        return h(f, f.length);
      }, i.binstring2buf = function(f) {
        for (var u = new n.Buf8(f.length), d = 0, p = u.length; d < p; d++)
          u[d] = f.charCodeAt(d);
        return u;
      }, i.buf2string = function(f, u) {
        var d, p, m, E, I = u || f.length, g = new Array(2 * I);
        for (d = p = 0; d < I; )
          if ((m = f[d++]) < 128)
            g[p++] = m;
          else if (4 < (E = a[m]))
            g[p++] = 65533, d += E - 1;
          else {
            for (m &= E === 2 ? 31 : E === 3 ? 15 : 7; 1 < E && d < I; )
              m = m << 6 | 63 & f[d++], E--;
            1 < E ? g[p++] = 65533 : m < 65536 ? g[p++] = m : (m -= 65536, g[p++] = 55296 | m >> 10 & 1023, g[p++] = 56320 | 1023 & m);
          }
        return h(g, p);
      }, i.utf8border = function(f, u) {
        var d;
        for ((u = u || f.length) > f.length && (u = f.length), d = u - 1; 0 <= d && (192 & f[d]) == 128; )
          d--;
        return d < 0 || d === 0 ? u : d + a[f[d]] > u ? d : u;
      };
    }, { "./common": 41 }], 43: [function(e, s, i) {
      s.exports = function(n, r, o, a) {
        for (var c = 65535 & n | 0, h = n >>> 16 & 65535 | 0, f = 0; o !== 0; ) {
          for (o -= f = 2e3 < o ? 2e3 : o; h = h + (c = c + r[a++] | 0) | 0, --f; )
            ;
          c %= 65521, h %= 65521;
        }
        return c | h << 16 | 0;
      };
    }, {}], 44: [function(e, s, i) {
      s.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, s, i) {
      var n = function() {
        for (var r, o = [], a = 0; a < 256; a++) {
          r = a;
          for (var c = 0; c < 8; c++)
            r = 1 & r ? 3988292384 ^ r >>> 1 : r >>> 1;
          o[a] = r;
        }
        return o;
      }();
      s.exports = function(r, o, a, c) {
        var h = n, f = c + a;
        r ^= -1;
        for (var u = c; u < f; u++)
          r = r >>> 8 ^ h[255 & (r ^ o[u])];
        return -1 ^ r;
      };
    }, {}], 46: [function(e, s, i) {
      var n, r = e("../utils/common"), o = e("./trees"), a = e("./adler32"), c = e("./crc32"), h = e("./messages"), f = 0, u = 4, d = 0, p = -2, m = -1, E = 4, I = 2, g = 8, T = 9, C = 286, F = 30, O = 19, P = 2 * C + 1, M = 15, L = 3, b = 258, B = b + L + 1, v = 42, D = 113, R = 1, _ = 2, K = 3, U = 4;
      function Z(S, Q) {
        return S.msg = h[Q], Q;
      }
      function H(S) {
        return (S << 1) - (4 < S ? 9 : 0);
      }
      function J(S) {
        for (var Q = S.length; 0 <= --Q; )
          S[Q] = 0;
      }
      function z(S) {
        var Q = S.state, X = Q.pending;
        X > S.avail_out && (X = S.avail_out), X !== 0 && (r.arraySet(S.output, Q.pending_buf, Q.pending_out, X, S.next_out), S.next_out += X, Q.pending_out += X, S.total_out += X, S.avail_out -= X, Q.pending -= X, Q.pending === 0 && (Q.pending_out = 0));
      }
      function k(S, Q) {
        o._tr_flush_block(S, 0 <= S.block_start ? S.block_start : -1, S.strstart - S.block_start, Q), S.block_start = S.strstart, z(S.strm);
      }
      function ae(S, Q) {
        S.pending_buf[S.pending++] = Q;
      }
      function ne(S, Q) {
        S.pending_buf[S.pending++] = Q >>> 8 & 255, S.pending_buf[S.pending++] = 255 & Q;
      }
      function ie(S, Q) {
        var X, x, N = S.max_chain_length, V = S.strstart, $ = S.prev_length, ee = S.nice_match, G = S.strstart > S.w_size - B ? S.strstart - (S.w_size - B) : 0, te = S.window, re = S.w_mask, se = S.prev, ce = S.strstart + b, Re = te[V + $ - 1], Ie = te[V + $];
        S.prev_length >= S.good_match && (N >>= 2), ee > S.lookahead && (ee = S.lookahead);
        do
          if (te[(X = Q) + $] === Ie && te[X + $ - 1] === Re && te[X] === te[V] && te[++X] === te[V + 1]) {
            V += 2, X++;
            do
              ;
            while (te[++V] === te[++X] && te[++V] === te[++X] && te[++V] === te[++X] && te[++V] === te[++X] && te[++V] === te[++X] && te[++V] === te[++X] && te[++V] === te[++X] && te[++V] === te[++X] && V < ce);
            if (x = b - (ce - V), V = ce - b, $ < x) {
              if (S.match_start = Q, ee <= ($ = x))
                break;
              Re = te[V + $ - 1], Ie = te[V + $];
            }
          }
        while ((Q = se[Q & re]) > G && --N != 0);
        return $ <= S.lookahead ? $ : S.lookahead;
      }
      function Fe(S) {
        var Q, X, x, N, V, $, ee, G, te, re, se = S.w_size;
        do {
          if (N = S.window_size - S.lookahead - S.strstart, S.strstart >= se + (se - B)) {
            for (r.arraySet(S.window, S.window, se, se, 0), S.match_start -= se, S.strstart -= se, S.block_start -= se, Q = X = S.hash_size; x = S.head[--Q], S.head[Q] = se <= x ? x - se : 0, --X; )
              ;
            for (Q = X = se; x = S.prev[--Q], S.prev[Q] = se <= x ? x - se : 0, --X; )
              ;
            N += se;
          }
          if (S.strm.avail_in === 0)
            break;
          if ($ = S.strm, ee = S.window, G = S.strstart + S.lookahead, te = N, re = void 0, re = $.avail_in, te < re && (re = te), X = re === 0 ? 0 : ($.avail_in -= re, r.arraySet(ee, $.input, $.next_in, re, G), $.state.wrap === 1 ? $.adler = a($.adler, ee, re, G) : $.state.wrap === 2 && ($.adler = c($.adler, ee, re, G)), $.next_in += re, $.total_in += re, re), S.lookahead += X, S.lookahead + S.insert >= L)
            for (V = S.strstart - S.insert, S.ins_h = S.window[V], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[V + 1]) & S.hash_mask; S.insert && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[V + L - 1]) & S.hash_mask, S.prev[V & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = V, V++, S.insert--, !(S.lookahead + S.insert < L)); )
              ;
        } while (S.lookahead < B && S.strm.avail_in !== 0);
      }
      function Le(S, Q) {
        for (var X, x; ; ) {
          if (S.lookahead < B) {
            if (Fe(S), S.lookahead < B && Q === f)
              return R;
            if (S.lookahead === 0)
              break;
          }
          if (X = 0, S.lookahead >= L && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + L - 1]) & S.hash_mask, X = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), X !== 0 && S.strstart - X <= S.w_size - B && (S.match_length = ie(S, X)), S.match_length >= L)
            if (x = o._tr_tally(S, S.strstart - S.match_start, S.match_length - L), S.lookahead -= S.match_length, S.match_length <= S.max_lazy_match && S.lookahead >= L) {
              for (S.match_length--; S.strstart++, S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + L - 1]) & S.hash_mask, X = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart, --S.match_length != 0; )
                ;
              S.strstart++;
            } else
              S.strstart += S.match_length, S.match_length = 0, S.ins_h = S.window[S.strstart], S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + 1]) & S.hash_mask;
          else
            x = o._tr_tally(S, 0, S.window[S.strstart]), S.lookahead--, S.strstart++;
          if (x && (k(S, !1), S.strm.avail_out === 0))
            return R;
        }
        return S.insert = S.strstart < L - 1 ? S.strstart : L - 1, Q === u ? (k(S, !0), S.strm.avail_out === 0 ? K : U) : S.last_lit && (k(S, !1), S.strm.avail_out === 0) ? R : _;
      }
      function le(S, Q) {
        for (var X, x, N; ; ) {
          if (S.lookahead < B) {
            if (Fe(S), S.lookahead < B && Q === f)
              return R;
            if (S.lookahead === 0)
              break;
          }
          if (X = 0, S.lookahead >= L && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + L - 1]) & S.hash_mask, X = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), S.prev_length = S.match_length, S.prev_match = S.match_start, S.match_length = L - 1, X !== 0 && S.prev_length < S.max_lazy_match && S.strstart - X <= S.w_size - B && (S.match_length = ie(S, X), S.match_length <= 5 && (S.strategy === 1 || S.match_length === L && 4096 < S.strstart - S.match_start) && (S.match_length = L - 1)), S.prev_length >= L && S.match_length <= S.prev_length) {
            for (N = S.strstart + S.lookahead - L, x = o._tr_tally(S, S.strstart - 1 - S.prev_match, S.prev_length - L), S.lookahead -= S.prev_length - 1, S.prev_length -= 2; ++S.strstart <= N && (S.ins_h = (S.ins_h << S.hash_shift ^ S.window[S.strstart + L - 1]) & S.hash_mask, X = S.prev[S.strstart & S.w_mask] = S.head[S.ins_h], S.head[S.ins_h] = S.strstart), --S.prev_length != 0; )
              ;
            if (S.match_available = 0, S.match_length = L - 1, S.strstart++, x && (k(S, !1), S.strm.avail_out === 0))
              return R;
          } else if (S.match_available) {
            if ((x = o._tr_tally(S, 0, S.window[S.strstart - 1])) && k(S, !1), S.strstart++, S.lookahead--, S.strm.avail_out === 0)
              return R;
          } else
            S.match_available = 1, S.strstart++, S.lookahead--;
        }
        return S.match_available && (x = o._tr_tally(S, 0, S.window[S.strstart - 1]), S.match_available = 0), S.insert = S.strstart < L - 1 ? S.strstart : L - 1, Q === u ? (k(S, !0), S.strm.avail_out === 0 ? K : U) : S.last_lit && (k(S, !1), S.strm.avail_out === 0) ? R : _;
      }
      function me(S, Q, X, x, N) {
        this.good_length = S, this.max_lazy = Q, this.nice_length = X, this.max_chain = x, this.func = N;
      }
      function pe() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = g, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new r.Buf16(2 * P), this.dyn_dtree = new r.Buf16(2 * (2 * F + 1)), this.bl_tree = new r.Buf16(2 * (2 * O + 1)), J(this.dyn_ltree), J(this.dyn_dtree), J(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new r.Buf16(M + 1), this.heap = new r.Buf16(2 * C + 1), J(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new r.Buf16(2 * C + 1), J(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Te(S) {
        var Q;
        return S && S.state ? (S.total_in = S.total_out = 0, S.data_type = I, (Q = S.state).pending = 0, Q.pending_out = 0, Q.wrap < 0 && (Q.wrap = -Q.wrap), Q.status = Q.wrap ? v : D, S.adler = Q.wrap === 2 ? 0 : 1, Q.last_flush = f, o._tr_init(Q), d) : Z(S, p);
      }
      function tt(S) {
        var Q = Te(S);
        return Q === d && function(X) {
          X.window_size = 2 * X.w_size, J(X.head), X.max_lazy_match = n[X.level].max_lazy, X.good_match = n[X.level].good_length, X.nice_match = n[X.level].nice_length, X.max_chain_length = n[X.level].max_chain, X.strstart = 0, X.block_start = 0, X.lookahead = 0, X.insert = 0, X.match_length = X.prev_length = L - 1, X.match_available = 0, X.ins_h = 0;
        }(S.state), Q;
      }
      function Ge(S, Q, X, x, N, V) {
        if (!S)
          return p;
        var $ = 1;
        if (Q === m && (Q = 6), x < 0 ? ($ = 0, x = -x) : 15 < x && ($ = 2, x -= 16), N < 1 || T < N || X !== g || x < 8 || 15 < x || Q < 0 || 9 < Q || V < 0 || E < V)
          return Z(S, p);
        x === 8 && (x = 9);
        var ee = new pe();
        return (S.state = ee).strm = S, ee.wrap = $, ee.gzhead = null, ee.w_bits = x, ee.w_size = 1 << ee.w_bits, ee.w_mask = ee.w_size - 1, ee.hash_bits = N + 7, ee.hash_size = 1 << ee.hash_bits, ee.hash_mask = ee.hash_size - 1, ee.hash_shift = ~~((ee.hash_bits + L - 1) / L), ee.window = new r.Buf8(2 * ee.w_size), ee.head = new r.Buf16(ee.hash_size), ee.prev = new r.Buf16(ee.w_size), ee.lit_bufsize = 1 << N + 6, ee.pending_buf_size = 4 * ee.lit_bufsize, ee.pending_buf = new r.Buf8(ee.pending_buf_size), ee.d_buf = 1 * ee.lit_bufsize, ee.l_buf = 3 * ee.lit_bufsize, ee.level = Q, ee.strategy = V, ee.method = X, tt(S);
      }
      n = [new me(0, 0, 0, 0, function(S, Q) {
        var X = 65535;
        for (X > S.pending_buf_size - 5 && (X = S.pending_buf_size - 5); ; ) {
          if (S.lookahead <= 1) {
            if (Fe(S), S.lookahead === 0 && Q === f)
              return R;
            if (S.lookahead === 0)
              break;
          }
          S.strstart += S.lookahead, S.lookahead = 0;
          var x = S.block_start + X;
          if ((S.strstart === 0 || S.strstart >= x) && (S.lookahead = S.strstart - x, S.strstart = x, k(S, !1), S.strm.avail_out === 0) || S.strstart - S.block_start >= S.w_size - B && (k(S, !1), S.strm.avail_out === 0))
            return R;
        }
        return S.insert = 0, Q === u ? (k(S, !0), S.strm.avail_out === 0 ? K : U) : (S.strstart > S.block_start && (k(S, !1), S.strm.avail_out), R);
      }), new me(4, 4, 8, 4, Le), new me(4, 5, 16, 8, Le), new me(4, 6, 32, 32, Le), new me(4, 4, 16, 16, le), new me(8, 16, 32, 32, le), new me(8, 16, 128, 128, le), new me(8, 32, 128, 256, le), new me(32, 128, 258, 1024, le), new me(32, 258, 258, 4096, le)], i.deflateInit = function(S, Q) {
        return Ge(S, Q, g, 15, 8, 0);
      }, i.deflateInit2 = Ge, i.deflateReset = tt, i.deflateResetKeep = Te, i.deflateSetHeader = function(S, Q) {
        return S && S.state ? S.state.wrap !== 2 ? p : (S.state.gzhead = Q, d) : p;
      }, i.deflate = function(S, Q) {
        var X, x, N, V;
        if (!S || !S.state || 5 < Q || Q < 0)
          return S ? Z(S, p) : p;
        if (x = S.state, !S.output || !S.input && S.avail_in !== 0 || x.status === 666 && Q !== u)
          return Z(S, S.avail_out === 0 ? -5 : p);
        if (x.strm = S, X = x.last_flush, x.last_flush = Q, x.status === v)
          if (x.wrap === 2)
            S.adler = 0, ae(x, 31), ae(x, 139), ae(x, 8), x.gzhead ? (ae(x, (x.gzhead.text ? 1 : 0) + (x.gzhead.hcrc ? 2 : 0) + (x.gzhead.extra ? 4 : 0) + (x.gzhead.name ? 8 : 0) + (x.gzhead.comment ? 16 : 0)), ae(x, 255 & x.gzhead.time), ae(x, x.gzhead.time >> 8 & 255), ae(x, x.gzhead.time >> 16 & 255), ae(x, x.gzhead.time >> 24 & 255), ae(x, x.level === 9 ? 2 : 2 <= x.strategy || x.level < 2 ? 4 : 0), ae(x, 255 & x.gzhead.os), x.gzhead.extra && x.gzhead.extra.length && (ae(x, 255 & x.gzhead.extra.length), ae(x, x.gzhead.extra.length >> 8 & 255)), x.gzhead.hcrc && (S.adler = c(S.adler, x.pending_buf, x.pending, 0)), x.gzindex = 0, x.status = 69) : (ae(x, 0), ae(x, 0), ae(x, 0), ae(x, 0), ae(x, 0), ae(x, x.level === 9 ? 2 : 2 <= x.strategy || x.level < 2 ? 4 : 0), ae(x, 3), x.status = D);
          else {
            var $ = g + (x.w_bits - 8 << 4) << 8;
            $ |= (2 <= x.strategy || x.level < 2 ? 0 : x.level < 6 ? 1 : x.level === 6 ? 2 : 3) << 6, x.strstart !== 0 && ($ |= 32), $ += 31 - $ % 31, x.status = D, ne(x, $), x.strstart !== 0 && (ne(x, S.adler >>> 16), ne(x, 65535 & S.adler)), S.adler = 1;
          }
        if (x.status === 69)
          if (x.gzhead.extra) {
            for (N = x.pending; x.gzindex < (65535 & x.gzhead.extra.length) && (x.pending !== x.pending_buf_size || (x.gzhead.hcrc && x.pending > N && (S.adler = c(S.adler, x.pending_buf, x.pending - N, N)), z(S), N = x.pending, x.pending !== x.pending_buf_size)); )
              ae(x, 255 & x.gzhead.extra[x.gzindex]), x.gzindex++;
            x.gzhead.hcrc && x.pending > N && (S.adler = c(S.adler, x.pending_buf, x.pending - N, N)), x.gzindex === x.gzhead.extra.length && (x.gzindex = 0, x.status = 73);
          } else
            x.status = 73;
        if (x.status === 73)
          if (x.gzhead.name) {
            N = x.pending;
            do {
              if (x.pending === x.pending_buf_size && (x.gzhead.hcrc && x.pending > N && (S.adler = c(S.adler, x.pending_buf, x.pending - N, N)), z(S), N = x.pending, x.pending === x.pending_buf_size)) {
                V = 1;
                break;
              }
              V = x.gzindex < x.gzhead.name.length ? 255 & x.gzhead.name.charCodeAt(x.gzindex++) : 0, ae(x, V);
            } while (V !== 0);
            x.gzhead.hcrc && x.pending > N && (S.adler = c(S.adler, x.pending_buf, x.pending - N, N)), V === 0 && (x.gzindex = 0, x.status = 91);
          } else
            x.status = 91;
        if (x.status === 91)
          if (x.gzhead.comment) {
            N = x.pending;
            do {
              if (x.pending === x.pending_buf_size && (x.gzhead.hcrc && x.pending > N && (S.adler = c(S.adler, x.pending_buf, x.pending - N, N)), z(S), N = x.pending, x.pending === x.pending_buf_size)) {
                V = 1;
                break;
              }
              V = x.gzindex < x.gzhead.comment.length ? 255 & x.gzhead.comment.charCodeAt(x.gzindex++) : 0, ae(x, V);
            } while (V !== 0);
            x.gzhead.hcrc && x.pending > N && (S.adler = c(S.adler, x.pending_buf, x.pending - N, N)), V === 0 && (x.status = 103);
          } else
            x.status = 103;
        if (x.status === 103 && (x.gzhead.hcrc ? (x.pending + 2 > x.pending_buf_size && z(S), x.pending + 2 <= x.pending_buf_size && (ae(x, 255 & S.adler), ae(x, S.adler >> 8 & 255), S.adler = 0, x.status = D)) : x.status = D), x.pending !== 0) {
          if (z(S), S.avail_out === 0)
            return x.last_flush = -1, d;
        } else if (S.avail_in === 0 && H(Q) <= H(X) && Q !== u)
          return Z(S, -5);
        if (x.status === 666 && S.avail_in !== 0)
          return Z(S, -5);
        if (S.avail_in !== 0 || x.lookahead !== 0 || Q !== f && x.status !== 666) {
          var ee = x.strategy === 2 ? function(G, te) {
            for (var re; ; ) {
              if (G.lookahead === 0 && (Fe(G), G.lookahead === 0)) {
                if (te === f)
                  return R;
                break;
              }
              if (G.match_length = 0, re = o._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++, re && (k(G, !1), G.strm.avail_out === 0))
                return R;
            }
            return G.insert = 0, te === u ? (k(G, !0), G.strm.avail_out === 0 ? K : U) : G.last_lit && (k(G, !1), G.strm.avail_out === 0) ? R : _;
          }(x, Q) : x.strategy === 3 ? function(G, te) {
            for (var re, se, ce, Re, Ie = G.window; ; ) {
              if (G.lookahead <= b) {
                if (Fe(G), G.lookahead <= b && te === f)
                  return R;
                if (G.lookahead === 0)
                  break;
              }
              if (G.match_length = 0, G.lookahead >= L && 0 < G.strstart && (se = Ie[ce = G.strstart - 1]) === Ie[++ce] && se === Ie[++ce] && se === Ie[++ce]) {
                Re = G.strstart + b;
                do
                  ;
                while (se === Ie[++ce] && se === Ie[++ce] && se === Ie[++ce] && se === Ie[++ce] && se === Ie[++ce] && se === Ie[++ce] && se === Ie[++ce] && se === Ie[++ce] && ce < Re);
                G.match_length = b - (Re - ce), G.match_length > G.lookahead && (G.match_length = G.lookahead);
              }
              if (G.match_length >= L ? (re = o._tr_tally(G, 1, G.match_length - L), G.lookahead -= G.match_length, G.strstart += G.match_length, G.match_length = 0) : (re = o._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++), re && (k(G, !1), G.strm.avail_out === 0))
                return R;
            }
            return G.insert = 0, te === u ? (k(G, !0), G.strm.avail_out === 0 ? K : U) : G.last_lit && (k(G, !1), G.strm.avail_out === 0) ? R : _;
          }(x, Q) : n[x.level].func(x, Q);
          if (ee !== K && ee !== U || (x.status = 666), ee === R || ee === K)
            return S.avail_out === 0 && (x.last_flush = -1), d;
          if (ee === _ && (Q === 1 ? o._tr_align(x) : Q !== 5 && (o._tr_stored_block(x, 0, 0, !1), Q === 3 && (J(x.head), x.lookahead === 0 && (x.strstart = 0, x.block_start = 0, x.insert = 0))), z(S), S.avail_out === 0))
            return x.last_flush = -1, d;
        }
        return Q !== u ? d : x.wrap <= 0 ? 1 : (x.wrap === 2 ? (ae(x, 255 & S.adler), ae(x, S.adler >> 8 & 255), ae(x, S.adler >> 16 & 255), ae(x, S.adler >> 24 & 255), ae(x, 255 & S.total_in), ae(x, S.total_in >> 8 & 255), ae(x, S.total_in >> 16 & 255), ae(x, S.total_in >> 24 & 255)) : (ne(x, S.adler >>> 16), ne(x, 65535 & S.adler)), z(S), 0 < x.wrap && (x.wrap = -x.wrap), x.pending !== 0 ? d : 1);
      }, i.deflateEnd = function(S) {
        var Q;
        return S && S.state ? (Q = S.state.status) !== v && Q !== 69 && Q !== 73 && Q !== 91 && Q !== 103 && Q !== D && Q !== 666 ? Z(S, p) : (S.state = null, Q === D ? Z(S, -3) : d) : p;
      }, i.deflateSetDictionary = function(S, Q) {
        var X, x, N, V, $, ee, G, te, re = Q.length;
        if (!S || !S.state || (V = (X = S.state).wrap) === 2 || V === 1 && X.status !== v || X.lookahead)
          return p;
        for (V === 1 && (S.adler = a(S.adler, Q, re, 0)), X.wrap = 0, re >= X.w_size && (V === 0 && (J(X.head), X.strstart = 0, X.block_start = 0, X.insert = 0), te = new r.Buf8(X.w_size), r.arraySet(te, Q, re - X.w_size, X.w_size, 0), Q = te, re = X.w_size), $ = S.avail_in, ee = S.next_in, G = S.input, S.avail_in = re, S.next_in = 0, S.input = Q, Fe(X); X.lookahead >= L; ) {
          for (x = X.strstart, N = X.lookahead - (L - 1); X.ins_h = (X.ins_h << X.hash_shift ^ X.window[x + L - 1]) & X.hash_mask, X.prev[x & X.w_mask] = X.head[X.ins_h], X.head[X.ins_h] = x, x++, --N; )
            ;
          X.strstart = x, X.lookahead = L - 1, Fe(X);
        }
        return X.strstart += X.lookahead, X.block_start = X.strstart, X.insert = X.lookahead, X.lookahead = 0, X.match_length = X.prev_length = L - 1, X.match_available = 0, S.next_in = ee, S.input = G, S.avail_in = $, X.wrap = V, d;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, s, i) {
      s.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, s, i) {
      s.exports = function(n, r) {
        var o, a, c, h, f, u, d, p, m, E, I, g, T, C, F, O, P, M, L, b, B, v, D, R, _;
        o = n.state, a = n.next_in, R = n.input, c = a + (n.avail_in - 5), h = n.next_out, _ = n.output, f = h - (r - n.avail_out), u = h + (n.avail_out - 257), d = o.dmax, p = o.wsize, m = o.whave, E = o.wnext, I = o.window, g = o.hold, T = o.bits, C = o.lencode, F = o.distcode, O = (1 << o.lenbits) - 1, P = (1 << o.distbits) - 1;
        e:
          do {
            T < 15 && (g += R[a++] << T, T += 8, g += R[a++] << T, T += 8), M = C[g & O];
            t:
              for (; ; ) {
                if (g >>>= L = M >>> 24, T -= L, (L = M >>> 16 & 255) === 0)
                  _[h++] = 65535 & M;
                else {
                  if (!(16 & L)) {
                    if (!(64 & L)) {
                      M = C[(65535 & M) + (g & (1 << L) - 1)];
                      continue t;
                    }
                    if (32 & L) {
                      o.mode = 12;
                      break e;
                    }
                    n.msg = "invalid literal/length code", o.mode = 30;
                    break e;
                  }
                  b = 65535 & M, (L &= 15) && (T < L && (g += R[a++] << T, T += 8), b += g & (1 << L) - 1, g >>>= L, T -= L), T < 15 && (g += R[a++] << T, T += 8, g += R[a++] << T, T += 8), M = F[g & P];
                  s:
                    for (; ; ) {
                      if (g >>>= L = M >>> 24, T -= L, !(16 & (L = M >>> 16 & 255))) {
                        if (!(64 & L)) {
                          M = F[(65535 & M) + (g & (1 << L) - 1)];
                          continue s;
                        }
                        n.msg = "invalid distance code", o.mode = 30;
                        break e;
                      }
                      if (B = 65535 & M, T < (L &= 15) && (g += R[a++] << T, (T += 8) < L && (g += R[a++] << T, T += 8)), d < (B += g & (1 << L) - 1)) {
                        n.msg = "invalid distance too far back", o.mode = 30;
                        break e;
                      }
                      if (g >>>= L, T -= L, (L = h - f) < B) {
                        if (m < (L = B - L) && o.sane) {
                          n.msg = "invalid distance too far back", o.mode = 30;
                          break e;
                        }
                        if (D = I, (v = 0) === E) {
                          if (v += p - L, L < b) {
                            for (b -= L; _[h++] = I[v++], --L; )
                              ;
                            v = h - B, D = _;
                          }
                        } else if (E < L) {
                          if (v += p + E - L, (L -= E) < b) {
                            for (b -= L; _[h++] = I[v++], --L; )
                              ;
                            if (v = 0, E < b) {
                              for (b -= L = E; _[h++] = I[v++], --L; )
                                ;
                              v = h - B, D = _;
                            }
                          }
                        } else if (v += E - L, L < b) {
                          for (b -= L; _[h++] = I[v++], --L; )
                            ;
                          v = h - B, D = _;
                        }
                        for (; 2 < b; )
                          _[h++] = D[v++], _[h++] = D[v++], _[h++] = D[v++], b -= 3;
                        b && (_[h++] = D[v++], 1 < b && (_[h++] = D[v++]));
                      } else {
                        for (v = h - B; _[h++] = _[v++], _[h++] = _[v++], _[h++] = _[v++], 2 < (b -= 3); )
                          ;
                        b && (_[h++] = _[v++], 1 < b && (_[h++] = _[v++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (a < c && h < u);
        a -= b = T >> 3, g &= (1 << (T -= b << 3)) - 1, n.next_in = a, n.next_out = h, n.avail_in = a < c ? c - a + 5 : 5 - (a - c), n.avail_out = h < u ? u - h + 257 : 257 - (h - u), o.hold = g, o.bits = T;
      };
    }, {}], 49: [function(e, s, i) {
      var n = e("../utils/common"), r = e("./adler32"), o = e("./crc32"), a = e("./inffast"), c = e("./inftrees"), h = 1, f = 2, u = 0, d = -2, p = 1, m = 852, E = 592;
      function I(v) {
        return (v >>> 24 & 255) + (v >>> 8 & 65280) + ((65280 & v) << 8) + ((255 & v) << 24);
      }
      function g() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function T(v) {
        var D;
        return v && v.state ? (D = v.state, v.total_in = v.total_out = D.total = 0, v.msg = "", D.wrap && (v.adler = 1 & D.wrap), D.mode = p, D.last = 0, D.havedict = 0, D.dmax = 32768, D.head = null, D.hold = 0, D.bits = 0, D.lencode = D.lendyn = new n.Buf32(m), D.distcode = D.distdyn = new n.Buf32(E), D.sane = 1, D.back = -1, u) : d;
      }
      function C(v) {
        var D;
        return v && v.state ? ((D = v.state).wsize = 0, D.whave = 0, D.wnext = 0, T(v)) : d;
      }
      function F(v, D) {
        var R, _;
        return v && v.state ? (_ = v.state, D < 0 ? (R = 0, D = -D) : (R = 1 + (D >> 4), D < 48 && (D &= 15)), D && (D < 8 || 15 < D) ? d : (_.window !== null && _.wbits !== D && (_.window = null), _.wrap = R, _.wbits = D, C(v))) : d;
      }
      function O(v, D) {
        var R, _;
        return v ? (_ = new g(), (v.state = _).window = null, (R = F(v, D)) !== u && (v.state = null), R) : d;
      }
      var P, M, L = !0;
      function b(v) {
        if (L) {
          var D;
          for (P = new n.Buf32(512), M = new n.Buf32(32), D = 0; D < 144; )
            v.lens[D++] = 8;
          for (; D < 256; )
            v.lens[D++] = 9;
          for (; D < 280; )
            v.lens[D++] = 7;
          for (; D < 288; )
            v.lens[D++] = 8;
          for (c(h, v.lens, 0, 288, P, 0, v.work, { bits: 9 }), D = 0; D < 32; )
            v.lens[D++] = 5;
          c(f, v.lens, 0, 32, M, 0, v.work, { bits: 5 }), L = !1;
        }
        v.lencode = P, v.lenbits = 9, v.distcode = M, v.distbits = 5;
      }
      function B(v, D, R, _) {
        var K, U = v.state;
        return U.window === null && (U.wsize = 1 << U.wbits, U.wnext = 0, U.whave = 0, U.window = new n.Buf8(U.wsize)), _ >= U.wsize ? (n.arraySet(U.window, D, R - U.wsize, U.wsize, 0), U.wnext = 0, U.whave = U.wsize) : (_ < (K = U.wsize - U.wnext) && (K = _), n.arraySet(U.window, D, R - _, K, U.wnext), (_ -= K) ? (n.arraySet(U.window, D, R - _, _, 0), U.wnext = _, U.whave = U.wsize) : (U.wnext += K, U.wnext === U.wsize && (U.wnext = 0), U.whave < U.wsize && (U.whave += K))), 0;
      }
      i.inflateReset = C, i.inflateReset2 = F, i.inflateResetKeep = T, i.inflateInit = function(v) {
        return O(v, 15);
      }, i.inflateInit2 = O, i.inflate = function(v, D) {
        var R, _, K, U, Z, H, J, z, k, ae, ne, ie, Fe, Le, le, me, pe, Te, tt, Ge, S, Q, X, x, N = 0, V = new n.Buf8(4), $ = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!v || !v.state || !v.output || !v.input && v.avail_in !== 0)
          return d;
        (R = v.state).mode === 12 && (R.mode = 13), Z = v.next_out, K = v.output, J = v.avail_out, U = v.next_in, _ = v.input, H = v.avail_in, z = R.hold, k = R.bits, ae = H, ne = J, Q = u;
        e:
          for (; ; )
            switch (R.mode) {
              case p:
                if (R.wrap === 0) {
                  R.mode = 13;
                  break;
                }
                for (; k < 16; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                if (2 & R.wrap && z === 35615) {
                  V[R.check = 0] = 255 & z, V[1] = z >>> 8 & 255, R.check = o(R.check, V, 2, 0), k = z = 0, R.mode = 2;
                  break;
                }
                if (R.flags = 0, R.head && (R.head.done = !1), !(1 & R.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
                  v.msg = "incorrect header check", R.mode = 30;
                  break;
                }
                if ((15 & z) != 8) {
                  v.msg = "unknown compression method", R.mode = 30;
                  break;
                }
                if (k -= 4, S = 8 + (15 & (z >>>= 4)), R.wbits === 0)
                  R.wbits = S;
                else if (S > R.wbits) {
                  v.msg = "invalid window size", R.mode = 30;
                  break;
                }
                R.dmax = 1 << S, v.adler = R.check = 1, R.mode = 512 & z ? 10 : 12, k = z = 0;
                break;
              case 2:
                for (; k < 16; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                if (R.flags = z, (255 & R.flags) != 8) {
                  v.msg = "unknown compression method", R.mode = 30;
                  break;
                }
                if (57344 & R.flags) {
                  v.msg = "unknown header flags set", R.mode = 30;
                  break;
                }
                R.head && (R.head.text = z >> 8 & 1), 512 & R.flags && (V[0] = 255 & z, V[1] = z >>> 8 & 255, R.check = o(R.check, V, 2, 0)), k = z = 0, R.mode = 3;
              case 3:
                for (; k < 32; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                R.head && (R.head.time = z), 512 & R.flags && (V[0] = 255 & z, V[1] = z >>> 8 & 255, V[2] = z >>> 16 & 255, V[3] = z >>> 24 & 255, R.check = o(R.check, V, 4, 0)), k = z = 0, R.mode = 4;
              case 4:
                for (; k < 16; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                R.head && (R.head.xflags = 255 & z, R.head.os = z >> 8), 512 & R.flags && (V[0] = 255 & z, V[1] = z >>> 8 & 255, R.check = o(R.check, V, 2, 0)), k = z = 0, R.mode = 5;
              case 5:
                if (1024 & R.flags) {
                  for (; k < 16; ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  R.length = z, R.head && (R.head.extra_len = z), 512 & R.flags && (V[0] = 255 & z, V[1] = z >>> 8 & 255, R.check = o(R.check, V, 2, 0)), k = z = 0;
                } else
                  R.head && (R.head.extra = null);
                R.mode = 6;
              case 6:
                if (1024 & R.flags && (H < (ie = R.length) && (ie = H), ie && (R.head && (S = R.head.extra_len - R.length, R.head.extra || (R.head.extra = new Array(R.head.extra_len)), n.arraySet(R.head.extra, _, U, ie, S)), 512 & R.flags && (R.check = o(R.check, _, ie, U)), H -= ie, U += ie, R.length -= ie), R.length))
                  break e;
                R.length = 0, R.mode = 7;
              case 7:
                if (2048 & R.flags) {
                  if (H === 0)
                    break e;
                  for (ie = 0; S = _[U + ie++], R.head && S && R.length < 65536 && (R.head.name += String.fromCharCode(S)), S && ie < H; )
                    ;
                  if (512 & R.flags && (R.check = o(R.check, _, ie, U)), H -= ie, U += ie, S)
                    break e;
                } else
                  R.head && (R.head.name = null);
                R.length = 0, R.mode = 8;
              case 8:
                if (4096 & R.flags) {
                  if (H === 0)
                    break e;
                  for (ie = 0; S = _[U + ie++], R.head && S && R.length < 65536 && (R.head.comment += String.fromCharCode(S)), S && ie < H; )
                    ;
                  if (512 & R.flags && (R.check = o(R.check, _, ie, U)), H -= ie, U += ie, S)
                    break e;
                } else
                  R.head && (R.head.comment = null);
                R.mode = 9;
              case 9:
                if (512 & R.flags) {
                  for (; k < 16; ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  if (z !== (65535 & R.check)) {
                    v.msg = "header crc mismatch", R.mode = 30;
                    break;
                  }
                  k = z = 0;
                }
                R.head && (R.head.hcrc = R.flags >> 9 & 1, R.head.done = !0), v.adler = R.check = 0, R.mode = 12;
                break;
              case 10:
                for (; k < 32; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                v.adler = R.check = I(z), k = z = 0, R.mode = 11;
              case 11:
                if (R.havedict === 0)
                  return v.next_out = Z, v.avail_out = J, v.next_in = U, v.avail_in = H, R.hold = z, R.bits = k, 2;
                v.adler = R.check = 1, R.mode = 12;
              case 12:
                if (D === 5 || D === 6)
                  break e;
              case 13:
                if (R.last) {
                  z >>>= 7 & k, k -= 7 & k, R.mode = 27;
                  break;
                }
                for (; k < 3; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                switch (R.last = 1 & z, k -= 1, 3 & (z >>>= 1)) {
                  case 0:
                    R.mode = 14;
                    break;
                  case 1:
                    if (b(R), R.mode = 20, D !== 6)
                      break;
                    z >>>= 2, k -= 2;
                    break e;
                  case 2:
                    R.mode = 17;
                    break;
                  case 3:
                    v.msg = "invalid block type", R.mode = 30;
                }
                z >>>= 2, k -= 2;
                break;
              case 14:
                for (z >>>= 7 & k, k -= 7 & k; k < 32; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                if ((65535 & z) != (z >>> 16 ^ 65535)) {
                  v.msg = "invalid stored block lengths", R.mode = 30;
                  break;
                }
                if (R.length = 65535 & z, k = z = 0, R.mode = 15, D === 6)
                  break e;
              case 15:
                R.mode = 16;
              case 16:
                if (ie = R.length) {
                  if (H < ie && (ie = H), J < ie && (ie = J), ie === 0)
                    break e;
                  n.arraySet(K, _, U, ie, Z), H -= ie, U += ie, J -= ie, Z += ie, R.length -= ie;
                  break;
                }
                R.mode = 12;
                break;
              case 17:
                for (; k < 14; ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                if (R.nlen = 257 + (31 & z), z >>>= 5, k -= 5, R.ndist = 1 + (31 & z), z >>>= 5, k -= 5, R.ncode = 4 + (15 & z), z >>>= 4, k -= 4, 286 < R.nlen || 30 < R.ndist) {
                  v.msg = "too many length or distance symbols", R.mode = 30;
                  break;
                }
                R.have = 0, R.mode = 18;
              case 18:
                for (; R.have < R.ncode; ) {
                  for (; k < 3; ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  R.lens[$[R.have++]] = 7 & z, z >>>= 3, k -= 3;
                }
                for (; R.have < 19; )
                  R.lens[$[R.have++]] = 0;
                if (R.lencode = R.lendyn, R.lenbits = 7, X = { bits: R.lenbits }, Q = c(0, R.lens, 0, 19, R.lencode, 0, R.work, X), R.lenbits = X.bits, Q) {
                  v.msg = "invalid code lengths set", R.mode = 30;
                  break;
                }
                R.have = 0, R.mode = 19;
              case 19:
                for (; R.have < R.nlen + R.ndist; ) {
                  for (; me = (N = R.lencode[z & (1 << R.lenbits) - 1]) >>> 16 & 255, pe = 65535 & N, !((le = N >>> 24) <= k); ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  if (pe < 16)
                    z >>>= le, k -= le, R.lens[R.have++] = pe;
                  else {
                    if (pe === 16) {
                      for (x = le + 2; k < x; ) {
                        if (H === 0)
                          break e;
                        H--, z += _[U++] << k, k += 8;
                      }
                      if (z >>>= le, k -= le, R.have === 0) {
                        v.msg = "invalid bit length repeat", R.mode = 30;
                        break;
                      }
                      S = R.lens[R.have - 1], ie = 3 + (3 & z), z >>>= 2, k -= 2;
                    } else if (pe === 17) {
                      for (x = le + 3; k < x; ) {
                        if (H === 0)
                          break e;
                        H--, z += _[U++] << k, k += 8;
                      }
                      k -= le, S = 0, ie = 3 + (7 & (z >>>= le)), z >>>= 3, k -= 3;
                    } else {
                      for (x = le + 7; k < x; ) {
                        if (H === 0)
                          break e;
                        H--, z += _[U++] << k, k += 8;
                      }
                      k -= le, S = 0, ie = 11 + (127 & (z >>>= le)), z >>>= 7, k -= 7;
                    }
                    if (R.have + ie > R.nlen + R.ndist) {
                      v.msg = "invalid bit length repeat", R.mode = 30;
                      break;
                    }
                    for (; ie--; )
                      R.lens[R.have++] = S;
                  }
                }
                if (R.mode === 30)
                  break;
                if (R.lens[256] === 0) {
                  v.msg = "invalid code -- missing end-of-block", R.mode = 30;
                  break;
                }
                if (R.lenbits = 9, X = { bits: R.lenbits }, Q = c(h, R.lens, 0, R.nlen, R.lencode, 0, R.work, X), R.lenbits = X.bits, Q) {
                  v.msg = "invalid literal/lengths set", R.mode = 30;
                  break;
                }
                if (R.distbits = 6, R.distcode = R.distdyn, X = { bits: R.distbits }, Q = c(f, R.lens, R.nlen, R.ndist, R.distcode, 0, R.work, X), R.distbits = X.bits, Q) {
                  v.msg = "invalid distances set", R.mode = 30;
                  break;
                }
                if (R.mode = 20, D === 6)
                  break e;
              case 20:
                R.mode = 21;
              case 21:
                if (6 <= H && 258 <= J) {
                  v.next_out = Z, v.avail_out = J, v.next_in = U, v.avail_in = H, R.hold = z, R.bits = k, a(v, ne), Z = v.next_out, K = v.output, J = v.avail_out, U = v.next_in, _ = v.input, H = v.avail_in, z = R.hold, k = R.bits, R.mode === 12 && (R.back = -1);
                  break;
                }
                for (R.back = 0; me = (N = R.lencode[z & (1 << R.lenbits) - 1]) >>> 16 & 255, pe = 65535 & N, !((le = N >>> 24) <= k); ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                if (me && !(240 & me)) {
                  for (Te = le, tt = me, Ge = pe; me = (N = R.lencode[Ge + ((z & (1 << Te + tt) - 1) >> Te)]) >>> 16 & 255, pe = 65535 & N, !(Te + (le = N >>> 24) <= k); ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  z >>>= Te, k -= Te, R.back += Te;
                }
                if (z >>>= le, k -= le, R.back += le, R.length = pe, me === 0) {
                  R.mode = 26;
                  break;
                }
                if (32 & me) {
                  R.back = -1, R.mode = 12;
                  break;
                }
                if (64 & me) {
                  v.msg = "invalid literal/length code", R.mode = 30;
                  break;
                }
                R.extra = 15 & me, R.mode = 22;
              case 22:
                if (R.extra) {
                  for (x = R.extra; k < x; ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  R.length += z & (1 << R.extra) - 1, z >>>= R.extra, k -= R.extra, R.back += R.extra;
                }
                R.was = R.length, R.mode = 23;
              case 23:
                for (; me = (N = R.distcode[z & (1 << R.distbits) - 1]) >>> 16 & 255, pe = 65535 & N, !((le = N >>> 24) <= k); ) {
                  if (H === 0)
                    break e;
                  H--, z += _[U++] << k, k += 8;
                }
                if (!(240 & me)) {
                  for (Te = le, tt = me, Ge = pe; me = (N = R.distcode[Ge + ((z & (1 << Te + tt) - 1) >> Te)]) >>> 16 & 255, pe = 65535 & N, !(Te + (le = N >>> 24) <= k); ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  z >>>= Te, k -= Te, R.back += Te;
                }
                if (z >>>= le, k -= le, R.back += le, 64 & me) {
                  v.msg = "invalid distance code", R.mode = 30;
                  break;
                }
                R.offset = pe, R.extra = 15 & me, R.mode = 24;
              case 24:
                if (R.extra) {
                  for (x = R.extra; k < x; ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  R.offset += z & (1 << R.extra) - 1, z >>>= R.extra, k -= R.extra, R.back += R.extra;
                }
                if (R.offset > R.dmax) {
                  v.msg = "invalid distance too far back", R.mode = 30;
                  break;
                }
                R.mode = 25;
              case 25:
                if (J === 0)
                  break e;
                if (ie = ne - J, R.offset > ie) {
                  if ((ie = R.offset - ie) > R.whave && R.sane) {
                    v.msg = "invalid distance too far back", R.mode = 30;
                    break;
                  }
                  Fe = ie > R.wnext ? (ie -= R.wnext, R.wsize - ie) : R.wnext - ie, ie > R.length && (ie = R.length), Le = R.window;
                } else
                  Le = K, Fe = Z - R.offset, ie = R.length;
                for (J < ie && (ie = J), J -= ie, R.length -= ie; K[Z++] = Le[Fe++], --ie; )
                  ;
                R.length === 0 && (R.mode = 21);
                break;
              case 26:
                if (J === 0)
                  break e;
                K[Z++] = R.length, J--, R.mode = 21;
                break;
              case 27:
                if (R.wrap) {
                  for (; k < 32; ) {
                    if (H === 0)
                      break e;
                    H--, z |= _[U++] << k, k += 8;
                  }
                  if (ne -= J, v.total_out += ne, R.total += ne, ne && (v.adler = R.check = R.flags ? o(R.check, K, ne, Z - ne) : r(R.check, K, ne, Z - ne)), ne = J, (R.flags ? z : I(z)) !== R.check) {
                    v.msg = "incorrect data check", R.mode = 30;
                    break;
                  }
                  k = z = 0;
                }
                R.mode = 28;
              case 28:
                if (R.wrap && R.flags) {
                  for (; k < 32; ) {
                    if (H === 0)
                      break e;
                    H--, z += _[U++] << k, k += 8;
                  }
                  if (z !== (4294967295 & R.total)) {
                    v.msg = "incorrect length check", R.mode = 30;
                    break;
                  }
                  k = z = 0;
                }
                R.mode = 29;
              case 29:
                Q = 1;
                break e;
              case 30:
                Q = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return d;
            }
        return v.next_out = Z, v.avail_out = J, v.next_in = U, v.avail_in = H, R.hold = z, R.bits = k, (R.wsize || ne !== v.avail_out && R.mode < 30 && (R.mode < 27 || D !== 4)) && B(v, v.output, v.next_out, ne - v.avail_out) ? (R.mode = 31, -4) : (ae -= v.avail_in, ne -= v.avail_out, v.total_in += ae, v.total_out += ne, R.total += ne, R.wrap && ne && (v.adler = R.check = R.flags ? o(R.check, K, ne, v.next_out - ne) : r(R.check, K, ne, v.next_out - ne)), v.data_type = R.bits + (R.last ? 64 : 0) + (R.mode === 12 ? 128 : 0) + (R.mode === 20 || R.mode === 15 ? 256 : 0), (ae == 0 && ne === 0 || D === 4) && Q === u && (Q = -5), Q);
      }, i.inflateEnd = function(v) {
        if (!v || !v.state)
          return d;
        var D = v.state;
        return D.window && (D.window = null), v.state = null, u;
      }, i.inflateGetHeader = function(v, D) {
        var R;
        return v && v.state && 2 & (R = v.state).wrap ? ((R.head = D).done = !1, u) : d;
      }, i.inflateSetDictionary = function(v, D) {
        var R, _ = D.length;
        return v && v.state ? (R = v.state).wrap !== 0 && R.mode !== 11 ? d : R.mode === 11 && r(1, D, _, 0) !== R.check ? -3 : B(v, D, _, _) ? (R.mode = 31, -4) : (R.havedict = 1, u) : d;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, s, i) {
      var n = e("../utils/common"), r = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      s.exports = function(h, f, u, d, p, m, E, I) {
        var g, T, C, F, O, P, M, L, b, B = I.bits, v = 0, D = 0, R = 0, _ = 0, K = 0, U = 0, Z = 0, H = 0, J = 0, z = 0, k = null, ae = 0, ne = new n.Buf16(16), ie = new n.Buf16(16), Fe = null, Le = 0;
        for (v = 0; v <= 15; v++)
          ne[v] = 0;
        for (D = 0; D < d; D++)
          ne[f[u + D]]++;
        for (K = B, _ = 15; 1 <= _ && ne[_] === 0; _--)
          ;
        if (_ < K && (K = _), _ === 0)
          return p[m++] = 20971520, p[m++] = 20971520, I.bits = 1, 0;
        for (R = 1; R < _ && ne[R] === 0; R++)
          ;
        for (K < R && (K = R), v = H = 1; v <= 15; v++)
          if (H <<= 1, (H -= ne[v]) < 0)
            return -1;
        if (0 < H && (h === 0 || _ !== 1))
          return -1;
        for (ie[1] = 0, v = 1; v < 15; v++)
          ie[v + 1] = ie[v] + ne[v];
        for (D = 0; D < d; D++)
          f[u + D] !== 0 && (E[ie[f[u + D]]++] = D);
        if (P = h === 0 ? (k = Fe = E, 19) : h === 1 ? (k = r, ae -= 257, Fe = o, Le -= 257, 256) : (k = a, Fe = c, -1), v = R, O = m, Z = D = z = 0, C = -1, F = (J = 1 << (U = K)) - 1, h === 1 && 852 < J || h === 2 && 592 < J)
          return 1;
        for (; ; ) {
          for (M = v - Z, b = E[D] < P ? (L = 0, E[D]) : E[D] > P ? (L = Fe[Le + E[D]], k[ae + E[D]]) : (L = 96, 0), g = 1 << v - Z, R = T = 1 << U; p[O + (z >> Z) + (T -= g)] = M << 24 | L << 16 | b | 0, T !== 0; )
            ;
          for (g = 1 << v - 1; z & g; )
            g >>= 1;
          if (g !== 0 ? (z &= g - 1, z += g) : z = 0, D++, --ne[v] == 0) {
            if (v === _)
              break;
            v = f[u + E[D]];
          }
          if (K < v && (z & F) !== C) {
            for (Z === 0 && (Z = K), O += R, H = 1 << (U = v - Z); U + Z < _ && !((H -= ne[U + Z]) <= 0); )
              U++, H <<= 1;
            if (J += 1 << U, h === 1 && 852 < J || h === 2 && 592 < J)
              return 1;
            p[C = z & F] = K << 24 | U << 16 | O - m | 0;
          }
        }
        return z !== 0 && (p[O + z] = v - Z << 24 | 64 << 16 | 0), I.bits = K, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, s, i) {
      s.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, s, i) {
      var n = e("../utils/common"), r = 0, o = 1;
      function a(N) {
        for (var V = N.length; 0 <= --V; )
          N[V] = 0;
      }
      var c = 0, h = 29, f = 256, u = f + 1 + h, d = 30, p = 19, m = 2 * u + 1, E = 15, I = 16, g = 7, T = 256, C = 16, F = 17, O = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], L = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], b = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], B = new Array(2 * (u + 2));
      a(B);
      var v = new Array(2 * d);
      a(v);
      var D = new Array(512);
      a(D);
      var R = new Array(256);
      a(R);
      var _ = new Array(h);
      a(_);
      var K, U, Z, H = new Array(d);
      function J(N, V, $, ee, G) {
        this.static_tree = N, this.extra_bits = V, this.extra_base = $, this.elems = ee, this.max_length = G, this.has_stree = N && N.length;
      }
      function z(N, V) {
        this.dyn_tree = N, this.max_code = 0, this.stat_desc = V;
      }
      function k(N) {
        return N < 256 ? D[N] : D[256 + (N >>> 7)];
      }
      function ae(N, V) {
        N.pending_buf[N.pending++] = 255 & V, N.pending_buf[N.pending++] = V >>> 8 & 255;
      }
      function ne(N, V, $) {
        N.bi_valid > I - $ ? (N.bi_buf |= V << N.bi_valid & 65535, ae(N, N.bi_buf), N.bi_buf = V >> I - N.bi_valid, N.bi_valid += $ - I) : (N.bi_buf |= V << N.bi_valid & 65535, N.bi_valid += $);
      }
      function ie(N, V, $) {
        ne(N, $[2 * V], $[2 * V + 1]);
      }
      function Fe(N, V) {
        for (var $ = 0; $ |= 1 & N, N >>>= 1, $ <<= 1, 0 < --V; )
          ;
        return $ >>> 1;
      }
      function Le(N, V, $) {
        var ee, G, te = new Array(E + 1), re = 0;
        for (ee = 1; ee <= E; ee++)
          te[ee] = re = re + $[ee - 1] << 1;
        for (G = 0; G <= V; G++) {
          var se = N[2 * G + 1];
          se !== 0 && (N[2 * G] = Fe(te[se]++, se));
        }
      }
      function le(N) {
        var V;
        for (V = 0; V < u; V++)
          N.dyn_ltree[2 * V] = 0;
        for (V = 0; V < d; V++)
          N.dyn_dtree[2 * V] = 0;
        for (V = 0; V < p; V++)
          N.bl_tree[2 * V] = 0;
        N.dyn_ltree[2 * T] = 1, N.opt_len = N.static_len = 0, N.last_lit = N.matches = 0;
      }
      function me(N) {
        8 < N.bi_valid ? ae(N, N.bi_buf) : 0 < N.bi_valid && (N.pending_buf[N.pending++] = N.bi_buf), N.bi_buf = 0, N.bi_valid = 0;
      }
      function pe(N, V, $, ee) {
        var G = 2 * V, te = 2 * $;
        return N[G] < N[te] || N[G] === N[te] && ee[V] <= ee[$];
      }
      function Te(N, V, $) {
        for (var ee = N.heap[$], G = $ << 1; G <= N.heap_len && (G < N.heap_len && pe(V, N.heap[G + 1], N.heap[G], N.depth) && G++, !pe(V, ee, N.heap[G], N.depth)); )
          N.heap[$] = N.heap[G], $ = G, G <<= 1;
        N.heap[$] = ee;
      }
      function tt(N, V, $) {
        var ee, G, te, re, se = 0;
        if (N.last_lit !== 0)
          for (; ee = N.pending_buf[N.d_buf + 2 * se] << 8 | N.pending_buf[N.d_buf + 2 * se + 1], G = N.pending_buf[N.l_buf + se], se++, ee === 0 ? ie(N, G, V) : (ie(N, (te = R[G]) + f + 1, V), (re = P[te]) !== 0 && ne(N, G -= _[te], re), ie(N, te = k(--ee), $), (re = M[te]) !== 0 && ne(N, ee -= H[te], re)), se < N.last_lit; )
            ;
        ie(N, T, V);
      }
      function Ge(N, V) {
        var $, ee, G, te = V.dyn_tree, re = V.stat_desc.static_tree, se = V.stat_desc.has_stree, ce = V.stat_desc.elems, Re = -1;
        for (N.heap_len = 0, N.heap_max = m, $ = 0; $ < ce; $++)
          te[2 * $] !== 0 ? (N.heap[++N.heap_len] = Re = $, N.depth[$] = 0) : te[2 * $ + 1] = 0;
        for (; N.heap_len < 2; )
          te[2 * (G = N.heap[++N.heap_len] = Re < 2 ? ++Re : 0)] = 1, N.depth[G] = 0, N.opt_len--, se && (N.static_len -= re[2 * G + 1]);
        for (V.max_code = Re, $ = N.heap_len >> 1; 1 <= $; $--)
          Te(N, te, $);
        for (G = ce; $ = N.heap[1], N.heap[1] = N.heap[N.heap_len--], Te(N, te, 1), ee = N.heap[1], N.heap[--N.heap_max] = $, N.heap[--N.heap_max] = ee, te[2 * G] = te[2 * $] + te[2 * ee], N.depth[G] = (N.depth[$] >= N.depth[ee] ? N.depth[$] : N.depth[ee]) + 1, te[2 * $ + 1] = te[2 * ee + 1] = G, N.heap[1] = G++, Te(N, te, 1), 2 <= N.heap_len; )
          ;
        N.heap[--N.heap_max] = N.heap[1], function(Ie, st) {
          var Gs, It, Ys, Me, Oi, Qn, Pt = st.dyn_tree, mo = st.max_code, pc = st.stat_desc.static_tree, mc = st.stat_desc.has_stree, Ic = st.stat_desc.extra_bits, Io = st.stat_desc.extra_base, Hs = st.stat_desc.max_length, Pi = 0;
          for (Me = 0; Me <= E; Me++)
            Ie.bl_count[Me] = 0;
          for (Pt[2 * Ie.heap[Ie.heap_max] + 1] = 0, Gs = Ie.heap_max + 1; Gs < m; Gs++)
            Hs < (Me = Pt[2 * Pt[2 * (It = Ie.heap[Gs]) + 1] + 1] + 1) && (Me = Hs, Pi++), Pt[2 * It + 1] = Me, mo < It || (Ie.bl_count[Me]++, Oi = 0, Io <= It && (Oi = Ic[It - Io]), Qn = Pt[2 * It], Ie.opt_len += Qn * (Me + Oi), mc && (Ie.static_len += Qn * (pc[2 * It + 1] + Oi)));
          if (Pi !== 0) {
            do {
              for (Me = Hs - 1; Ie.bl_count[Me] === 0; )
                Me--;
              Ie.bl_count[Me]--, Ie.bl_count[Me + 1] += 2, Ie.bl_count[Hs]--, Pi -= 2;
            } while (0 < Pi);
            for (Me = Hs; Me !== 0; Me--)
              for (It = Ie.bl_count[Me]; It !== 0; )
                mo < (Ys = Ie.heap[--Gs]) || (Pt[2 * Ys + 1] !== Me && (Ie.opt_len += (Me - Pt[2 * Ys + 1]) * Pt[2 * Ys], Pt[2 * Ys + 1] = Me), It--);
          }
        }(N, V), Le(te, Re, N.bl_count);
      }
      function S(N, V, $) {
        var ee, G, te = -1, re = V[1], se = 0, ce = 7, Re = 4;
        for (re === 0 && (ce = 138, Re = 3), V[2 * ($ + 1) + 1] = 65535, ee = 0; ee <= $; ee++)
          G = re, re = V[2 * (ee + 1) + 1], ++se < ce && G === re || (se < Re ? N.bl_tree[2 * G] += se : G !== 0 ? (G !== te && N.bl_tree[2 * G]++, N.bl_tree[2 * C]++) : se <= 10 ? N.bl_tree[2 * F]++ : N.bl_tree[2 * O]++, te = G, Re = (se = 0) === re ? (ce = 138, 3) : G === re ? (ce = 6, 3) : (ce = 7, 4));
      }
      function Q(N, V, $) {
        var ee, G, te = -1, re = V[1], se = 0, ce = 7, Re = 4;
        for (re === 0 && (ce = 138, Re = 3), ee = 0; ee <= $; ee++)
          if (G = re, re = V[2 * (ee + 1) + 1], !(++se < ce && G === re)) {
            if (se < Re)
              for (; ie(N, G, N.bl_tree), --se != 0; )
                ;
            else
              G !== 0 ? (G !== te && (ie(N, G, N.bl_tree), se--), ie(N, C, N.bl_tree), ne(N, se - 3, 2)) : se <= 10 ? (ie(N, F, N.bl_tree), ne(N, se - 3, 3)) : (ie(N, O, N.bl_tree), ne(N, se - 11, 7));
            te = G, Re = (se = 0) === re ? (ce = 138, 3) : G === re ? (ce = 6, 3) : (ce = 7, 4);
          }
      }
      a(H);
      var X = !1;
      function x(N, V, $, ee) {
        ne(N, (c << 1) + (ee ? 1 : 0), 3), function(G, te, re, se) {
          me(G), ae(G, re), ae(G, ~re), n.arraySet(G.pending_buf, G.window, te, re, G.pending), G.pending += re;
        }(N, V, $);
      }
      i._tr_init = function(N) {
        X || (function() {
          var V, $, ee, G, te, re = new Array(E + 1);
          for (G = ee = 0; G < h - 1; G++)
            for (_[G] = ee, V = 0; V < 1 << P[G]; V++)
              R[ee++] = G;
          for (R[ee - 1] = G, G = te = 0; G < 16; G++)
            for (H[G] = te, V = 0; V < 1 << M[G]; V++)
              D[te++] = G;
          for (te >>= 7; G < d; G++)
            for (H[G] = te << 7, V = 0; V < 1 << M[G] - 7; V++)
              D[256 + te++] = G;
          for ($ = 0; $ <= E; $++)
            re[$] = 0;
          for (V = 0; V <= 143; )
            B[2 * V + 1] = 8, V++, re[8]++;
          for (; V <= 255; )
            B[2 * V + 1] = 9, V++, re[9]++;
          for (; V <= 279; )
            B[2 * V + 1] = 7, V++, re[7]++;
          for (; V <= 287; )
            B[2 * V + 1] = 8, V++, re[8]++;
          for (Le(B, u + 1, re), V = 0; V < d; V++)
            v[2 * V + 1] = 5, v[2 * V] = Fe(V, 5);
          K = new J(B, P, f + 1, u, E), U = new J(v, M, 0, d, E), Z = new J(new Array(0), L, 0, p, g);
        }(), X = !0), N.l_desc = new z(N.dyn_ltree, K), N.d_desc = new z(N.dyn_dtree, U), N.bl_desc = new z(N.bl_tree, Z), N.bi_buf = 0, N.bi_valid = 0, le(N);
      }, i._tr_stored_block = x, i._tr_flush_block = function(N, V, $, ee) {
        var G, te, re = 0;
        0 < N.level ? (N.strm.data_type === 2 && (N.strm.data_type = function(se) {
          var ce, Re = 4093624447;
          for (ce = 0; ce <= 31; ce++, Re >>>= 1)
            if (1 & Re && se.dyn_ltree[2 * ce] !== 0)
              return r;
          if (se.dyn_ltree[18] !== 0 || se.dyn_ltree[20] !== 0 || se.dyn_ltree[26] !== 0)
            return o;
          for (ce = 32; ce < f; ce++)
            if (se.dyn_ltree[2 * ce] !== 0)
              return o;
          return r;
        }(N)), Ge(N, N.l_desc), Ge(N, N.d_desc), re = function(se) {
          var ce;
          for (S(se, se.dyn_ltree, se.l_desc.max_code), S(se, se.dyn_dtree, se.d_desc.max_code), Ge(se, se.bl_desc), ce = p - 1; 3 <= ce && se.bl_tree[2 * b[ce] + 1] === 0; ce--)
            ;
          return se.opt_len += 3 * (ce + 1) + 5 + 5 + 4, ce;
        }(N), G = N.opt_len + 3 + 7 >>> 3, (te = N.static_len + 3 + 7 >>> 3) <= G && (G = te)) : G = te = $ + 5, $ + 4 <= G && V !== -1 ? x(N, V, $, ee) : N.strategy === 4 || te === G ? (ne(N, 2 + (ee ? 1 : 0), 3), tt(N, B, v)) : (ne(N, 4 + (ee ? 1 : 0), 3), function(se, ce, Re, Ie) {
          var st;
          for (ne(se, ce - 257, 5), ne(se, Re - 1, 5), ne(se, Ie - 4, 4), st = 0; st < Ie; st++)
            ne(se, se.bl_tree[2 * b[st] + 1], 3);
          Q(se, se.dyn_ltree, ce - 1), Q(se, se.dyn_dtree, Re - 1);
        }(N, N.l_desc.max_code + 1, N.d_desc.max_code + 1, re + 1), tt(N, N.dyn_ltree, N.dyn_dtree)), le(N), ee && me(N);
      }, i._tr_tally = function(N, V, $) {
        return N.pending_buf[N.d_buf + 2 * N.last_lit] = V >>> 8 & 255, N.pending_buf[N.d_buf + 2 * N.last_lit + 1] = 255 & V, N.pending_buf[N.l_buf + N.last_lit] = 255 & $, N.last_lit++, V === 0 ? N.dyn_ltree[2 * $]++ : (N.matches++, V--, N.dyn_ltree[2 * (R[$] + f + 1)]++, N.dyn_dtree[2 * k(V)]++), N.last_lit === N.lit_bufsize - 1;
      }, i._tr_align = function(N) {
        ne(N, 2, 3), ie(N, T, B), function(V) {
          V.bi_valid === 16 ? (ae(V, V.bi_buf), V.bi_buf = 0, V.bi_valid = 0) : 8 <= V.bi_valid && (V.pending_buf[V.pending++] = 255 & V.bi_buf, V.bi_buf >>= 8, V.bi_valid -= 8);
        }(N);
      };
    }, { "../utils/common": 41 }], 53: [function(e, s, i) {
      s.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, s, i) {
      (function(n) {
        (function(r, o) {
          if (!r.setImmediate) {
            var a, c, h, f, u = 1, d = {}, p = !1, m = r.document, E = Object.getPrototypeOf && Object.getPrototypeOf(r);
            E = E && E.setTimeout ? E : r, a = {}.toString.call(r.process) === "[object process]" ? function(C) {
              process.nextTick(function() {
                g(C);
              });
            } : function() {
              if (r.postMessage && !r.importScripts) {
                var C = !0, F = r.onmessage;
                return r.onmessage = function() {
                  C = !1;
                }, r.postMessage("", "*"), r.onmessage = F, C;
              }
            }() ? (f = "setImmediate$" + Math.random() + "$", r.addEventListener ? r.addEventListener("message", T, !1) : r.attachEvent("onmessage", T), function(C) {
              r.postMessage(f + C, "*");
            }) : r.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(C) {
              g(C.data);
            }, function(C) {
              h.port2.postMessage(C);
            }) : m && "onreadystatechange" in m.createElement("script") ? (c = m.documentElement, function(C) {
              var F = m.createElement("script");
              F.onreadystatechange = function() {
                g(C), F.onreadystatechange = null, c.removeChild(F), F = null;
              }, c.appendChild(F);
            }) : function(C) {
              setTimeout(g, 0, C);
            }, E.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var F = new Array(arguments.length - 1), O = 0; O < F.length; O++)
                F[O] = arguments[O + 1];
              var P = { callback: C, args: F };
              return d[u] = P, a(u), u++;
            }, E.clearImmediate = I;
          }
          function I(C) {
            delete d[C];
          }
          function g(C) {
            if (p)
              setTimeout(g, 0, C);
            else {
              var F = d[C];
              if (F) {
                p = !0;
                try {
                  (function(O) {
                    var P = O.callback, M = O.args;
                    switch (M.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(M[0]);
                        break;
                      case 2:
                        P(M[0], M[1]);
                        break;
                      case 3:
                        P(M[0], M[1], M[2]);
                        break;
                      default:
                        P.apply(o, M);
                    }
                  })(F);
                } finally {
                  I(C), p = !1;
                }
              }
            }
          }
          function T(C) {
            C.source === r && typeof C.data == "string" && C.data.indexOf(f) === 0 && g(+C.data.slice(f.length));
          }
        })(typeof self > "u" ? n === void 0 ? this : n : self);
      }).call(this, typeof Zi < "u" ? Zi : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Pl);
var lf = Pl.exports;
const ra = /* @__PURE__ */ Ja(lf);
var ao = {}, Wn = {};
(function(l) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", e = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", s = "[" + t + "][" + e + "]*", i = new RegExp("^" + s + "$"), n = function(o, a) {
    const c = [];
    let h = a.exec(o);
    for (; h; ) {
      const f = [];
      f.startIndex = a.lastIndex - h[0].length;
      const u = h.length;
      for (let d = 0; d < u; d++)
        f.push(h[d]);
      c.push(f), h = a.exec(o);
    }
    return c;
  }, r = function(o) {
    const a = i.exec(o);
    return !(a === null || typeof a > "u");
  };
  l.isExist = function(o) {
    return typeof o < "u";
  }, l.isEmptyObject = function(o) {
    return Object.keys(o).length === 0;
  }, l.merge = function(o, a, c) {
    if (a) {
      const h = Object.keys(a), f = h.length;
      for (let u = 0; u < f; u++)
        c === "strict" ? o[h[u]] = [a[h[u]]] : o[h[u]] = a[h[u]];
    }
  }, l.getValue = function(o) {
    return l.isExist(o) ? o : "";
  }, l.isName = r, l.getAllMatches = n, l.nameRegexp = s;
})(Wn);
const lo = Wn, cf = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
ao.validate = function(l, t) {
  t = Object.assign({}, cf, t);
  const e = [];
  let s = !1, i = !1;
  l[0] === "\uFEFF" && (l = l.substr(1));
  for (let n = 0; n < l.length; n++)
    if (l[n] === "<" && l[n + 1] === "?") {
      if (n += 2, n = aa(l, n), n.err)
        return n;
    } else if (l[n] === "<") {
      let r = n;
      if (n++, l[n] === "!") {
        n = la(l, n);
        continue;
      } else {
        let o = !1;
        l[n] === "/" && (o = !0, n++);
        let a = "";
        for (; n < l.length && l[n] !== ">" && l[n] !== " " && l[n] !== "	" && l[n] !== `
` && l[n] !== "\r"; n++)
          a += l[n];
        if (a = a.trim(), a[a.length - 1] === "/" && (a = a.substring(0, a.length - 1), n--), !Ef(a)) {
          let f;
          return a.trim().length === 0 ? f = "Invalid space after '<'." : f = "Tag '" + a + "' is an invalid name.", be("InvalidTag", f, We(l, n));
        }
        const c = ff(l, n);
        if (c === !1)
          return be("InvalidAttr", "Attributes for '" + a + "' have open quote.", We(l, n));
        let h = c.value;
        if (n = c.index, h[h.length - 1] === "/") {
          const f = n - h.length;
          h = h.substring(0, h.length - 1);
          const u = ca(h, t);
          if (u === !0)
            s = !0;
          else
            return be(u.err.code, u.err.msg, We(l, f + u.err.line));
        } else if (o)
          if (c.tagClosed) {
            if (h.trim().length > 0)
              return be("InvalidTag", "Closing tag '" + a + "' can't have attributes or invalid starting.", We(l, r));
            if (e.length === 0)
              return be("InvalidTag", "Closing tag '" + a + "' has not been opened.", We(l, r));
            {
              const f = e.pop();
              if (a !== f.tagName) {
                let u = We(l, f.tagStartPos);
                return be(
                  "InvalidTag",
                  "Expected closing tag '" + f.tagName + "' (opened in line " + u.line + ", col " + u.col + ") instead of closing tag '" + a + "'.",
                  We(l, r)
                );
              }
              e.length == 0 && (i = !0);
            }
          } else
            return be("InvalidTag", "Closing tag '" + a + "' doesn't have proper closing.", We(l, n));
        else {
          const f = ca(h, t);
          if (f !== !0)
            return be(f.err.code, f.err.msg, We(l, n - h.length + f.err.line));
          if (i === !0)
            return be("InvalidXml", "Multiple possible root nodes found.", We(l, n));
          t.unpairedTags.indexOf(a) !== -1 || e.push({ tagName: a, tagStartPos: r }), s = !0;
        }
        for (n++; n < l.length; n++)
          if (l[n] === "<")
            if (l[n + 1] === "!") {
              n++, n = la(l, n);
              continue;
            } else if (l[n + 1] === "?") {
              if (n = aa(l, ++n), n.err)
                return n;
            } else
              break;
          else if (l[n] === "&") {
            const f = mf(l, n);
            if (f == -1)
              return be("InvalidChar", "char '&' is not expected.", We(l, n));
            n = f;
          } else if (i === !0 && !oa(l[n]))
            return be("InvalidXml", "Extra text at the end", We(l, n));
        l[n] === "<" && n--;
      }
    } else {
      if (oa(l[n]))
        continue;
      return be("InvalidChar", "char '" + l[n] + "' is not expected.", We(l, n));
    }
  if (s) {
    if (e.length == 1)
      return be("InvalidTag", "Unclosed tag '" + e[0].tagName + "'.", We(l, e[0].tagStartPos));
    if (e.length > 0)
      return be("InvalidXml", "Invalid '" + JSON.stringify(e.map((n) => n.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return be("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function oa(l) {
  return l === " " || l === "	" || l === `
` || l === "\r";
}
function aa(l, t) {
  const e = t;
  for (; t < l.length; t++)
    if (l[t] == "?" || l[t] == " ") {
      const s = l.substr(e, t - e);
      if (t > 5 && s === "xml")
        return be("InvalidXml", "XML declaration allowed only at the start of the document.", We(l, t));
      if (l[t] == "?" && l[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function la(l, t) {
  if (l.length > t + 5 && l[t + 1] === "-" && l[t + 2] === "-") {
    for (t += 3; t < l.length; t++)
      if (l[t] === "-" && l[t + 1] === "-" && l[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (l.length > t + 8 && l[t + 1] === "D" && l[t + 2] === "O" && l[t + 3] === "C" && l[t + 4] === "T" && l[t + 5] === "Y" && l[t + 6] === "P" && l[t + 7] === "E") {
    let e = 1;
    for (t += 8; t < l.length; t++)
      if (l[t] === "<")
        e++;
      else if (l[t] === ">" && (e--, e === 0))
        break;
  } else if (l.length > t + 9 && l[t + 1] === "[" && l[t + 2] === "C" && l[t + 3] === "D" && l[t + 4] === "A" && l[t + 5] === "T" && l[t + 6] === "A" && l[t + 7] === "[") {
    for (t += 8; t < l.length; t++)
      if (l[t] === "]" && l[t + 1] === "]" && l[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
const hf = '"', uf = "'";
function ff(l, t) {
  let e = "", s = "", i = !1;
  for (; t < l.length; t++) {
    if (l[t] === hf || l[t] === uf)
      s === "" ? s = l[t] : s !== l[t] || (s = "");
    else if (l[t] === ">" && s === "") {
      i = !0;
      break;
    }
    e += l[t];
  }
  return s !== "" ? !1 : {
    value: e,
    index: t,
    tagClosed: i
  };
}
const df = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function ca(l, t) {
  const e = lo.getAllMatches(l, df), s = {};
  for (let i = 0; i < e.length; i++) {
    if (e[i][1].length === 0)
      return be("InvalidAttr", "Attribute '" + e[i][2] + "' has no space in starting.", ri(e[i]));
    if (e[i][3] !== void 0 && e[i][4] === void 0)
      return be("InvalidAttr", "Attribute '" + e[i][2] + "' is without value.", ri(e[i]));
    if (e[i][3] === void 0 && !t.allowBooleanAttributes)
      return be("InvalidAttr", "boolean attribute '" + e[i][2] + "' is not allowed.", ri(e[i]));
    const n = e[i][2];
    if (!If(n))
      return be("InvalidAttr", "Attribute '" + n + "' is an invalid name.", ri(e[i]));
    if (!s.hasOwnProperty(n))
      s[n] = 1;
    else
      return be("InvalidAttr", "Attribute '" + n + "' is repeated.", ri(e[i]));
  }
  return !0;
}
function pf(l, t) {
  let e = /\d/;
  for (l[t] === "x" && (t++, e = /[\da-fA-F]/); t < l.length; t++) {
    if (l[t] === ";")
      return t;
    if (!l[t].match(e))
      break;
  }
  return -1;
}
function mf(l, t) {
  if (t++, l[t] === ";")
    return -1;
  if (l[t] === "#")
    return t++, pf(l, t);
  let e = 0;
  for (; t < l.length; t++, e++)
    if (!(l[t].match(/\w/) && e < 20)) {
      if (l[t] === ";")
        break;
      return -1;
    }
  return t;
}
function be(l, t, e) {
  return {
    err: {
      code: l,
      msg: t,
      line: e.line || e,
      col: e.col
    }
  };
}
function If(l) {
  return lo.isName(l);
}
function Ef(l) {
  return lo.isName(l);
}
function We(l, t) {
  const e = l.substring(0, t).split(/\r?\n/);
  return {
    line: e.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: e[e.length - 1].length + 1
  };
}
function ri(l) {
  return l.startIndex + l[1].length;
}
var co = {};
const Nl = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(l, t) {
    return t;
  },
  attributeValueProcessor: function(l, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(l, t, e) {
    return l;
  }
  // skipEmptyListItem: false
}, gf = function(l) {
  return Object.assign({}, Nl, l);
};
co.buildOptions = gf;
co.defaultOptions = Nl;
class Cf {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, e) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: e });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
}
var Tf = Cf;
const yf = Wn;
function Rf(l, t) {
  const e = {};
  if (l[t + 3] === "O" && l[t + 4] === "C" && l[t + 5] === "T" && l[t + 6] === "Y" && l[t + 7] === "P" && l[t + 8] === "E") {
    t = t + 9;
    let s = 1, i = !1, n = !1, r = "";
    for (; t < l.length; t++)
      if (l[t] === "<" && !n)
        i && Af(l, t) ? (t += 7, [entityName, val, t] = Sf(l, t + 1), val.indexOf("&") === -1 && (e[Of(entityName)] = {
          regx: RegExp(`&${entityName};`, "g"),
          val
        })) : i && Ff(l, t) || i && wf(l, t) ? t += 8 : i && vf(l, t) ? t += 9 : n = !0, s++, r = "";
      else if (l[t] === ">") {
        if (n ? l[t - 1] === "-" && l[t - 2] === "-" && (n = !1, s--) : s--, s === 0)
          break;
      } else
        l[t] === "[" ? i = !0 : r += l[t];
    if (s !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: e, i: t };
}
function Sf(l, t) {
  let e = "";
  for (; t < l.length && l[t] !== "'" && l[t] !== '"'; t++)
    e += l[t];
  if (e = e.trim(), e.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const s = l[t++];
  let i = "";
  for (; t < l.length && l[t] !== s; t++)
    i += l[t];
  return [e, i, t];
}
function Af(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "E" && l[t + 3] === "N" && l[t + 4] === "T" && l[t + 5] === "I" && l[t + 6] === "T" && l[t + 7] === "Y";
}
function Ff(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "E" && l[t + 3] === "L" && l[t + 4] === "E" && l[t + 5] === "M" && l[t + 6] === "E" && l[t + 7] === "N" && l[t + 8] === "T";
}
function wf(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "A" && l[t + 3] === "T" && l[t + 4] === "T" && l[t + 5] === "L" && l[t + 6] === "I" && l[t + 7] === "S" && l[t + 8] === "T";
}
function vf(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "N" && l[t + 3] === "O" && l[t + 4] === "T" && l[t + 5] === "A" && l[t + 6] === "T" && l[t + 7] === "I" && l[t + 8] === "O" && l[t + 9] === "N";
}
function Of(l) {
  if (yf.isName(l))
    return l;
  throw new Error(`Invalid entity name ${l}`);
}
var Pf = Rf;
const Nf = /^[-+]?0x[a-fA-F0-9]+$/, xf = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const Lf = {
  hex: !0,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function Mf(l, t = {}) {
  if (t = Object.assign({}, Lf, t), !l || typeof l != "string")
    return l;
  let e = l.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(e))
    return l;
  if (t.hex && Nf.test(e))
    return Number.parseInt(e, 16);
  {
    const s = xf.exec(e);
    if (s) {
      const i = s[1], n = s[2];
      let r = bf(s[3]);
      const o = s[4] || s[6];
      if (!t.leadingZeros && n.length > 0 && i && e[2] !== ".")
        return l;
      if (!t.leadingZeros && n.length > 0 && !i && e[1] !== ".")
        return l;
      {
        const a = Number(e), c = "" + a;
        return c.search(/[eE]/) !== -1 || o ? t.eNotation ? a : l : e.indexOf(".") !== -1 ? c === "0" && r === "" || c === r || i && c === "-" + r ? a : l : n ? r === c || i + r === c ? a : l : e === c || e === i + c ? a : l;
      }
    } else
      return l;
  }
}
function bf(l) {
  return l && l.indexOf(".") !== -1 && (l = l.replace(/0+$/, ""), l === "." ? l = "0" : l[0] === "." ? l = "0" + l : l[l.length - 1] === "." && (l = l.substr(0, l.length - 1))), l;
}
var Df = Mf;
const xl = Wn, oi = Tf, _f = Pf, Uf = Df;
let Bf = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "¢" },
      pound: { regex: /&(pound|#163);/g, val: "£" },
      yen: { regex: /&(yen|#165);/g, val: "¥" },
      euro: { regex: /&(euro|#8364);/g, val: "€" },
      copyright: { regex: /&(copy|#169);/g, val: "©" },
      reg: { regex: /&(reg|#174);/g, val: "®" },
      inr: { regex: /&(inr|#8377);/g, val: "₹" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (e, s) => String.fromCharCode(Number.parseInt(s, 10)) },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (e, s) => String.fromCharCode(Number.parseInt(s, 16)) }
    }, this.addExternalEntities = Vf, this.parseXml = Hf, this.parseTextData = zf, this.resolveNameSpace = kf, this.buildAttributesMap = Yf, this.isItStopNode = jf, this.replaceEntitiesValue = Xf, this.readStopNodeData = Kf, this.saveTextToParentTag = Zf, this.addChild = Wf;
  }
};
function Vf(l) {
  const t = Object.keys(l);
  for (let e = 0; e < t.length; e++) {
    const s = t[e];
    this.lastEntities[s] = {
      regex: new RegExp("&" + s + ";", "g"),
      val: l[s]
    };
  }
}
function zf(l, t, e, s, i, n, r) {
  if (l !== void 0 && (this.options.trimValues && !s && (l = l.trim()), l.length > 0)) {
    r || (l = this.replaceEntitiesValue(l));
    const o = this.options.tagValueProcessor(t, l, e, i, n);
    return o == null ? l : typeof o != typeof l || o !== l ? o : this.options.trimValues ? Yr(l, this.options.parseTagValue, this.options.numberParseOptions) : l.trim() === l ? Yr(l, this.options.parseTagValue, this.options.numberParseOptions) : l;
  }
}
function kf(l) {
  if (this.options.removeNSPrefix) {
    const t = l.split(":"), e = l.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (l = e + t[1]);
  }
  return l;
}
const Gf = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Yf(l, t, e) {
  if (!this.options.ignoreAttributes && typeof l == "string") {
    const s = xl.getAllMatches(l, Gf), i = s.length, n = {};
    for (let r = 0; r < i; r++) {
      const o = this.resolveNameSpace(s[r][1]);
      let a = s[r][4], c = this.options.attributeNamePrefix + o;
      if (o.length)
        if (this.options.transformAttributeName && (c = this.options.transformAttributeName(c)), c === "__proto__" && (c = "#__proto__"), a !== void 0) {
          this.options.trimValues && (a = a.trim()), a = this.replaceEntitiesValue(a);
          const h = this.options.attributeValueProcessor(o, a, t);
          h == null ? n[c] = a : typeof h != typeof a || h !== a ? n[c] = h : n[c] = Yr(
            a,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (n[c] = !0);
    }
    if (!Object.keys(n).length)
      return;
    if (this.options.attributesGroupName) {
      const r = {};
      return r[this.options.attributesGroupName] = n, r;
    }
    return n;
  }
}
const Hf = function(l) {
  l = l.replace(/\r\n?/g, `
`);
  const t = new oi("!xml");
  let e = t, s = "", i = "";
  for (let n = 0; n < l.length; n++)
    if (l[n] === "<")
      if (l[n + 1] === "/") {
        const o = ls(l, ">", n, "Closing Tag is not closed.");
        let a = l.substring(n + 2, o).trim();
        if (this.options.removeNSPrefix) {
          const f = a.indexOf(":");
          f !== -1 && (a = a.substr(f + 1));
        }
        this.options.transformTagName && (a = this.options.transformTagName(a)), e && (s = this.saveTextToParentTag(s, e, i));
        const c = i.substring(i.lastIndexOf(".") + 1);
        if (a && this.options.unpairedTags.indexOf(a) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${a}>`);
        let h = 0;
        c && this.options.unpairedTags.indexOf(c) !== -1 ? (h = i.lastIndexOf(".", i.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : h = i.lastIndexOf("."), i = i.substring(0, h), e = this.tagsNodeStack.pop(), s = "", n = o;
      } else if (l[n + 1] === "?") {
        let o = Gr(l, n, !1, "?>");
        if (!o)
          throw new Error("Pi Tag is not closed.");
        if (s = this.saveTextToParentTag(s, e, i), !(this.options.ignoreDeclaration && o.tagName === "?xml" || this.options.ignorePiTags)) {
          const a = new oi(o.tagName);
          a.add(this.options.textNodeName, ""), o.tagName !== o.tagExp && o.attrExpPresent && (a[":@"] = this.buildAttributesMap(o.tagExp, i, o.tagName)), this.addChild(e, a, i);
        }
        n = o.closeIndex + 1;
      } else if (l.substr(n + 1, 3) === "!--") {
        const o = ls(l, "-->", n + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const a = l.substring(n + 4, o - 2);
          s = this.saveTextToParentTag(s, e, i), e.add(this.options.commentPropName, [{ [this.options.textNodeName]: a }]);
        }
        n = o;
      } else if (l.substr(n + 1, 2) === "!D") {
        const o = _f(l, n);
        this.docTypeEntities = o.entities, n = o.i;
      } else if (l.substr(n + 1, 2) === "![") {
        const o = ls(l, "]]>", n, "CDATA is not closed.") - 2, a = l.substring(n + 9, o);
        s = this.saveTextToParentTag(s, e, i);
        let c = this.parseTextData(a, e.tagname, i, !0, !1, !0, !0);
        c == null && (c = ""), this.options.cdataPropName ? e.add(this.options.cdataPropName, [{ [this.options.textNodeName]: a }]) : e.add(this.options.textNodeName, c), n = o + 2;
      } else {
        let o = Gr(l, n, this.options.removeNSPrefix), a = o.tagName;
        const c = o.rawTagName;
        let h = o.tagExp, f = o.attrExpPresent, u = o.closeIndex;
        this.options.transformTagName && (a = this.options.transformTagName(a)), e && s && e.tagname !== "!xml" && (s = this.saveTextToParentTag(s, e, i, !1));
        const d = e;
        if (d && this.options.unpairedTags.indexOf(d.tagname) !== -1 && (e = this.tagsNodeStack.pop(), i = i.substring(0, i.lastIndexOf("."))), a !== t.tagname && (i += i ? "." + a : a), this.isItStopNode(this.options.stopNodes, i, a)) {
          let p = "";
          if (h.length > 0 && h.lastIndexOf("/") === h.length - 1)
            a[a.length - 1] === "/" ? (a = a.substr(0, a.length - 1), i = i.substr(0, i.length - 1), h = a) : h = h.substr(0, h.length - 1), n = o.closeIndex;
          else if (this.options.unpairedTags.indexOf(a) !== -1)
            n = o.closeIndex;
          else {
            const E = this.readStopNodeData(l, c, u + 1);
            if (!E)
              throw new Error(`Unexpected end of ${c}`);
            n = E.i, p = E.tagContent;
          }
          const m = new oi(a);
          a !== h && f && (m[":@"] = this.buildAttributesMap(h, i, a)), p && (p = this.parseTextData(p, a, i, !0, f, !0, !0)), i = i.substr(0, i.lastIndexOf(".")), m.add(this.options.textNodeName, p), this.addChild(e, m, i);
        } else {
          if (h.length > 0 && h.lastIndexOf("/") === h.length - 1) {
            a[a.length - 1] === "/" ? (a = a.substr(0, a.length - 1), i = i.substr(0, i.length - 1), h = a) : h = h.substr(0, h.length - 1), this.options.transformTagName && (a = this.options.transformTagName(a));
            const p = new oi(a);
            a !== h && f && (p[":@"] = this.buildAttributesMap(h, i, a)), this.addChild(e, p, i), i = i.substr(0, i.lastIndexOf("."));
          } else {
            const p = new oi(a);
            this.tagsNodeStack.push(e), a !== h && f && (p[":@"] = this.buildAttributesMap(h, i, a)), this.addChild(e, p, i), e = p;
          }
          s = "", n = u;
        }
      }
    else
      s += l[n];
  return t.child;
};
function Wf(l, t, e) {
  const s = this.options.updateTag(t.tagname, e, t[":@"]);
  s === !1 || (typeof s == "string" && (t.tagname = s), l.addChild(t));
}
const Xf = function(l) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const e = this.docTypeEntities[t];
      l = l.replace(e.regx, e.val);
    }
    for (let t in this.lastEntities) {
      const e = this.lastEntities[t];
      l = l.replace(e.regex, e.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const e = this.htmlEntities[t];
        l = l.replace(e.regex, e.val);
      }
    l = l.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return l;
};
function Zf(l, t, e, s) {
  return l && (s === void 0 && (s = Object.keys(t.child).length === 0), l = this.parseTextData(
    l,
    t.tagname,
    e,
    !1,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1,
    s
  ), l !== void 0 && l !== "" && t.add(this.options.textNodeName, l), l = ""), l;
}
function jf(l, t, e) {
  const s = "*." + e;
  for (const i in l) {
    const n = l[i];
    if (s === n || t === n)
      return !0;
  }
  return !1;
}
function Qf(l, t, e = ">") {
  let s, i = "";
  for (let n = t; n < l.length; n++) {
    let r = l[n];
    if (s)
      r === s && (s = "");
    else if (r === '"' || r === "'")
      s = r;
    else if (r === e[0])
      if (e[1]) {
        if (l[n + 1] === e[1])
          return {
            data: i,
            index: n
          };
      } else
        return {
          data: i,
          index: n
        };
    else
      r === "	" && (r = " ");
    i += r;
  }
}
function ls(l, t, e, s) {
  const i = l.indexOf(t, e);
  if (i === -1)
    throw new Error(s);
  return i + t.length - 1;
}
function Gr(l, t, e, s = ">") {
  const i = Qf(l, t + 1, s);
  if (!i)
    return;
  let n = i.data;
  const r = i.index, o = n.search(/\s/);
  let a = n, c = !0;
  o !== -1 && (a = n.substring(0, o), n = n.substring(o + 1).trimStart());
  const h = a;
  if (e) {
    const f = a.indexOf(":");
    f !== -1 && (a = a.substr(f + 1), c = a !== i.data.substr(f + 1));
  }
  return {
    tagName: a,
    tagExp: n,
    closeIndex: r,
    attrExpPresent: c,
    rawTagName: h
  };
}
function Kf(l, t, e) {
  const s = e;
  let i = 1;
  for (; e < l.length; e++)
    if (l[e] === "<")
      if (l[e + 1] === "/") {
        const n = ls(l, ">", e, `${t} is not closed`);
        if (l.substring(e + 2, n).trim() === t && (i--, i === 0))
          return {
            tagContent: l.substring(s, e),
            i: n
          };
        e = n;
      } else if (l[e + 1] === "?")
        e = ls(l, "?>", e + 1, "StopNode is not closed.");
      else if (l.substr(e + 1, 3) === "!--")
        e = ls(l, "-->", e + 3, "StopNode is not closed.");
      else if (l.substr(e + 1, 2) === "![")
        e = ls(l, "]]>", e, "StopNode is not closed.") - 2;
      else {
        const n = Gr(l, e, ">");
        n && ((n && n.tagName) === t && n.tagExp[n.tagExp.length - 1] !== "/" && i++, e = n.closeIndex);
      }
}
function Yr(l, t, e) {
  if (t && typeof l == "string") {
    const s = l.trim();
    return s === "true" ? !0 : s === "false" ? !1 : Uf(l, e);
  } else
    return xl.isExist(l) ? l : "";
}
var qf = Bf, Ll = {};
function Jf(l, t) {
  return Ml(l, t);
}
function Ml(l, t, e) {
  let s;
  const i = {};
  for (let n = 0; n < l.length; n++) {
    const r = l[n], o = $f(r);
    let a = "";
    if (e === void 0 ? a = o : a = e + "." + o, o === t.textNodeName)
      s === void 0 ? s = r[o] : s += "" + r[o];
    else {
      if (o === void 0)
        continue;
      if (r[o]) {
        let c = Ml(r[o], t, a);
        const h = td(c, t);
        r[":@"] ? ed(c, r[":@"], a, t) : Object.keys(c).length === 1 && c[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? c = c[t.textNodeName] : Object.keys(c).length === 0 && (t.alwaysCreateTextNode ? c[t.textNodeName] = "" : c = ""), i[o] !== void 0 && i.hasOwnProperty(o) ? (Array.isArray(i[o]) || (i[o] = [i[o]]), i[o].push(c)) : t.isArray(o, a, h) ? i[o] = [c] : i[o] = c;
      }
    }
  }
  return typeof s == "string" ? s.length > 0 && (i[t.textNodeName] = s) : s !== void 0 && (i[t.textNodeName] = s), i;
}
function $f(l) {
  const t = Object.keys(l);
  for (let e = 0; e < t.length; e++) {
    const s = t[e];
    if (s !== ":@")
      return s;
  }
}
function ed(l, t, e, s) {
  if (t) {
    const i = Object.keys(t), n = i.length;
    for (let r = 0; r < n; r++) {
      const o = i[r];
      s.isArray(o, e + "." + o, !0, !0) ? l[o] = [t[o]] : l[o] = t[o];
    }
  }
}
function td(l, t) {
  const { textNodeName: e } = t, s = Object.keys(l).length;
  return !!(s === 0 || s === 1 && (l[e] || typeof l[e] == "boolean" || l[e] === 0));
}
Ll.prettify = Jf;
const { buildOptions: sd } = co, id = qf, { prettify: nd } = Ll, rd = ao;
let od = class {
  constructor(t) {
    this.externalEntities = {}, this.options = sd(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, e) {
    if (typeof t != "string")
      if (t.toString)
        t = t.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (e) {
      e === !0 && (e = {});
      const n = rd.validate(t, e);
      if (n !== !0)
        throw Error(`${n.err.msg}:${n.err.line}:${n.err.col}`);
    }
    const s = new id(this.options);
    s.addExternalEntities(this.externalEntities);
    const i = s.parseXml(t);
    return this.options.preserveOrder || i === void 0 ? i : nd(i, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, e) {
    if (e.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (e === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = e;
  }
};
var ad = od;
const ld = `
`;
function cd(l, t) {
  let e = "";
  return t.format && t.indentBy.length > 0 && (e = ld), bl(l, t, "", e);
}
function bl(l, t, e, s) {
  let i = "", n = !1;
  for (let r = 0; r < l.length; r++) {
    const o = l[r], a = hd(o);
    if (a === void 0)
      continue;
    let c = "";
    if (e.length === 0 ? c = a : c = `${e}.${a}`, a === t.textNodeName) {
      let p = o[a];
      ud(c, t) || (p = t.tagValueProcessor(a, p), p = Dl(p, t)), n && (i += s), i += p, n = !1;
      continue;
    } else if (a === t.cdataPropName) {
      n && (i += s), i += `<![CDATA[${o[a][0][t.textNodeName]}]]>`, n = !1;
      continue;
    } else if (a === t.commentPropName) {
      i += s + `<!--${o[a][0][t.textNodeName]}-->`, n = !0;
      continue;
    } else if (a[0] === "?") {
      const p = ha(o[":@"], t), m = a === "?xml" ? "" : s;
      let E = o[a][0][t.textNodeName];
      E = E.length !== 0 ? " " + E : "", i += m + `<${a}${E}${p}?>`, n = !0;
      continue;
    }
    let h = s;
    h !== "" && (h += t.indentBy);
    const f = ha(o[":@"], t), u = s + `<${a}${f}`, d = bl(o[a], t, c, h);
    t.unpairedTags.indexOf(a) !== -1 ? t.suppressUnpairedNode ? i += u + ">" : i += u + "/>" : (!d || d.length === 0) && t.suppressEmptyNode ? i += u + "/>" : d && d.endsWith(">") ? i += u + `>${d}${s}</${a}>` : (i += u + ">", d && s !== "" && (d.includes("/>") || d.includes("</")) ? i += s + t.indentBy + d + s : i += d, i += `</${a}>`), n = !0;
  }
  return i;
}
function hd(l) {
  const t = Object.keys(l);
  for (let e = 0; e < t.length; e++) {
    const s = t[e];
    if (l.hasOwnProperty(s) && s !== ":@")
      return s;
  }
}
function ha(l, t) {
  let e = "";
  if (l && !t.ignoreAttributes)
    for (let s in l) {
      if (!l.hasOwnProperty(s))
        continue;
      let i = t.attributeValueProcessor(s, l[s]);
      i = Dl(i, t), i === !0 && t.suppressBooleanAttributes ? e += ` ${s.substr(t.attributeNamePrefix.length)}` : e += ` ${s.substr(t.attributeNamePrefix.length)}="${i}"`;
    }
  return e;
}
function ud(l, t) {
  l = l.substr(0, l.length - t.textNodeName.length - 1);
  let e = l.substr(l.lastIndexOf(".") + 1);
  for (let s in t.stopNodes)
    if (t.stopNodes[s] === l || t.stopNodes[s] === "*." + e)
      return !0;
  return !1;
}
function Dl(l, t) {
  if (l && l.length > 0 && t.processEntities)
    for (let e = 0; e < t.entities.length; e++) {
      const s = t.entities[e];
      l = l.replace(s.regex, s.val);
    }
  return l;
}
var fd = cd;
const dd = fd, pd = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(l, t) {
    return t;
  },
  attributeValueProcessor: function(l, t) {
    return t;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function es(l) {
  this.options = Object.assign({}, pd, l), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Ed), this.processTextOrObjNode = md, this.options.format ? (this.indentate = Id, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
es.prototype.build = function(l) {
  return this.options.preserveOrder ? dd(l, this.options) : (Array.isArray(l) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (l = {
    [this.options.arrayNodeName]: l
  }), this.j2x(l, 0).val);
};
es.prototype.j2x = function(l, t) {
  let e = "", s = "";
  for (let i in l)
    if (Object.prototype.hasOwnProperty.call(l, i))
      if (typeof l[i] > "u")
        this.isAttribute(i) && (s += "");
      else if (l[i] === null)
        this.isAttribute(i) ? s += "" : i[0] === "?" ? s += this.indentate(t) + "<" + i + "?" + this.tagEndChar : s += this.indentate(t) + "<" + i + "/" + this.tagEndChar;
      else if (l[i] instanceof Date)
        s += this.buildTextValNode(l[i], i, "", t);
      else if (typeof l[i] != "object") {
        const n = this.isAttribute(i);
        if (n)
          e += this.buildAttrPairStr(n, "" + l[i]);
        else if (i === this.options.textNodeName) {
          let r = this.options.tagValueProcessor(i, "" + l[i]);
          s += this.replaceEntitiesValue(r);
        } else
          s += this.buildTextValNode(l[i], i, "", t);
      } else if (Array.isArray(l[i])) {
        const n = l[i].length;
        let r = "", o = "";
        for (let a = 0; a < n; a++) {
          const c = l[i][a];
          if (!(typeof c > "u"))
            if (c === null)
              i[0] === "?" ? s += this.indentate(t) + "<" + i + "?" + this.tagEndChar : s += this.indentate(t) + "<" + i + "/" + this.tagEndChar;
            else if (typeof c == "object")
              if (this.options.oneListGroup) {
                const h = this.j2x(c, t + 1);
                r += h.val, this.options.attributesGroupName && c.hasOwnProperty(this.options.attributesGroupName) && (o += h.attrStr);
              } else
                r += this.processTextOrObjNode(c, i, t);
            else if (this.options.oneListGroup) {
              let h = this.options.tagValueProcessor(i, c);
              h = this.replaceEntitiesValue(h), r += h;
            } else
              r += this.buildTextValNode(c, i, "", t);
        }
        this.options.oneListGroup && (r = this.buildObjectNode(r, i, o, t)), s += r;
      } else if (this.options.attributesGroupName && i === this.options.attributesGroupName) {
        const n = Object.keys(l[i]), r = n.length;
        for (let o = 0; o < r; o++)
          e += this.buildAttrPairStr(n[o], "" + l[i][n[o]]);
      } else
        s += this.processTextOrObjNode(l[i], i, t);
  return { attrStr: e, val: s };
};
es.prototype.buildAttrPairStr = function(l, t) {
  return t = this.options.attributeValueProcessor(l, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + l : " " + l + '="' + t + '"';
};
function md(l, t, e) {
  const s = this.j2x(l, e + 1);
  return l[this.options.textNodeName] !== void 0 && Object.keys(l).length === 1 ? this.buildTextValNode(l[this.options.textNodeName], t, s.attrStr, e) : this.buildObjectNode(s.val, t, s.attrStr, e);
}
es.prototype.buildObjectNode = function(l, t, e, s) {
  if (l === "")
    return t[0] === "?" ? this.indentate(s) + "<" + t + e + "?" + this.tagEndChar : this.indentate(s) + "<" + t + e + this.closeTag(t) + this.tagEndChar;
  {
    let i = "</" + t + this.tagEndChar, n = "";
    return t[0] === "?" && (n = "?", i = ""), (e || e === "") && l.indexOf("<") === -1 ? this.indentate(s) + "<" + t + e + n + ">" + l + i : this.options.commentPropName !== !1 && t === this.options.commentPropName && n.length === 0 ? this.indentate(s) + `<!--${l}-->` + this.newLine : this.indentate(s) + "<" + t + e + n + this.tagEndChar + l + this.indentate(s) + i;
  }
};
es.prototype.closeTag = function(l) {
  let t = "";
  return this.options.unpairedTags.indexOf(l) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${l}`, t;
};
es.prototype.buildTextValNode = function(l, t, e, s) {
  if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
    return this.indentate(s) + `<![CDATA[${l}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && t === this.options.commentPropName)
    return this.indentate(s) + `<!--${l}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(s) + "<" + t + e + "?" + this.tagEndChar;
  {
    let i = this.options.tagValueProcessor(t, l);
    return i = this.replaceEntitiesValue(i), i === "" ? this.indentate(s) + "<" + t + e + this.closeTag(t) + this.tagEndChar : this.indentate(s) + "<" + t + e + ">" + i + "</" + t + this.tagEndChar;
  }
};
es.prototype.replaceEntitiesValue = function(l) {
  if (l && l.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const e = this.options.entities[t];
      l = l.replace(e.regex, e.val);
    }
  return l;
};
function Id(l) {
  return this.options.indentBy.repeat(l);
}
function Ed(l) {
  return l.startsWith(this.options.attributeNamePrefix) && l !== this.options.textNodeName ? l.substr(this.attrPrefixLen) : !1;
}
var gd = es;
const Cd = ao, Td = ad, yd = gd;
var _l = {
  XMLParser: Td,
  XMLValidator: Cd,
  XMLBuilder: yd
};
class Hr {
  /**
   * Constructs a new BCF Topic Comment instance.
   * @param components - The Components instance.
   * @param text - The initial comment text.
   */
  constructor(t, e) {
    y(this, "date", /* @__PURE__ */ new Date()), y(this, "author"), y(this, "guid", zt.create()), y(this, "viewpoint"), y(this, "modifiedAuthor"), y(this, "modifiedDate"), y(this, "topic"), y(this, "_components"), y(this, "_comment", ""), this._components = t, this._comment = e;
    const s = this._components.get(Xe);
    this.author = s.config.author;
  }
  /**
   * Sets the comment text and updates the modified date and author.
   * The author will be the one defined in BCFTopics.config.author
   * @param value - The new comment text.
   */
  set comment(t) {
    var e;
    const s = this._components.get(Xe);
    this._comment = t, this.modifiedDate = /* @__PURE__ */ new Date(), this.modifiedAuthor = s.config.author, (e = this.topic) == null || e.comments.set(this.guid, this);
  }
  /**
   * Gets the comment text.
   * @returns The comment text.
   */
  get comment() {
    return this._comment;
  }
  /**
   * Serializes the Comment instance into a BCF compliant XML string.
   *
   * @returns A string representing the Comment in BCFv2 XML format.
   */
  serialize() {
    let t = null;
    this.viewpoint && (t = `<Viewpoint Guid="${this.viewpoint.guid}"/>`);
    let e = null;
    this.modifiedDate && (e = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`);
    let s = null;
    return this.modifiedAuthor && (s = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`), `
      <Comment Guid="${this.guid}">
        <Date>${this.date.toISOString()}</Date>
        <Author>${this.author}</Author>
        <Comment>${this.comment}</Comment>
        ${t ?? ""}
        ${s ?? ""}
        ${e ?? ""}
      </Comment>
    `;
  }
}
const Ul = class Xt {
  /**
   * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
   * It provides methods and properties to manage and serialize BCF topics.
   *
   * @remarks
   * The default creationUser is the one set in BCFTopics.config.author
   * It should not be created manually. Better use BCFTopics.create().
   *
   * @param components - The `Components` instance that provides access to other components and services.
   */
  constructor(t) {
    y(this, "guid", zt.create()), y(this, "title", Xt.default.title), y(this, "creationDate", /* @__PURE__ */ new Date()), y(this, "creationAuthor", ""), y(this, "viewpoints", new qt()), y(this, "relatedTopics", new qt()), y(this, "comments", new mt()), y(this, "customData", {}), y(this, "description"), y(this, "serverAssignedId"), y(this, "dueDate"), y(this, "modifiedAuthor"), y(this, "modifiedDate"), y(this, "index"), y(this, "_type", Xt.default.type), y(this, "_status", Xt.default.status), y(this, "_priority", Xt.default.priority), y(this, "_stage", Xt.default.stage), y(this, "_assignedTo", Xt.default.assignedTo), y(this, "_labels", Xt.default.labels ?? /* @__PURE__ */ new Set()), y(this, "_components"), this._components = t;
    const e = t.get(Xe);
    this.creationAuthor = e.config.author, this.relatedTopics.guard = (s) => s !== this.guid;
  }
  set type(t) {
    const e = this._components.get(Xe), { strict: s, types: i } = e.config;
    (!s || i.has(t)) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  set status(t) {
    const e = this._components.get(Xe), { strict: s, statuses: i } = e.config;
    (!s || i.has(t)) && (this._status = t);
  }
  get status() {
    return this._status;
  }
  set priority(t) {
    const e = this._components.get(Xe);
    if (t) {
      const { strict: s, priorities: i } = e.config;
      if (!(s ? i.has(t) : !0))
        return;
      this._priority = t;
    } else
      this._priority = t;
  }
  get priority() {
    return this._priority;
  }
  set stage(t) {
    const e = this._components.get(Xe);
    if (t) {
      const { strict: s, stages: i } = e.config;
      if (!(s ? i.has(t) : !0))
        return;
      this._stage = t;
    } else
      this._stage = t;
  }
  get stage() {
    return this._stage;
  }
  set assignedTo(t) {
    const e = this._components.get(Xe);
    if (t) {
      const { strict: s, users: i } = e.config;
      if (!(s ? i.has(t) : !0))
        return;
      this._assignedTo = t;
    } else
      this._assignedTo = t;
  }
  get assignedTo() {
    return this._assignedTo;
  }
  set labels(t) {
    const e = this._components.get(Xe), { strict: s, labels: i } = e.config;
    if (s) {
      const n = /* @__PURE__ */ new Set();
      for (const r of t)
        (!s || i.has(r)) && n.add(r);
      this._labels = n;
    } else
      this._labels = t;
  }
  get labels() {
    return this._labels;
  }
  get _managerVersion() {
    return this._components.get(Xe).config.version;
  }
  /**
   * Sets properties of the BCF Topic based on the provided data.
   *
   * @remarks
   * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
   * It skips the `guid` property as it should not be modified.
   *
   * @param data - An object containing the properties to be updated.
   * @returns The topic
   *
   * @example
   * ```typescript
   * const topic = new Topic(components);
   * topic.set({
   *   title: "New BCF Topic Title",
   *   description: "This is a new description.",
   *   status: "Resolved",
   * });
   * ```
   */
  set(t) {
    const e = t, s = this;
    for (const n in t) {
      if (n === "guid")
        continue;
      const r = e[n];
      n in this && (s[n] = r);
    }
    return this._components.get(Xe).list.set(this.guid, this), this;
  }
  /**
   * Creates a new comment associated with the current topic.
   *
   * @param text - The text content of the comment.
   * @param viewpoint - (Optional) The viewpoint associated with the comment.
   *
   * @returns The newly created comment.
   *
   * @example
   * ```typescript
   * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
   * const topic = topics.create(); // Created with an instance of BCFTopics
   * topic.viewpoints.add(viewpoint);
   * const comment = topic.createComment("This is a new comment", viewpoint);
   * ```
   */
  createComment(t, e) {
    const s = new Hr(this._components, t);
    return s.viewpoint = e, s.topic = this, this.comments.set(s.guid, s), s;
  }
  createLabelTags(t = this._managerVersion) {
    let e = "Labels";
    t === "2.1" && (e = "Labels"), t === "3" && (e = "Label");
    let s = [...this.labels].map((i) => `<${e}>${i}</${e}>`).join(`
`);
    for (const i in this.customData) {
      const n = this.customData[i];
      typeof n == "string" && (s += `
<${e}>${n}</${e}>`);
    }
    return t === "2.1" ? s : t === "3" ? s.length !== 0 ? `<Labels>
${s}
</Labels>` : "<Labels/>" : s;
  }
  createCommentTags(t = this._managerVersion) {
    const e = [...this.comments.values()].map((s) => s.serialize()).join(`
`);
    return t === "2.1" ? e : t === "3" ? e.length !== 0 ? `<Comments>
${e}
</Comments>` : "<Comments/>" : e;
  }
  createViewpointTags(t = this._managerVersion) {
    let e = "Viewpoints";
    t === "2.1" && (e = "Viewpoints"), t === "3" && (e = "ViewPoint");
    const s = this._components.get(Dt), n = [...this.viewpoints].map((r) => s.list.get(r)).filter((r) => r).map((r) => `<${e} Guid="${r.guid}">
          <Viewpoint>${r.guid}.bcfv</Viewpoint>
          <Snapshot>${r.guid}.jpeg</Snapshot>
        </${e}>
      `).join(`
`);
    return t === "2.1" ? n : t === "3" ? n.length !== 0 ? `<Viewpoints>
${n}
</Viewpoints>` : "<Viewpoints />" : n;
  }
  createRelatedTopicTags(t = this._managerVersion) {
    const e = [...this.relatedTopics].map(
      (s) => `<RelatedTopic Guid="${s}"></RelatedTopic>
      `
    ).join(`
`);
    return t === "2.1" ? e : t === "3" ? e.length !== 0 ? `<RelatedTopics>
${e}
</RelatedTopics>` : "<RelatedTopics />" : e;
  }
  /**
   * Serializes the BCF Topic instance into an XML string representation based on the official schema.
   *
   * @remarks
   * This method constructs an XML string based on the properties of the BCF Topic instance.
   * It includes the topic's guid, type, status, creation date, creation author, priority, index,
   * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
   * comments, and viewpoints.
   *
   * @returns A string representing the XML serialization of the BCF Topic.
   *
   * @example
   * ```typescript
   * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
   * const xml = topic.serialize();
   * console.log(xml);
   * ```
   */
  serialize() {
    const t = this._managerVersion;
    let e = null;
    this.serverAssignedId && (e = `ServerAssignedId="${this.serverAssignedId}"`);
    let s = null;
    this.priority && (s = `<Priority>${this.priority}</Priority>`);
    let i = null;
    this.index && t === "2.1" && (i = `<Index>${this.index}</Index>`);
    let n = null;
    this.modifiedDate && (n = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`);
    let r = null;
    this.modifiedAuthor && (r = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`);
    let o = null;
    this.dueDate && (o = `<DueDate>${this.dueDate.toISOString()}</DueDate>`);
    let a = null;
    this.assignedTo && (a = `<AssignedTo>${this.assignedTo}</AssignedTo>`);
    let c = null;
    this.description && (c = `<Description>${this.description}</Description>`);
    let h = null;
    this.stage && (h = `<Stage>${this.stage}</Stage>`);
    const f = this.createCommentTags(t), u = this.createViewpointTags(t), d = this.createLabelTags(t), p = this.createRelatedTopicTags(t);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Markup>
        <Topic Guid="${this.guid}" TopicType="${this.type}" TopicStatus="${this.status}" ${e ?? ""}>
          <Title>${this.title}</Title>
          <CreationDate>${this.creationDate.toISOString()}</CreationDate>
          <CreationAuthor>${this.creationAuthor}</CreationAuthor>
          ${s ?? ""}
          ${i ?? ""}
          ${n ?? ""}
          ${r ?? ""}
          ${o ?? ""}
          ${a ?? ""}
          ${c ?? ""}
          ${h ?? ""}
          ${d}
          ${p}
          ${t === "3" ? f : ""}
          ${t === "3" ? u : ""}
        </Topic>
        ${t === "2.1" ? f : ""}
        ${t === "2.1" ? u : ""}
      </Markup>
    `;
  }
};
y(Ul, "default", {
  title: "BCF Topic",
  type: "Issue",
  status: "Active"
});
let ua = Ul;
const Rd = (l, t) => {
  if (t.trim() === "")
    return;
  const e = Xe.xmlParser.parse(t).Extensions;
  if (!e)
    return;
  const { Priorities: s, TopicStatuses: i, TopicTypes: n, Users: r } = e;
  if (s && s.Priority) {
    const o = Array.isArray(s.Priority) ? s.Priority : [s.Priority];
    for (const a of o)
      l.config.priorities.add(a);
  }
  if (i && i.TopicStatus) {
    const o = Array.isArray(i.TopicStatus) ? i.TopicStatus : [i.TopicStatus];
    for (const a of o)
      l.config.statuses.add(a);
  }
  if (n && n.TopicType) {
    const o = Array.isArray(n.TopicType) ? n.TopicType : [n.TopicType];
    for (const a of o)
      l.config.types.add(a);
  }
  if (r && r.User) {
    const o = Array.isArray(r.User) ? r.User : [r.User];
    for (const a of o)
      l.config.users.add(a);
  }
};
class Sd extends zs {
  constructor() {
    super(...arguments), y(this, "_config", {
      version: {
        type: "Select",
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        multiple: !1,
        value: ""
      },
      author: {
        type: "Text",
        value: ""
      },
      types: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      statuses: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      priorities: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      labels: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      stages: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      users: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      includeSelectionTag: {
        type: "Boolean",
        value: !1
      },
      updateExtensionsOnImport: {
        type: "Boolean",
        value: !1
      },
      strict: {
        type: "Boolean",
        value: !1
      },
      includeAllExtensionsOnExport: {
        type: "Boolean",
        value: !1
      },
      fallbackVersionOnImport: {
        type: "Select",
        multiple: !1,
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        value: ""
      },
      ignoreIncompleteTopicsOnImport: {
        type: "Boolean",
        value: !1
      }
    });
  }
  get version() {
    return this._config.version.value;
  }
  set version(t) {
    this._config.version.value = t;
  }
  get author() {
    return this._config.author.value;
  }
  set author(t) {
    this._config.author.value = t;
  }
  get types() {
    return this._config.types.value;
  }
  set types(t) {
    this._config.types.value = t;
  }
  get statuses() {
    return this._config.statuses.value;
  }
  set statuses(t) {
    this._config.statuses.value = t;
  }
  get priorities() {
    return this._config.priorities.value;
  }
  set priorities(t) {
    this._config.priorities.value = t;
  }
  get labels() {
    return this._config.labels.value;
  }
  set labels(t) {
    this._config.labels.value = t;
  }
  get stages() {
    return this._config.stages.value;
  }
  set stages(t) {
    this._config.stages.value = t;
  }
  get users() {
    return this._config.users.value;
  }
  set users(t) {
    this._config.users.value = t;
  }
  get includeSelectionTag() {
    return this._config.includeSelectionTag.value;
  }
  set includeSelectionTag(t) {
    this._config.includeSelectionTag.value = t;
  }
  get updateExtensionsOnImport() {
    return this._config.updateExtensionsOnImport.value;
  }
  set updateExtensionsOnImport(t) {
    this._config.updateExtensionsOnImport.value = t;
  }
  get strict() {
    return this._config.strict.value;
  }
  set strict(t) {
    this._config.strict.value = t;
  }
  get includeAllExtensionsOnExport() {
    return this._config.includeAllExtensionsOnExport.value;
  }
  set includeAllExtensionsOnExport(t) {
    this._config.includeAllExtensionsOnExport.value = t;
  }
  get fallbackVersionOnImport() {
    return this._config.fallbackVersionOnImport.value;
  }
  set fallbackVersionOnImport(t) {
    this._config.fallbackVersionOnImport.value = t;
  }
  get ignoreIncompleteTopicsOnImport() {
    return this._config.ignoreIncompleteTopicsOnImport.value;
  }
  set ignoreIncompleteTopicsOnImport(t) {
    this._config.ignoreIncompleteTopicsOnImport.value = t;
  }
}
const ho = class hi extends ue {
  constructor() {
    super(...arguments), y(this, "enabled", !1), y(this, "_defaultConfig", {
      author: "jhon.doe@example.com",
      version: "2.1",
      types: /* @__PURE__ */ new Set([
        "Clash",
        "Failure",
        "Fault",
        "Inquiry",
        "Issue",
        "Remark",
        "Request"
      ]),
      statuses: /* @__PURE__ */ new Set(["Active", "In Progress", "Done", "In Review", "Closed"]),
      priorities: /* @__PURE__ */ new Set(["On hold", "Minor", "Normal", "Major", "Critical"]),
      labels: /* @__PURE__ */ new Set(),
      stages: /* @__PURE__ */ new Set(),
      users: /* @__PURE__ */ new Set(),
      includeSelectionTag: !1,
      updateExtensionsOnImport: !0,
      strict: !1,
      includeAllExtensionsOnExport: !0,
      fallbackVersionOnImport: "2.1",
      ignoreIncompleteTopicsOnImport: !1
    }), y(this, "config", new Sd(
      this,
      this.components,
      "BCF Topics",
      hi.uuid
    )), y(this, "list", new mt()), y(this, "onSetup", new Y()), y(this, "isSetup", !1), y(this, "onBCFImported", new Y()), y(this, "onDisposed", new Y());
  }
  setup(t) {
    if (this.isSetup)
      return;
    const e = { ...this._defaultConfig, ...t };
    this.config.version = e.version, this.config.author = e.author, this.config.types = e.types, this.config.statuses = e.statuses, this.config.priorities = e.priorities, this.config.labels = e.labels, this.config.stages = e.stages, this.config.users = e.users, this.config.includeSelectionTag = e.includeSelectionTag, this.config.updateExtensionsOnImport = e.updateExtensionsOnImport, this.config.strict = e.strict, this.config.includeAllExtensionsOnExport = e.includeAllExtensionsOnExport, this.config.fallbackVersionOnImport = e.fallbackVersionOnImport || "", this.config.ignoreIncompleteTopicsOnImport = e.ignoreIncompleteTopicsOnImport, this.isSetup = !0, this.enabled = !0, this.onSetup.trigger();
  }
  /**
   * Creates a new BCFTopic instance and adds it to the list.
   *
   * @param data - Optional partial BCFTopic object to initialize the new topic with.
   * If not provided, default values will be used.
   * @returns The newly created BCFTopic instance.
   */
  create(t) {
    const e = new ua(this.components);
    return t ? (e.guid = t.guid ?? e.guid, e.set(t)) : this.list.set(e.guid, e), e;
  }
  /**
   * Disposes of the BCFTopics component and triggers the onDisposed event.
   *
   * @remarks
   * This method clears the list of topics and triggers the onDisposed event.
   * It also resets the onDisposed event listener.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Retrieves the unique set of topic types used across all topics.
   *
   * @returns A Set containing the unique topic types.
   */
  get usedTypes() {
    const t = [...this.list].map(([e, s]) => s.type);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic statuses used across all topics.
   *
   * @returns A Set containing the unique topic statuses.
   */
  get usedStatuses() {
    const t = [...this.list].map(([e, s]) => s.status);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic priorities used across all topics.
   *
   * @returns A Set containing the unique topic priorities.
   * Note: This method filters out any null or undefined priorities.
   */
  get usedPriorities() {
    const t = [...this.list].map(([e, s]) => s.priority).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic stages used across all topics.
   *
   * @returns A Set containing the unique topic stages.
   * Note: This method filters out any null or undefined stages.
   */
  get usedStages() {
    const t = [...this.list].map(([e, s]) => s.stage).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of users associated with topics.
   *
   * @returns A Set containing the unique users.
   * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
   */
  get usedUsers() {
    const t = [];
    for (const [e, s] of this.list) {
      t.push(s.creationAuthor), s.assignedTo && t.push(s.assignedTo), s.modifiedAuthor && t.push(s.modifiedAuthor);
      for (const [i, n] of s.comments)
        t.push(n.author), n.modifiedAuthor && t.push(n.modifiedAuthor);
    }
    return new Set(t);
  }
  /**
   * Retrieves the unique set of labels used across all topics.
   *
   * @returns A Set containing the unique labels.
   */
  get usedLabels() {
    const t = [];
    for (const [e, s] of this.list)
      t.push(...s.labels);
    return new Set(t);
  }
  /**
   * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
   * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
   */
  updateExtensions() {
    for (const [t, e] of this.list) {
      for (const s of e.labels)
        this.config.labels.add(s);
      this.config.types.add(e.type), e.priority && this.config.priorities.add(e.priority), e.stage && this.config.stages.add(e.stage), this.config.statuses.add(e.status), this.config.users.add(e.creationAuthor), e.assignedTo && this.config.users.add(e.assignedTo), e.modifiedAuthor && this.config.users.add(e.modifiedAuthor);
      for (const [s, i] of e.comments)
        this.config.users.add(i.author), i.modifiedAuthor && this.config.users.add(i.modifiedAuthor);
    }
  }
  /**
   * Updates the references to viewpoints in the topics.
   * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
   * If a viewpoint does not exist, it is removed from the topic's viewpoints.
   */
  updateViewpointReferences() {
    const t = this.components.get(Dt);
    for (const [e, s] of this.list)
      for (const i of s.viewpoints)
        t.list.has(i) || s.viewpoints.delete(i);
  }
  /**
   * Exports the given topics to a BCF (Building Collaboration Format) zip file.
   *
   * @param topics - The topics to export. Defaults to all topics in the list.
   * @returns A promise that resolves to a Blob containing the exported BCF zip file.
   */
  async export(t = this.list.values()) {
    const e = new ra();
    e.file(
      "bcf.version",
      `<?xml version="1.0" encoding="UTF-8"?>
    <Version VersionId="${this.config.version}" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/buildingSMART/BCF-XML/release_3_0/Schemas/version.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    </Version>`
    ), e.file("bcf.extensions", this.serializeExtensions());
    const i = await (await fetch(
      "https://thatopen.github.io/engine_components/resources/favicon.ico"
    )).arrayBuffer(), n = this.components.get(Dt);
    for (const o of t) {
      const a = e.folder(o.guid);
      a.file("markup.bcf", o.serialize());
      for (const c of o.viewpoints) {
        const h = n.list.get(c);
        h && (a.file(`${c}.jpeg`, i, {
          binary: !0
        }), a.file(`${c}.bcfv`, await h.serialize()));
      }
    }
    return await e.generateAsync({ type: "blob" });
  }
  serializeExtensions() {
    const t = [...this.config.types].map((o) => `<TopicType>${o}</TopicType>`).join(`
`), e = [...this.config.statuses].map((o) => `<TopicStatus>${o}</TopicStatus>`).join(`
`), s = [...this.config.priorities].map((o) => `<Priority>${o}</Priority>`).join(`
`), i = [...this.config.labels].map((o) => `<TopicLabel>${o}</TopicLabel>`).join(`
`), n = [...this.config.stages].map((o) => `<Stage>${o}</Stage>`).join(`
`), r = [...this.config.users].map((o) => `<User>${o}</User>`).join(`
`);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Extensions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="your-schema-location.xsd">
        ${t.length !== 0 ? `<TopicTypes>
${t}
</TopicTypes>` : ""}
        ${e.length !== 0 ? `<TopicStatuses>
${e}
</TopicStatuses>` : ""}
        ${s.length !== 0 ? `<Priorities>
${s}
</Priorities>` : ""}
        ${i.length !== 0 ? `<TopicLabels>
${i}
</TopicLabels>` : ""}
        ${n.length !== 0 ? `<Stages>
${n}
</Stages>` : ""}
        ${r.length !== 0 ? `<Users>
${r}
</Users>` : ""}
      </Extensions>
    `;
  }
  processMarkupComment(t) {
    const {
      Guid: e,
      Date: s,
      Author: i,
      Comment: n,
      Viewpoint: r
    } = t;
    if (!(e && s && i && Hr))
      return null;
    const o = this.components.get(Dt), a = new Hr(this.components, n ?? "");
    return a.guid = e, a.date = new Date(s), a.author = i, a.viewpoint = r != null && r.Guid ? o.list.get(r.Guid) : void 0, a.modifiedAuthor = t.ModifiedAuthor, a.modifiedDate = t.ModifiedDate ? new Date(t.ModifiedDate) : void 0, a;
  }
  getMarkupComments(t, e) {
    var s;
    let i;
    if (e === "2.1" && (i = t.Comment), e === "3" && (i = (s = t.Topic.Comments) == null ? void 0 : s.Comment), !i)
      return [];
    i = Array.isArray(i) ? i : [i];
    const n = i.map((o) => this.processMarkupComment(o)).filter((o) => o);
    return Array.isArray(n) ? n : [n];
  }
  getMarkupLabels(t, e) {
    var s;
    let i;
    return e === "2.1" && (i = t.Topic.Labels), e === "3" && (i = (s = t.Topic.Labels) == null ? void 0 : s.Label), i ? Array.isArray(i) ? i : [i] : [];
  }
  getMarkupViewpoints(t, e) {
    var s;
    let i;
    return e === "2.1" && (i = t.Viewpoints), e === "3" && (i = (s = t.Topic.Viewpoints) == null ? void 0 : s.ViewPoint), i ? (i = Array.isArray(i) ? i : [i], i) : [];
  }
  getMarkupRelatedTopics(t, e) {
    var s;
    let i;
    return e === "2.1" && (i = t.Topic.RelatedTopic), e === "3" && (i = (s = t.Topic.RelatedTopics) == null ? void 0 : s.RelatedTopic), i ? (Array.isArray(i) ? i : [i]).map((r) => r.Guid) : [];
  }
  /**
   * Loads BCF (Building Collaboration Format) data into the engine.
   *
   * @param world - The default world where the viewpoints are going to be created.
   * @param data - The BCF data to load.
   *
   * @returns A promise that resolves to an object containing the created viewpoints and topics.
   *
   * @throws An error if the BCF version is not supported.
   */
  async load(t, e) {
    var s;
    const {
      fallbackVersionOnImport: i,
      ignoreIncompleteTopicsOnImport: n,
      updateExtensionsOnImport: r
    } = this.config, o = new ra();
    await o.loadAsync(t);
    const a = Object.values(o.files);
    let c = i;
    const h = a.find((g) => g.name.endsWith(".version"));
    if (h) {
      const g = await h.async("string"), T = hi.xmlParser.parse(g).Version.VersionId;
      c = String(T);
    }
    if (!(c && (c === "2.1" || c === "3")))
      throw new Error(`BCFTopics: ${c} is not supported.`);
    const f = a.find(
      (g) => g.name.endsWith(".extensions")
    );
    if (r && f) {
      const g = await f.async("string");
      Rd(this, g);
    }
    const u = [], d = this.components.get(Dt), p = a.filter((g) => g.name.endsWith(".bcfv"));
    for (const g of p) {
      const T = await g.async("string"), C = hi.xmlParser.parse(T).VisualizationInfo;
      if (!C) {
        console.warn("Missing VisualizationInfo in Viewpoint");
        continue;
      }
      const F = {}, {
        Guid: O,
        ClippingPlanes: P,
        Components: M,
        OrthogonalCamera: L,
        PerspectiveCamera: b
      } = C;
      if (O && (F.guid = O), M) {
        const { Selection: v, Visibility: D } = M;
        if (v && v.Component) {
          const _ = Array.isArray(v.Component) ? v.Component : [v.Component];
          F.selectionComponents = _.map((K) => K.IfcGuid).filter((K) => K);
        }
        if (D && "DefaultVisibility" in D && (F.defaultVisibility = D.DefaultVisibility), D && D.Exceptions && "Component" in D.Exceptions) {
          const { Component: _ } = D.Exceptions, K = Array.isArray(_) ? _ : [_];
          F.exceptionComponents = K.map((U) => U.IfcGuid).filter((U) => U);
        }
        let R;
        c === "2.1" && (R = M.ViewSetupHints), c === "3" && (R = (s = M.Visibility) == null ? void 0 : s.ViewSetupHints), R && ("OpeningsVisible" in R && (F.openingsVisible = R.OpeningsVisible), "SpacesVisible" in R && (F.spacesVisible = R.SpacesVisible), "SpaceBoundariesVisible" in R && (F.spaceBoundariesVisible = R.SpaceBoundariesVisible));
      }
      if (L || b) {
        const v = C.PerspectiveCamera ?? C.OrthogonalCamera, { CameraViewPoint: D, CameraDirection: R } = v, _ = new A.Vector3(
          Number(D.X),
          Number(D.Z),
          Number(-D.Y)
        ), K = new A.Vector3(
          Number(R.X),
          Number(R.Z),
          Number(-R.Y)
        ), U = {
          position: { x: _.x, y: _.y, z: _.z },
          direction: { x: K.x, y: K.y, z: K.z },
          aspectRatio: "AspectRatio" in v ? v.AspectRatio : 1
          // Temporal simplification
        };
        "ViewToWorldScale" in v && (F.camera = {
          ...U,
          viewToWorldScale: v.ViewToWorldScale
        }), "FieldOfView" in v && (F.camera = {
          ...U,
          fov: v.FieldOfView
        });
      }
      const B = new $l(this.components, e, {
        data: F,
        setCamera: !1
      });
      if (M) {
        const { Coloring: v } = M;
        if (v && v.Color) {
          const D = Array.isArray(v.Color) ? v.Color : [v.Color];
          for (const R of D) {
            const { Color: _, Component: K } = R, Z = (Array.isArray(K) ? K : [K]).map((H) => H.IfcGuid);
            B.componentColors.set(_, Z);
          }
        }
      }
      if (u.push(B), P) {
        const v = this.components.get(Bs), D = Array.isArray(P.ClippingPlane) ? P.ClippingPlane : [P.ClippingPlane];
        for (const R of D) {
          const { Location: _, Direction: K } = R;
          if (!(_ && K))
            continue;
          const U = new A.Vector3(
            _.X,
            _.Z,
            -_.Y
          ), Z = new A.Vector3(
            K.X,
            -K.Z,
            K.Y
          ), H = v.createFromNormalAndCoplanarPoint(
            e,
            Z,
            U
          );
          H.visible = !1, H.enabled = !1, B.clippingPlanes.add(H);
        }
      }
    }
    const m = {}, E = [], I = a.filter((g) => g.name.endsWith(".bcf"));
    for (const g of I) {
      const T = await g.async("string"), C = hi.xmlParser.parse(T).Markup, F = C.Topic, {
        Guid: O,
        TopicType: P,
        TopicStatus: M,
        Title: L,
        CreationDate: b,
        CreationAuthor: B
      } = F;
      if (n && !(O && P && M && L && b && B))
        continue;
      const v = new ua(this.components);
      v.guid = O ?? v.guid;
      const D = this.getMarkupRelatedTopics(C, c);
      m[v.guid] = new Set(D), v.type = P ?? v.type, v.status = M ?? v.status, v.title = L ?? v.title, v.creationDate = b ? new Date(b) : v.creationDate, v.creationAuthor = B ?? v.creationAuthor, v.serverAssignedId = F.ServerAssignedId, v.priority = F.Priority, v.index = F.Index, v.modifiedDate = F.ModifiedDate ? new Date(F.ModifiedDate) : void 0, v.modifiedAuthor = F.ModifiedAuthor, v.dueDate = F.DueDate ? new Date(F.DueDate) : void 0, v.assignedTo = F.AssignedTo, v.description = F.Description, v.stage = F.Stage;
      const R = this.getMarkupLabels(C, c);
      for (const U of R)
        v.labels.add(U);
      const _ = this.getMarkupComments(C, c);
      for (const U of _)
        v.comments.set(U.guid, U);
      const K = this.getMarkupViewpoints(C, c);
      for (const U of K) {
        if (!(U && U.Guid))
          continue;
        const Z = d.list.get(U.Guid);
        Z && v.viewpoints.add(Z.guid);
      }
      this.list.set(v.guid, v), E.push(v);
    }
    for (const g in m) {
      const T = this.list.get(g);
      if (!T)
        continue;
      const C = m[g];
      for (const F of C)
        T.relatedTopics.add(F);
    }
    return this.onBCFImported.trigger(E), { viewpoints: u, topics: E };
  }
};
y(ho, "uuid", "de977976-e4f6-4e4f-a01a-204727839802");
y(ho, "xmlParser", new _l.XMLParser({
  allowBooleanAttributes: !0,
  attributeNamePrefix: "",
  ignoreAttributes: !1,
  ignoreDeclaration: !0,
  ignorePiTags: !0,
  numberParseOptions: { leadingZeros: !0, hex: !0 },
  parseAttributeValue: !0,
  preserveOrder: !1,
  processEntities: !1,
  removeNSPrefix: !0,
  trimValues: !0
}));
let Xe = ho;
const Bl = class xt extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), y(this, "onDisposed", new Y()), y(this, "_absoluteMin"), y(this, "_absoluteMax"), y(this, "_meshes", []), this.components.add(xt.uuid, this), this._absoluteMin = xt.newBound(!0), this._absoluteMax = xt.newBound(!1);
  }
  /**
   * A static method to calculate the dimensions of a given bounding box.
   *
   * @param bbox - The bounding box to calculate the dimensions for.
   * @returns An object containing the width, height, depth, and center of the bounding box.
   */
  static getDimensions(t) {
    const { min: e, max: s } = t, i = Math.abs(s.x - e.x), n = Math.abs(s.y - e.y), r = Math.abs(s.z - e.z), o = new A.Vector3();
    return o.subVectors(s, e).divideScalar(2).add(e), { width: i, height: n, depth: r, center: o };
  }
  /**
   * A static method to create a new bounding box boundary.
   *
   * @param positive - A boolean indicating whether to create a boundary for positive or negative values.
   * @returns A new THREE.Vector3 representing the boundary.
   *
   * @remarks
   * This method is used to create a new boundary for calculating bounding boxes.
   * It sets the x, y, and z components of the returned vector to positive or negative infinity,
   * depending on the value of the `positive` parameter.
   *
   * @example
   * ```typescript
   * const positiveBound = BoundingBoxer.newBound(true);
   * console.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }
   *
   * const negativeBound = BoundingBoxer.newBound(false);
   * console.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }
   * ```
   */
  static newBound(t) {
    const e = t ? 1 : -1;
    return new A.Vector3(
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE
    );
  }
  /**
   * A static method to calculate the bounding box of a set of points.
   *
   * @param points - An array of THREE.Vector3 representing the points.
   * @param min - An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated.
   * @param max - An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated.
   * @returns A THREE.Box3 representing the bounding box of the given points.
   *
   * @remarks
   * This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.
   * If the `min` or `max` parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity.
   *
   * @example
   * ```typescript
   * const points = [
   *   new THREE.Vector3(1, 2, 3),
   *   new THREE.Vector3(4, 5, 6),
   *   new THREE.Vector3(7, 8, 9),
   * ];
   *
   * const bbox = BoundingBoxer.getBounds(points);
   * console.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }
   * ```
   */
  static getBounds(t, e, s) {
    const i = s || this.newBound(!1), n = e || this.newBound(!0);
    for (const r of t)
      r.x < n.x && (n.x = r.x), r.y < n.y && (n.y = r.y), r.z < n.z && (n.z = r.z), r.x > i.x && (i.x = r.x), r.y > i.y && (i.y = r.y), r.z > i.z && (i.z = r.z);
    return new A.Box3(e, s);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(Ot);
    for (const e of this._meshes)
      t.destroy(e);
    this._meshes = [], this.onDisposed.trigger(xt.uuid), this.onDisposed.reset();
  }
  /**
   * Returns the bounding box of the calculated fragments.
   *
   * @returns A new THREE.Box3 instance representing the bounding box.
   *
   * @remarks
   * This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.
   * The returned box represents the bounding box of the calculated fragments.
   *
   * @example
   * ```typescript
   * const boundingBox = boundingBoxer.get();
   * console.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }
   * ```
   */
  get() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone();
    return new A.Box3(t, e);
  }
  /**
   * Calculates and returns a sphere that encompasses the entire bounding box.
   *
   * @returns A new THREE.Sphere instance representing the calculated sphere.
   *
   * @remarks
   * This method calculates the center and radius of a sphere that encompasses the entire bounding box.
   * The center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.
   * The radius is calculated as the distance from the center to the minimum bound.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingSphere = boundingBoxer.getSphere();
   * console.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }
   * ```
   */
  getSphere() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone(), s = Math.abs((e.x - t.x) / 2), i = Math.abs((e.y - t.y) / 2), n = Math.abs((e.z - t.z) / 2), r = new A.Vector3(t.x + s, t.y + i, t.z + n), o = r.distanceTo(t);
    return new A.Sphere(r, o);
  }
  /**
   * Returns a THREE.Mesh instance representing the bounding box.
   *
   * @returns A new THREE.Mesh instance representing the bounding box.
   *
   * @remarks
   * This method calculates the dimensions of the bounding box using the `getDimensions` method.
   * It then creates a new THREE.BoxGeometry with the calculated dimensions.
   * A new THREE.Mesh is created using the box geometry, and it is added to the `_meshes` array.
   * The position of the mesh is set to the center of the bounding box.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingBoxMesh = boundingBoxer.getMesh();
   * scene.add(boundingBoxMesh);
   * ```
   */
  getMesh() {
    const t = new A.Box3(this._absoluteMin, this._absoluteMax), e = xt.getDimensions(t), { width: s, height: i, depth: n, center: r } = e, o = new A.BoxGeometry(s, i, n), a = new A.Mesh(o);
    return this._meshes.push(a), a.position.copy(r), a;
  }
  /**
   * Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.
   * This method is used to prepare the BoundingBoxer for a new set of fragments.
   *
   * @remarks
   * This method is called when a new set of fragments is added to the BoundingBoxer.
   * It ensures that the bounding box calculations are accurate and up-to-date.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * // ...
   * boundingBoxer.reset();
   * ```
   */
  reset() {
    this._absoluteMin = xt.newBound(!0), this._absoluteMax = xt.newBound(!1);
  }
  /**
   * Adds a FragmentsGroup to the BoundingBoxer.
   *
   * @param group - The FragmentsGroup to add.
   *
   * @remarks
   * This method iterates through each fragment in the provided FragmentsGroup,
   * and calls the `addMesh` method for each fragment's mesh.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * ```
   */
  add(t) {
    for (const e of t.items)
      this.addMesh(e.mesh);
  }
  /**
   * Adds a mesh to the BoundingBoxer and calculates the bounding box.
   *
   * @param mesh - The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh.
   * @param itemIDs - An optional iterable of numbers representing the item IDs.
   *
   * @remarks
   * This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.
   * If the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.
   * If the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.addMesh(mesh);
   * ```
   */
  addMesh(t, e) {
    if (!t.geometry.index)
      return;
    const s = xt.getFragmentBounds(t);
    t.updateMatrixWorld();
    const i = t.matrixWorld, n = new A.Matrix4(), r = t instanceof A.InstancedMesh, o = /* @__PURE__ */ new Set();
    if (t instanceof Pe.FragmentMesh) {
      e || (e = t.fragment.ids);
      for (const a of e) {
        const c = t.fragment.getInstancesIDs(a);
        if (c)
          for (const h of c)
            o.add(h);
      }
    } else
      o.add(0);
    for (const a of o) {
      const c = s.min.clone(), h = s.max.clone();
      r && (t.getMatrixAt(a, n), c.applyMatrix4(n), h.applyMatrix4(n)), c.applyMatrix4(i), h.applyMatrix4(i), c.x < this._absoluteMin.x && (this._absoluteMin.x = c.x), c.y < this._absoluteMin.y && (this._absoluteMin.y = c.y), c.z < this._absoluteMin.z && (this._absoluteMin.z = c.z), c.x > this._absoluteMax.x && (this._absoluteMax.x = c.x), c.y > this._absoluteMax.y && (this._absoluteMax.y = c.y), c.z > this._absoluteMax.z && (this._absoluteMax.z = c.z), h.x > this._absoluteMax.x && (this._absoluteMax.x = h.x), h.y > this._absoluteMax.y && (this._absoluteMax.y = h.y), h.z > this._absoluteMax.z && (this._absoluteMax.z = h.z), h.x < this._absoluteMin.x && (this._absoluteMin.x = h.x), h.y < this._absoluteMin.y && (this._absoluteMin.y = h.y), h.z < this._absoluteMin.z && (this._absoluteMin.z = h.z);
    }
  }
  /**
   * Uses a FragmentIdMap to add its meshes to the bb calculation.
   *
   * This method iterates through the provided `fragmentIdMap`, retrieves the corresponding fragment from the `FragmentsManager`,
   * and then calls the `addMesh` method for each fragment's mesh, passing the expression IDs as the second parameter.
   *
   * @param fragmentIdMap - A mapping of fragment IDs to their corresponding expression IDs.
   *
   * @remarks
   * This method is used to add a mapping of fragment IDs to their corresponding expression IDs.
   * It ensures that the bounding box calculations are accurate and up-to-date by updating the internal minimum and maximum vectors.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * const fragmentIdMap: FRAGS.FragmentIdMap = {
   *   '5991fa75-2eef-4825-90b3-85177f51a9c9': [123, 245, 389],
   *   '3469077e-39bf-4fc9-b3e6-4a1d78ad52b0': [454, 587, 612],
   * };
   * boundingBoxer.addFragmentIdMap(fragmentIdMap);
   * ```
   */
  addFragmentIdMap(t) {
    const e = this.components.get(fe);
    for (const s in t) {
      const i = e.list.get(s);
      if (!i)
        continue;
      const n = t[s];
      this.addMesh(i.mesh, n);
    }
  }
  static getFragmentBounds(t) {
    const e = t.geometry.attributes.position, s = Number.MAX_VALUE, i = -s, n = new A.Vector3(s, s, s), r = new A.Vector3(i, i, i);
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = Array.from(t.geometry.index.array);
    for (let a = 0; a < o.length; a++) {
      if (a % 3 === 0 && o[a] === 0 && o[a + 1] === 0 && o[a + 2] === 0) {
        a += 2;
        continue;
      }
      const c = o[a], h = e.getX(c), f = e.getY(c), u = e.getZ(c);
      h < n.x && (n.x = h), f < n.y && (n.y = f), u < n.z && (n.z = u), h > r.x && (r.x = h), f > r.y && (r.y = f), u > r.z && (r.z = u);
    }
    return new A.Box3(n, r);
  }
};
y(Bl, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
let Tn = Bl;
const Ad = class Vl extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), t.add(Vl.uuid, this);
  }
  async getIsolatedElements(t, e, s) {
    const i = /* @__PURE__ */ new Set();
    function n(a) {
      if (i.has(a))
        return;
      const c = t.GetLine(e, a);
      if (c) {
        i.add(a);
        for (const h in c) {
          const f = c[h];
          f && f.constructor.name === "Handle" && f.value > 0 ? n(f.value) : Array.isArray(f) && f.forEach((u) => {
            u && u.constructor.name === "Handle" && u.value > 0 && n(u.value);
          });
        }
      }
    }
    for (const a of s)
      n(a);
    const r = [];
    for (const a of i)
      r.push(a);
    r.sort((a, c) => a - c);
    const o = [];
    return r.forEach((a) => {
      const c = t.GetLine(e, a);
      o.push(c);
    }), o;
  }
  /**
   * Exports isolated elements to the new model.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the new IFC model.
   * @param isolatedElements The array of isolated elements
   */
  async export(t, e, s) {
    return s.forEach((n) => {
      t.WriteLine(e, n);
    }), t.SaveModel(e);
  }
  async splitIfc(t, e, s) {
    const i = new Uint8Array(e), n = t.OpenModel(i), r = await this.getIsolatedElements(
      t,
      n,
      s
    ), o = t.CreateModel({ schema: W.Schemas.IFC2X3 });
    return await this.export(t, o, r);
  }
};
y(Ad, "uuid", "6eb0ba2f-71c0-464e-bcec-2d7c335186b2");
const zl = class kl {
  constructor(t) {
    y(this, "onProgress", new Y()), y(this, "inclusive", !1), y(this, "rules", []), y(this, "ids", {}), y(this, "needsUpdate", /* @__PURE__ */ new Map()), y(this, "components"), this.components = t;
  }
  /**
   * Imports a query given its data. This data can be generating using its {@link IfcFinderQuery.export} method.
   *
   * @param components the instance of {@link Components} used by this app.
   * @param data the data of the query to import as a serializable object.
   */
  static import(t, e) {
    const s = kl.importers.get(e.type);
    return s ? s(t, e) : (console.warn("Invalid query data:.", e), null);
  }
  /**
   * Imports the given serialized rules. Only use this when writing your own custom query. See the other queries provided by the library for reference.
   *
   * @param serializedRules the rules to be parsed.
   */
  static importRules(t) {
    const e = [];
    for (const s of t) {
      const i = {};
      for (const n in s) {
        const r = s[n];
        r.regexp ? i[n] = new RegExp(r.value) : i[n] = r;
      }
      e.push(i);
    }
    return e;
  }
  /**
   * Imports the given IDs. Only use this when writing your own custom query. See the other queries provided by the library for reference.
   *
   * @param data the serialized object representing the query whose IDs to parse.
   */
  static importIds(t) {
    const e = {};
    for (const s in t.ids)
      e[s] = new Set(t.ids[s]);
    return e;
  }
  /**
   * Clears the data of the given model. If not specified, clears all the data.
   *
   * @param modelID ID of the model whose data to clear.
   */
  clear(t) {
    if (t === void 0) {
      this.ids = {}, this.needsUpdate.clear();
      return;
    }
    delete this.ids[t], this.needsUpdate.delete(t);
  }
  addID(t, e) {
    this.ids[t] || (this.ids[t] = /* @__PURE__ */ new Set()), this.ids[t].add(e);
  }
  getData() {
    const t = {};
    for (const s in this.ids)
      t[s] = Array.from(this.ids[s]);
    const e = this.exportRules();
    return {
      name: this.name,
      inclusive: this.inclusive,
      type: "IfcFinderQuery",
      ids: t,
      rules: e
    };
  }
  exportRules() {
    const t = [];
    for (const e of this.rules) {
      const s = {};
      for (const i in e) {
        const n = e[i];
        n instanceof RegExp ? s[i] = { regexp: !0, value: n.source } : s[i] = n;
      }
      t.push(s);
    }
    return t;
  }
  findInFile(t, e) {
    return new Promise((s) => {
      const i = new FileReader(), n = new TextDecoder("utf-8"), r = 1e4 * 1024, o = 1e3;
      let a = 0;
      const c = /;/, h = () => {
        if (a >= e.size) {
          s();
          return;
        }
        const f = Math.min(a + r + o, e.size), u = e.slice(a, f);
        i.readAsArrayBuffer(u);
      };
      i.onload = () => {
        if (!(i.result instanceof ArrayBuffer))
          return;
        const f = new Uint8Array(i.result), d = n.decode(f).split(c);
        d.shift(), this.findInLines(t, d), this.onProgress.trigger(a / e.size), a += r, h();
      }, h();
    });
  }
  getIdFromLine(t) {
    const e = t.slice(t.indexOf("#") + 1, t.indexOf("="));
    return parseInt(e, 10);
  }
  testRules(t) {
    let e = null, s = null, i = null, n = !1;
    for (const r of this.rules) {
      if (r.type === "category") {
        if (e === null && (e = this.getCategoryFromLine(t), e === null)) {
          if (this.inclusive)
            continue;
          break;
        }
        if (!r.value.test(e)) {
          if (this.inclusive)
            continue;
          n = !1;
          break;
        }
        n = !0;
        continue;
      }
      if (s === null && (s = this.getAttributesFromLine(t), s === null)) {
        if (this.inclusive)
          continue;
        n = !1;
        break;
      }
      if (e === null && (e = this.getCategoryFromLine(t), e === null)) {
        if (this.inclusive)
          continue;
        n = !1;
        break;
      }
      if (i === null && (i = Object.keys(new W.IFC4[e]()), i = i.slice(2), i === null)) {
        if (this.inclusive)
          continue;
        n = !1;
        break;
      }
      if (r.type === "property") {
        const { name: o, value: a } = r;
        if (!a.test(t)) {
          if (this.inclusive)
            continue;
          n = !1;
          break;
        }
        let c = !1;
        for (let h = 0; h < s.length; h++) {
          const f = s[h], u = i[h];
          if (a.test(f) && o.test(u)) {
            c = !0;
            break;
          }
        }
        if (c)
          n = !0;
        else if (!this.inclusive) {
          n = !1;
          break;
        }
      }
      if (r.type === "operator") {
        const { name: o, value: a, operator: c } = r;
        let h = !1;
        for (let f = 0; f < s.length; f++) {
          const u = i[f], d = s[f].replace(
            /IFCLENGTHMEASURE\(|IFCVOLUMEMEASURE\(|\)/g,
            ""
          );
          if (o.test(u)) {
            if (c === "=" && parseFloat(d) === a) {
              h = !0;
              break;
            } else if (c === "<" && parseFloat(d) < a) {
              h = !0;
              break;
            } else if (c === ">" && parseFloat(d) > a) {
              h = !0;
              break;
            } else if (c === ">=" && parseFloat(d) >= a) {
              h = !0;
              break;
            } else if (c === "<=" && parseFloat(d) <= a) {
              h = !0;
              break;
            }
          }
        }
        if (h)
          n = !0;
        else if (!this.inclusive) {
          n = !1;
          break;
        }
      }
    }
    return n;
  }
  getCategoryFromLine(t) {
    const e = t.indexOf("=") + 1, s = t.indexOf("("), i = t.slice(e, s).trim(), n = ef[i];
    return n || null;
  }
  getAttributesFromLine(t) {
    const e = /\((.*)\)/, s = t.match(e);
    if (!(s && s[1]))
      return null;
    const i = /,(?![^()]*\))/g;
    return s[1].split(i).map((r) => r.trim());
  }
};
y(zl, "importers", /* @__PURE__ */ new Map());
let _t = zl;
class fa {
  constructor(t) {
    y(this, "list", /* @__PURE__ */ new Map()), y(this, "id", A.MathUtils.generateUUID()), y(this, "mode", "intersect"), y(this, "_components"), this._components = t;
  }
  /**
   * The list of unique queries contained in this group.
   */
  get queries() {
    return new Set(this.list.values());
  }
  /**
   * The items of all the queries contained in this group. The returned data depends on {@link IfcQueryGroup.mode}.
   */
  get items() {
    const t = [];
    for (const e of this.queries)
      t.push(e.items);
    return this.mode === "combine" ? Pe.FragmentUtils.combine(t) : Pe.FragmentUtils.intersect(t);
  }
  /**
   * Adds a new query to this group.
   * @param query the query to add.
   */
  add(t) {
    if (this.list.has(t.name))
      throw new Error(
        `This group already has a query with the name ${t.name}.`
      );
    this.list.set(t.name, t);
  }
  /**
   * Clears the data of the given modelID of all queries contained in this group. If no modelID is provided, clears all data.
   * @param modelID the model whose data to remove.
   */
  clear(t) {
    for (const e of this.queries)
      e.clear(t);
  }
  /**
   * Imports data that has been previously exported through {@link IfcQueryGroup.export}.
   * @param data the serializable object used to persist a group's data.
   */
  import(t) {
    this.mode = t.mode, this.id = t.id;
    for (const e in t.queries) {
      const s = _t.import(this._components, t.queries[e]);
      s && this.list.set(e, s);
    }
  }
  /**
   * Exports all the data of this group, so that it can be persisted and imported later using {@link IfcQueryGroup.import}.
   */
  export() {
    const t = {};
    for (const [e, s] of this.list)
      t[e] = s.export();
    return {
      mode: this.mode,
      id: this.id,
      queries: t
    };
  }
  /**
   * Updates all the queries contained in this group that need an update for the given file. It will skip those where {@link IfcFinderQuery.needsUpdate} is false.
   * @param modelID the identifier used to refer to the given file.
   * @param file the file to process.
   */
  async update(t, e) {
    for (const s of this.queries) {
      const i = s.needsUpdate.get(t);
      (i === void 0 || i) && await s.update(t, e);
    }
  }
}
const Gl = class Yl extends _t {
  constructor(t, e) {
    super(t), y(this, "name"), this.name = e.name, this.rules = e.rules, this.inclusive = e.inclusive;
  }
  /**
   * {@link IfcFinderQuery.items}
   */
  get items() {
    const t = this.components.get(fe), e = [];
    for (const s in this.ids) {
      const i = this.ids[s], n = t.groups.get(s);
      if (!n) {
        console.warn(`Model ${s} not found!`);
        continue;
      }
      const r = n.getFragmentMap(i);
      e.push(r);
    }
    return Pe.FragmentUtils.combine(e);
  }
  /**
   * {@link IfcFinderQuery.export}
   */
  export() {
    const t = this.getData();
    return t.type = Yl.type, t;
  }
  /**
   * {@link IfcFinderQuery.update}
   */
  async update(t, e) {
    this.ids[t] = /* @__PURE__ */ new Set(), await this.findInFile(t, e), this.needsUpdate.set(t, !1);
  }
  findInLines(t, e) {
    for (const s of e)
      if (this.testRules(s)) {
        const n = this.getIdFromLine(s);
        this.addID(t, n);
      }
  }
};
y(Gl, "type", "IfcBasicQuery");
let da = Gl;
_t.importers.set(
  da.type,
  (l, t) => {
    const e = new da(l, {
      name: t.name,
      rules: _t.importRules(t.rules),
      inclusive: t.inclusive
    });
    return e.ids = _t.importIds(t), e;
  }
);
const Hl = class Wl extends _t {
  constructor(t, e) {
    super(t), y(this, "name"), y(this, "psets", []), this.name = e.name, this.rules = e.rules, this.inclusive = e.inclusive;
  }
  /**
   * {@link IfcFinderQuery.items}
   */
  get items() {
    const t = this.components.get(et), e = this.components.get(fe), s = [];
    for (const i in this.ids) {
      const n = e.groups.get(i);
      if (!n) {
        console.log(`Model not found: ${i}.`);
        continue;
      }
      const r = this.ids[i];
      for (const o of r) {
        const a = t.getEntityRelations(
          i,
          o,
          "DefinesOcurrence"
        );
        if (a) {
          const c = n.getFragmentMap(a);
          s.push(c);
        }
      }
    }
    return Pe.FragmentUtils.combine(s);
  }
  /**
   * {@link IfcFinderQuery.export}
   */
  export() {
    const t = this.getData();
    return t.type = Wl.type, t;
  }
  /**
   * {@link IfcFinderQuery.update}
   */
  async update(t, e) {
    await this.findInFile(t, e);
    const s = /* @__PURE__ */ new Set();
    for (const i of this.psets) {
      const n = this.getAttributesFromLine(i);
      if (n === null)
        continue;
      const r = n[4].replace("(", "[").replace(")", "]").replace(/#/g, ""), o = JSON.parse(r);
      for (const a of o) {
        const c = this.ids[t];
        if (c && c.has(a)) {
          const h = this.getIdFromLine(i);
          s.add(h);
          break;
        }
      }
    }
    this.ids[t] = s, this.psets = [], this.needsUpdate.set(t, !1);
  }
  findInLines(t, e) {
    for (const s of e) {
      const i = this.getCategoryFromLine(s);
      if (i === "IfcPropertySet") {
        this.psets.push(s);
        continue;
      }
      if (i !== "IfcPropertySingleValue")
        continue;
      if (this.testRules(s)) {
        const r = this.getIdFromLine(s);
        this.addID(t, r);
      }
    }
  }
};
y(Hl, "type", "IfcPropertyQuery");
let pa = Hl;
_t.importers.set(
  pa.type,
  (l, t) => {
    const e = new pa(l, {
      name: t.name,
      inclusive: t.inclusive,
      rules: _t.importRules(t.rules)
    });
    return e.ids = _t.importIds(t), e;
  }
);
const Fd = class Xl extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), y(this, "list", /* @__PURE__ */ new Map()), t.add(Xl.uuid, this);
  }
  /**
   * List of all queries from all created {@link IfcQueryGroup} instances.
   */
  get queries() {
    const t = /* @__PURE__ */ new Set();
    for (const [, e] of this.list)
      for (const s of e.queries)
        t.add(s);
    return t;
  }
  /**
   * Imports all the query groups provided in the given data. You can generate this data to save the result of queries and persist it over time.
   * @param data The data containing the serialized query groups to import.
   */
  import(t) {
    for (const e in t) {
      const s = new fa(this.components);
      s.import(t[e]), this.list.set(e, s);
    }
  }
  /**
   * Exports all the query groups created. You can then import this data back using the import method.
   */
  export() {
    const t = {};
    for (const [e, s] of this.list)
      t[e] = s.export();
    return t;
  }
  /**
   * Creates a new {@link IfcQueryGroup}.
   */
  create() {
    const t = new fa(this.components);
    return this.list.set(t.id, t), t;
  }
  /**
   * Creates the {@link IfcQueryGroup} with the given ID.
   */
  delete(t) {
    this.list.delete(t);
  }
  /**
   * Deletes all {@link IfcQueryGroup} instances.
   */
  clear() {
    this.list.clear();
  }
};
y(Fd, "uuid", "0da7ad77-f734-42ca-942f-a074adfd1e3a");
const Zl = class jl extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), y(this, "list", {}), y(this, "onDisposed", new Y()), y(this, "onFragmentsDisposed", (s) => {
      const { groupID: i, fragmentIDs: n } = s;
      for (const r in this.list) {
        const o = this.list[r], a = Object.keys(o);
        if (a.includes(i))
          delete o[i], Object.values(o).length === 0 && delete this.list[r];
        else
          for (const c of a) {
            const h = o[c];
            for (const f of n)
              delete h.map[f];
            Object.values(h).length === 0 && delete o[c];
          }
      }
    }), t.add(jl.uuid, this), t.get(fe).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list = {}, this.components.get(fe).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Removes a fragment from the classification based on its unique identifier (guid).
   * This method iterates through all classification systems and classes, and deletes the fragment with the specified guid from the respective group.
   *
   * @param guid - The unique identifier of the fragment to be removed.
   */
  remove(t) {
    for (const e in this.list) {
      const s = this.list[e];
      for (const i in s) {
        const n = s[i];
        delete n.map[t];
      }
    }
  }
  /**
   * Finds and returns fragments based on the provided filter criteria.
   * If no filter is provided, it returns all fragments.
   *
   * @param filter - An optional object containing filter criteria.
   * The keys of the object represent the classification system names,
   * and the values are arrays of class names to match.
   *
   * @returns A map of fragment GUIDs to their respective express IDs,
   * where the express IDs are filtered based on the provided filter criteria.
   *
   * @throws Will throw an error if the fragments map is malformed.
   */
  find(t) {
    const e = this.components.get(fe);
    if (!t) {
      const r = {};
      for (const [o, a] of e.list)
        r[o] = new Set(a.ids);
      return r;
    }
    const s = Object.keys(t).length, i = {};
    for (const r in t) {
      const o = t[r];
      if (!this.list[r]) {
        console.warn(`Classification ${r} does not exist.`);
        continue;
      }
      for (const a of o) {
        const c = this.list[r][a];
        if (c)
          for (const h in c.map) {
            i[h] || (i[h] = /* @__PURE__ */ new Map());
            for (const f of c.map[h]) {
              const u = i[h].get(f);
              u === void 0 ? i[h].set(f, 1) : i[h].set(f, u + 1);
            }
          }
      }
    }
    const n = {};
    for (const r in i) {
      const o = i[r];
      for (const [a, c] of o) {
        if (c === void 0)
          throw new Error("Malformed fragments map!");
        c === s && (n[r] || (n[r] = /* @__PURE__ */ new Set()), n[r].add(a));
      }
    }
    return n;
  }
  /**
   * Classifies fragments based on their modelID.
   *
   * @param modelID - The unique identifier of the model to classify fragments by.
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the fragments in the provided group,
   * and classifies them based on their modelID.
   * The classification is stored in the `list.models` property,
   * with the modelID as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   */
  byModel(t, e) {
    this.list.models || (this.list.models = {});
    const s = this.list.models;
    s[t] || (s[t] = { map: {}, id: null, name: t });
    const i = s[t];
    for (const [n, r] of e.data) {
      const o = r[0];
      for (const a of o) {
        const c = e.keyFragments.get(a);
        c && (i.map[c] || (i.map[c] = /* @__PURE__ */ new Set()), i.map[c].add(n));
      }
    }
  }
  /**
   * Classifies fragments based on their PredefinedType property.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the properties of the fragments in the provided group,
   * and classifies them based on their PredefinedType property.
   * The classification is stored in the `list.predefinedTypes` property,
   * with the PredefinedType as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  async byPredefinedType(t) {
    var e;
    this.list.predefinedTypes || (this.list.predefinedTypes = {});
    const s = this.list.predefinedTypes, i = t.getAllPropertiesIDs();
    for (const n of i) {
      const r = await t.getProperties(n);
      if (!r)
        continue;
      const o = String((e = r.PredefinedType) == null ? void 0 : e.value).toUpperCase();
      s[o] || (s[o] = {
        map: {},
        id: null,
        name: o
      });
      const a = s[o];
      for (const [c, h] of t.data) {
        const f = h[0];
        for (const u of f) {
          const d = t.keyFragments.get(u);
          if (!d)
            throw new Error("Fragment ID not found!");
          a.map[d] || (a.map[d] = /* @__PURE__ */ new Set()), a.map[d].add(r.expressID);
        }
      }
    }
  }
  /**
   * Classifies fragments based on their entity type.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their entity type.
   * The classification is stored in the `list.entities` property,
   * with the entity type as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  byEntity(t) {
    this.list.entities || (this.list.entities = {});
    for (const [e, s] of t.data) {
      const n = s[1][1], r = Cn[n];
      this.saveItem(t, "entities", r, e);
    }
  }
  /**
   * Classifies fragments based on a specific IFC relationship.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   * @param ifcRel - The IFC relationship number to classify fragments by.
   * @param systemName - The name of the classification system to store the classification.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on the specified IFC relationship.
   * The classification is stored in the `list` property under the specified system name,
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the IFC relationship is not valid.
   */
  async byIfcRel(t, e, s) {
    cs.isRel(e) && await cs.getRelationMap(
      t,
      e,
      async (i, n) => {
        const { name: r } = await cs.getEntityName(
          t,
          i
        );
        for (const o of n)
          this.saveItem(
            t,
            s,
            r ?? "NO REL NAME",
            o
          );
      }
    );
  }
  /**
   * Classifies fragments based on their spatial structure in the IFC model.
   *
   * @param model - The FragmentsGroup containing the fragments to be classified.
   * @param config - The configuration for the classifier. It includes "useProperties", which is true by default
   * (if false, the classification will use the expressIDs instead of the names), and "isolate", which will make
   * the classifier just pick the WEBIFC categories provided.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their spatial structure in the IFC model.
   * The classification is stored in the `list` property under the system name "spatialStructures",
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the model relations do not exist.
   */
  async bySpatialStructure(t, e = {}) {
    var s, i;
    const n = this.components.get(et), r = n.relationMaps[t.uuid];
    if (!r)
      throw new Error(
        `Classifier: model relations of ${t.name || t.uuid} have to exists to group by spatial structure.`
      );
    const o = e.systemName ?? "spatialStructures", c = e.useProperties === void 0 || e.useProperties;
    for (const [h] of r) {
      if (e.isolate) {
        const p = t.data.get(h);
        if (!p)
          continue;
        const m = p[1][1];
        if (m === void 0 || !e.isolate.has(m))
          continue;
      }
      const f = n.getEntityRelations(
        t,
        h,
        "Decomposes"
      );
      if (f)
        for (const p of f) {
          let m = p.toString();
          if (c) {
            const E = await t.getProperties(p);
            if (!E)
              continue;
            m = (s = E.Name) == null ? void 0 : s.value;
          }
          this.saveItem(t, o, m, h, p);
        }
      const u = n.getEntityRelations(
        t,
        h,
        "ContainsElements"
      );
      if (!u)
        continue;
      let d = h.toString();
      if (c) {
        const p = await t.getProperties(h);
        if (!p)
          continue;
        d = (i = p.Name) == null ? void 0 : i.value;
      }
      for (const p of u) {
        this.saveItem(t, o, d, p, h);
        const m = n.getEntityRelations(
          t,
          Number(p),
          "IsDecomposedBy"
        );
        if (m)
          for (const E of m)
            this.saveItem(t, o, d, E, h);
      }
    }
  }
  /**
   * Sets the color of the specified fragments.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   * @param color - The color to set for the fragments.
   * @param override - A boolean indicating whether to override the existing color of the fragments.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and sets their color using the `setColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  setColor(t, e, s = !1) {
    const i = this.components.get(fe);
    for (const n in t) {
      const r = i.list.get(n);
      if (!r)
        continue;
      const o = t[n];
      r.setColor(e, o, s);
    }
  }
  /**
   * Resets the color of the specified fragments to their original color.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and resets their color using the `resetColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  resetColor(t) {
    const e = this.components.get(fe);
    for (const s in t) {
      const i = e.list.get(s);
      if (!i)
        continue;
      const n = t[s];
      i.resetColor(n);
    }
  }
  /**
   * Exports the computed classification to persists them and import them back
   * later for faster loading.
   */
  export() {
    const t = {};
    for (const e in this.list) {
      t[e] = {};
      const s = this.list[e];
      for (const i in s) {
        const n = s[i];
        t[e][i] = {
          map: Pe.FragmentUtils.export(n.map),
          name: n.name,
          id: n.id
        };
      }
    }
    return t;
  }
  /**
   * Imports a classification previously exported with .export().
   * @param data the serialized classification to import.
   */
  import(t) {
    for (const e in t) {
      this.list[e] || (this.list[e] = {});
      const s = t[e];
      for (const i in s) {
        const n = s[i];
        this.list[e][i] = {
          map: Pe.FragmentUtils.import(n.map),
          name: n.name,
          id: n.id
        };
      }
    }
  }
  saveItem(t, e, s, i, n = null) {
    this.list[e] || (this.list[e] = {});
    const r = t.data.get(i);
    if (r)
      for (const o of r[0]) {
        const a = t.keyFragments.get(o);
        if (a) {
          const c = this.list[e];
          c[s] || (c[s] = { map: {}, id: n, name: s }), c[s].map[a] || (c[s].map[a] = /* @__PURE__ */ new Set()), c[s].map[a].add(i);
        }
      }
  }
};
y(Zl, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
let Wr = Zl;
const wd = class Ql extends ue {
  constructor(t) {
    super(t), y(this, "onDisposed", new Y()), y(this, "enabled", !0), y(this, "height", 10), y(this, "groupName", "spatialStructures"), y(this, "list", /* @__PURE__ */ new Set()), t.add(Ql.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Sets the explosion state of the fragments.
   *
   * @param active - A boolean indicating whether to activate or deactivate the explosion.
   *
   * @remarks
   * This method applies a vertical transformation to the fragments based on the `active` parameter.
   * If `active` is true, the fragments are moved upwards by a distance determined by the `height` property.
   * If `active` is false, the fragments are moved back to their original position.
   *
   * The method also keeps track of the exploded items using the `list` set.
   *
   * @throws Will throw an error if the `Classifier` or `FragmentsManager` components are not found in the `components` system.
   */
  set(t) {
    if (!this.enabled)
      return;
    const e = this.components.get(Wr), s = this.components.get(fe), i = t ? 1 : -1;
    let n = 0;
    const r = e.list[this.groupName], o = new A.Matrix4();
    for (const a in r) {
      o.elements[13] = n * i * this.height;
      for (const c in r[a].map) {
        const h = s.list.get(c), f = a + c, u = this.list.has(f);
        if (!h || t && u || !t && !u)
          continue;
        t ? this.list.add(f) : this.list.delete(f);
        const d = r[a].map[c];
        h.applyTransform(d, o), h.mesh.computeBoundingSphere(), h.mesh.computeBoundingBox();
      }
      n++;
    }
  }
};
y(wd, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
const Kl = class ql extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), this.components.add(ql.uuid, this);
  }
  /**
   * Sets the visibility of fragments within the 3D scene.
   * If no `items` parameter is provided, all fragments will be set to the specified visibility.
   * If `items` is provided, only the specified fragments will be affected.
   *
   * @param visible - The visibility state to set for the fragments.
   * @param items - An optional map of fragment IDs and their corresponding sub-fragment IDs to be affected.
   * If not provided, all fragments will be affected.
   *
   * @returns {void}
   */
  set(t, e) {
    const s = this.components.get(fe);
    if (!e) {
      for (const [i, n] of s.list)
        n && (n.setVisibility(t), this.updateCulledVisibility(n));
      return;
    }
    for (const i in e) {
      const n = e[i], r = s.list.get(i);
      r && (r.setVisibility(t, n), this.updateCulledVisibility(r));
    }
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param items - A map of fragment IDs and their corresponding sub-fragment IDs to be isolated.
   * If not provided, all fragments will be isolated.
   *
   * @returns {void}
   */
  isolate(t) {
    this.set(!1), this.set(!0, t);
  }
  updateCulledVisibility(t) {
    const e = this.components.get(Mu);
    for (const [s, i] of e.list) {
      const n = i.colorMeshes.get(t.id);
      n && (n.count = t.mesh.count);
    }
  }
};
y(Kl, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
let vd = Kl;
class Od extends oo {
  constructor() {
    super(...arguments), y(this, "minGeometrySize", 10), y(this, "minAssetsSize", 1e3), y(this, "maxTriangles", null);
  }
}
const Pd = class Jl extends ue {
  constructor(t) {
    super(t), y(this, "onGeometryStreamed", new bt()), y(this, "onAssetStreamed", new bt()), y(this, "onProgress", new bt()), y(this, "onIfcLoaded", new bt()), y(this, "onDisposed", new Y()), y(this, "settings", new Od()), y(this, "enabled", !0), y(this, "webIfc", new W.IfcAPI()), y(this, "_nextAvailableID", 0), y(this, "_splittedGeometries", /* @__PURE__ */ new Map()), y(this, "_spatialTree", new El()), y(this, "_metaData", new Cl()), y(this, "_visitedGeometries", /* @__PURE__ */ new Map()), y(this, "_streamSerializer", new Pe.StreamSerializer()), y(this, "_geometries", /* @__PURE__ */ new Map()), y(this, "_geometryCount", 0), y(this, "_civil", new gl()), y(this, "_groupSerializer", new Pe.Serializer()), y(this, "_assets", []), y(this, "_meshesWithHoles", /* @__PURE__ */ new Set()), this.components.add(Jl.uuid, this), this.settings.excludedCategories.add(W.IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onIfcLoaded.reset(), this.onGeometryStreamed.reset(), this.onAssetStreamed.reset(), this.webIfc = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * This method streams the IFC file from a given buffer.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   * @example
   * ```typescript
   * const ifcData = await fetch('path/to/ifc/file.ifc');
   * const rawBuffer = await response.arrayBuffer();
   * const ifcBuffer = new Uint8Array(rawBuffer);
   * await ifcGeometryTiler.streamFromBuffer(ifcBuffer);
   * ```
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  /**
   * This method streams the IFC file from a given callback.
   *
   * @param loadCallback - The callback function that will be used to load the IFC file.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: s, logLevel: i } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, s), await this.webIfc.Init(), i && this.webIfc.SetLogLevel(i), this.webIfc.OpenModel(t, this.settings.webIfc), this._nextAvailableID = this.webIfc.GetMaxExpressID(0);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: s, logLevel: i } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, s), await this.webIfc.Init(), i && this.webIfc.SetLogLevel(i), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc), this._nextAvailableID = this.webIfc.GetMaxExpressID(0);
  }
  async streamAllGeometries() {
    console.log("Converting geometries to tiles...");
    const { minGeometrySize: t, minAssetsSize: e } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const s = this.webIfc.GetIfcEntityList(0), i = [[]], n = new Pe.FragmentsGroup();
    n.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let r = 0, o = 0;
    for (const p of s) {
      if (!this.webIfc.IsIfcElement(p) && p !== W.IFCSPACE || this.settings.excludedCategories.has(p))
        continue;
      const m = this.webIfc.GetLineIDsWithType(0, p), E = m.size();
      for (let I = 0; I < E; I++) {
        r > t && (r = 0, o++, i.push([]));
        const g = m.get(I);
        i[o].push(g);
        const T = this.webIfc.GetLine(0, g);
        if (T.GlobalId) {
          const F = (T == null ? void 0 : T.GlobalId.value) || (T == null ? void 0 : T.GlobalId);
          n.globalToExpressIDs.set(F, g);
        }
        const C = this._spatialTree.itemsByFloor[g] || 0;
        n.data.set(g, [[], [C, p]]), r++;
      }
    }
    this._spatialTree.cleanUp();
    let a = 0.01, c = 0;
    for (const p of i) {
      c++, this.webIfc.StreamMeshes(0, p, (E) => {
        this.getMesh(this.webIfc, E, n);
      }), this._geometryCount > this.settings.minGeometrySize && await this.streamGeometries(), this._assets.length > e && await this.streamAssets();
      const m = c / i.length;
      m > a && (a += 0.01, a = Math.max(a, m), await this.onProgress.trigger(Math.round(a * 100) / 100));
    }
    this._geometryCount && await this.streamGeometries(), this._assets.length && await this.streamAssets();
    const { opaque: h, transparent: f } = n.geometryIDs;
    for (const [p, { index: m, uuid: E }] of this._visitedGeometries)
      n.keyFragments.set(m, E), (p > 1 ? h : f).set(p, m);
    Tl.get(n, this.webIfc);
    const u = this.webIfc.GetCoordinationMatrix(0);
    n.coordinationMatrix.fromArray(u), n.civilData = this._civil.read(this.webIfc);
    const d = this._groupSerializer.export(n);
    await this.onIfcLoaded.trigger(d), n.dispose(!0);
  }
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch {
    }
    this.webIfc = null, this.webIfc = new W.IfcAPI(), this._visitedGeometries.clear(), this._geometries.clear(), this._assets = [], this._meshesWithHoles.clear();
  }
  getMesh(t, e, s) {
    const i = e.geometries.size(), n = e.expressID, r = { id: n, geometries: [] };
    for (let o = 0; o < i; o++) {
      const a = e.geometries.get(o), c = a.geometryExpressID, h = a.color.w === 1, u = c * (h ? 1 : -1);
      this._visitedGeometries.has(u) || this.getGeometry(t, c, h), this.registerGeometryData(
        s,
        n,
        a,
        r,
        c,
        u
      );
      const d = this._splittedGeometries.get(c);
      if (d)
        for (const p of d)
          this.registerGeometryData(s, n, a, r, p, p);
    }
    this._assets.push(r);
  }
  getGeometry(t, e, s) {
    const i = t.GetGeometry(0, e), n = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), r = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), o = new Float32Array(r.length / 2), a = new Float32Array(r.length / 2);
    for (let d = 0; d < r.length; d += 6)
      o[d / 2] = r[d], o[d / 2 + 1] = r[d + 1], o[d / 2 + 2] = r[d + 2], a[d / 2] = r[d + 3], a[d / 2 + 1] = r[d + 4], a[d / 2 + 2] = r[d + 5];
    const c = s ? 1 : -1;
    if (n.length === 0) {
      const d = new Float32Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
      this._geometries.set(e, {
        position: o,
        normal: a,
        index: n,
        boundingBox: d,
        hasHoles: !1
      });
      const p = this._visitedGeometries.size, m = A.MathUtils.generateUUID(), E = e * c;
      this._visitedGeometries.set(E, { uuid: m, index: p }), this._geometryCount++, i.delete();
      return;
    }
    const f = (this.settings.maxTriangles || n.length / 3) * 3;
    let u = !0;
    for (let d = 0; d < n.length; d += f) {
      const p = n.length - d, m = Math.min(p, f), E = d + m, I = [], g = [], T = [];
      let C = 0;
      for (let _ = d; _ < E; _++) {
        I.push(C++);
        const K = n[_];
        g.push(o[K * 3]), g.push(o[K * 3 + 1]), g.push(o[K * 3 + 2]), T.push(a[K * 3]), T.push(a[K * 3 + 1]), T.push(a[K * 3 + 2]);
      }
      const F = new Uint32Array(I), O = new Float32Array(g), P = new Float32Array(T), M = iu(O), L = new Float32Array(M.transformation.elements), b = !1, B = u ? e : this._nextAvailableID++;
      this._geometries.set(B, {
        position: O,
        normal: P,
        index: F,
        boundingBox: L,
        hasHoles: b
      }), u || (this._splittedGeometries.has(e) || this._splittedGeometries.set(e, /* @__PURE__ */ new Set()), this._splittedGeometries.get(e).add(B));
      const v = this._visitedGeometries.size, D = A.MathUtils.generateUUID(), R = B * c;
      this._visitedGeometries.set(R, { uuid: D, index: v }), this._geometryCount++, u = !1;
    }
    i.delete();
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets), this._assets = null, this._assets = [];
  }
  async streamGeometries() {
    const t = /* @__PURE__ */ new Map();
    for (const [e, s] of this._geometries)
      t.set(e, s), t.size > this.settings.minGeometrySize && await this.outputGeometries(t);
    await this.outputGeometries(t), this._geometries.clear(), this._geometryCount = 0;
  }
  async outputGeometries(t) {
    let e = this._streamSerializer.export(t), s = {};
    for (const [i, { boundingBox: n, hasHoles: r }] of t)
      s[i] = { boundingBox: n, hasHoles: r };
    await this.onGeometryStreamed.trigger({ data: s, buffer: e }), s = null, e = null, t.clear();
  }
  registerGeometryData(t, e, s, i, n, r) {
    const o = this._visitedGeometries.get(r);
    if (o === void 0)
      throw new Error("Error getting geometry data for streaming!");
    const a = t.data.get(e);
    if (!a)
      throw new Error("Data not found!");
    a[0].push(o.index);
    const { x: c, y: h, z: f, w: u } = s.color, d = [c, h, f, u], p = s.flatTransformation;
    i.geometries.push({ color: d, geometryID: n, transformation: p });
  }
};
y(Pd, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
class Nd extends oo {
  constructor() {
    super(...arguments), y(this, "propertiesSize", 100);
  }
}
class xd extends ue {
  constructor() {
    super(...arguments), y(this, "onPropertiesStreamed", new bt()), y(this, "onProgress", new bt()), y(this, "onIndicesStreamed", new bt()), y(this, "onDisposed", new Y()), y(this, "enabled", !0), y(this, "settings", new Nd()), y(this, "webIfc", new W.IfcAPI());
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  /**
   * This method converts properties from an IFC file to tiles given its data as a Uint8Array.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  /**
   * This method converts properties from an IFC file to tiles using a given callback function to read the file.
   *
   * @param loadCallback - A callback function that loads the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: s, logLevel: i } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, s), await this.webIfc.Init(), i && this.webIfc.SetLogLevel(i), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: s, logLevel: i } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, s), await this.webIfc.Init(), i && this.webIfc.SetLogLevel(i), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), s = /* @__PURE__ */ new Set([
      W.IFCPROJECT,
      W.IFCSITE,
      W.IFCBUILDING,
      W.IFCBUILDINGSTOREY,
      W.IFCSPACE
    ]);
    for (const a of s)
      e.add(a);
    let i = 0.01, n = 0;
    for (const a of e) {
      if (n++, yl.has(a))
        continue;
      const c = s.has(a), h = this.webIfc.GetLineIDsWithType(0, a), f = h.size();
      let u = 0;
      for (let p = 0; p < f - t; p += t) {
        const m = {};
        for (let E = 0; E < t; E++) {
          u++;
          const I = h.get(p + E);
          try {
            const g = this.webIfc.GetLine(0, I, c);
            m[g.expressID] = g;
          } catch {
            console.log(`Could not get property: ${I}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: a, data: m });
      }
      if (u !== f) {
        const p = {};
        for (let m = u; m < f; m++) {
          const E = h.get(m);
          try {
            const I = this.webIfc.GetLine(0, E, c);
            p[I.expressID] = I;
          } catch {
            console.log(`Could not get property: ${E}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: a, data: p });
      }
      n / e.size > i && (i = Math.round(i * 100) / 100, await this.onProgress.trigger(i), i += 0.01);
    }
    await this.onProgress.trigger(1);
    const o = await this.components.get(et).processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(o);
  }
  cleanUp() {
    this.webIfc.Dispose(), this.webIfc = null, this.webIfc = new W.IfcAPI();
  }
}
y(xd, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
class $l {
  constructor(t, e, s) {
    y(this, "title"), y(this, "guid", zt.create()), y(this, "clippingPlanes", new qt()), y(this, "camera", {
      aspectRatio: 1,
      fov: 60,
      direction: { x: 0, y: 0, z: 0 },
      position: { x: 0, y: 0, z: 0 }
    }), y(this, "exceptionComponents", new qt()), y(this, "selectionComponents", new qt()), y(this, "componentColors", new mt()), y(this, "spacesVisible", !1), y(this, "spaceBoundariesVisible", !1), y(this, "openingsVisible", !1), y(this, "defaultVisibility", !0), y(this, "_components"), y(this, "world");
    const i = { setCamera: !0, ...s }, { data: n, setCamera: r } = i;
    this._components = t, this.world = e, n && (this.guid = n.guid ?? this.guid, this.set(n)), r && this.updateCamera();
  }
  get _selectionModelIdMap() {
    const t = this._components.get(fe), e = {};
    for (const [s, i] of t.groups) {
      s in e || (e[s] = /* @__PURE__ */ new Set());
      for (const n of this.selectionComponents) {
        const r = i.globalToExpressIDs.get(n);
        r && e[s].add(r);
      }
    }
    return e;
  }
  get _exceptionModelIdMap() {
    const t = this._components.get(fe), e = {};
    for (const [s, i] of t.groups) {
      s in e || (e[s] = /* @__PURE__ */ new Set());
      for (const n of this.exceptionComponents) {
        const r = i.globalToExpressIDs.get(n);
        r && e[s].add(r);
      }
    }
    return e;
  }
  /**
   * A list of components that should be selected (highlighted) when displaying a viewpoint.
   * @returns The fragmentIdMap for components marked as selections.
   */
  get selection() {
    return this._components.get(fe).modelIdToFragmentIdMap(
      this._selectionModelIdMap
    );
  }
  /**
   * A list of components to hide when defaultVisibility = true or to show when defaultVisibility = false
   * @returns The fragmentIdMap for components marked as exceptions.
   */
  get exception() {
    return this._components.get(fe).modelIdToFragmentIdMap(
      this._exceptionModelIdMap
    );
  }
  /**
   * Retrieves the projection type of the viewpoint's camera.
   *
   * @returns A string representing the projection type of the viewpoint's camera.
   *          It can be either 'Perspective' or 'Orthographic'.
   */
  get projection() {
    return "fov" in this.camera ? "Perspective" : "Orthographic";
  }
  /**
   * Retrieves the position vector of the viewpoint's camera.
   *
   * @remarks
   * The position vector represents the camera's position in the world coordinate system.
   * The function applies the base coordinate system transformation to the position vector.
   *
   * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
   */
  get position() {
    const t = this._components.get(fe), { position: e } = this.camera, { x: s, y: i, z: n } = e, r = new A.Vector3(s, i, n);
    return t.applyBaseCoordinateSystem(r, new A.Matrix4()), r;
  }
  /**
   * Retrieves the direction vector of the viewpoint's camera.
   *
   * @remarks
   * The direction vector represents the direction in which the camera is pointing.
   * It is calculated by extracting the x, y, and z components from the camera's direction property.
   *
   * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
   */
  get direction() {
    const { direction: t } = this.camera, { x: e, y: s, z: i } = t;
    return new A.Vector3(e, s, i);
  }
  get _managerVersion() {
    return this._components.get(Xe).config.version;
  }
  /**
   * Retrieves the list of BCF topics associated with the current viewpoint.
   *
   * @remarks
   * This function retrieves the BCFTopics manager from the components,
   * then filters the list of topics to find those associated with the current viewpoint.
   *
   * @returns An array of BCF topics associated with the current viewpoint.
   */
  get topics() {
    return [...this._components.get(Xe).list.values()].filter(
      (i) => i.viewpoints.has(this.guid)
    );
  }
  /**
   * Adds components to the viewpoint based on the provided fragment ID map.
   *
   * @param fragmentIdMap - A map containing fragment IDs as keys and arrays of express IDs as values.
   */
  addComponentsFromMap(t) {
    const s = this._components.get(fe).fragmentIdMapToGuids(t);
    this.selectionComponents.add(...s), this._components.get(Dt).list.set(this.guid, this);
  }
  /**
   * Replace the properties of the viewpoint with the provided data.
   *
   * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
   * @remarks The existing selection and exception components will be fully replaced in case new ones are provided.
   *
   * @param data - An object containing the properties to be set.
   *               The properties not included in the object will remain unchanged.
   *
   * @returns The viewpoint instance with the updated properties.
   */
  set(t) {
    const e = t, s = this;
    for (const n in t) {
      if (n === "guid")
        continue;
      const r = e[n];
      if (n === "selectionComponents") {
        this.selectionComponents.clear(), this.selectionComponents.add(...r);
        continue;
      }
      if (n === "exceptionComponents") {
        this.exceptionComponents.clear(), this.exceptionComponents.add(...r);
        continue;
      }
      n in this && (s[n] = r);
    }
    return this._components.get(Dt).list.set(this.guid, this), this;
  }
  /**
   * Sets the viewpoint of the camera in the world.
   *
   * @remarks
   * This function calculates the target position based on the viewpoint information.
   * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
   *
   * @param transition - Indicates whether the camera movement should have a transition effect.
   *                      Default value is `true`.
   *
   * @throws An error if the world's camera does not have camera controls.
   *
   * @returns A Promise that resolves when the camera has been set.
   */
  async go(t, e = !0) {
    const { camera: s } = t ?? this.world;
    if (!s.hasCameraControls())
      throw new Error(
        "Viewpoint: the world's camera need controls to set the viewpoint."
      );
    s instanceof $u && s.projection.set(this.projection);
    const i = new A.Vector3(
      this.camera.position.x,
      this.camera.position.y,
      this.camera.position.z
    ), n = new A.Vector3(
      this.camera.direction.x,
      this.camera.direction.y,
      this.camera.direction.z
    );
    if (i.equals(new A.Vector3()) && n.equals(new A.Vector3()))
      return;
    const r = this.position, o = this.direction;
    let a = {
      x: r.x + o.x * 80,
      y: r.y + o.y * 80,
      z: r.z + o.z * 80
    };
    const c = this.selection;
    if (Object.keys(c).length === 0) {
      const u = this._components.get(ct).get(this.world).castRayFromVector(r, this.direction);
      u && (a = u.point);
    } else {
      const h = this._components.get(Tn);
      h.reset(), h.addFragmentIdMap(c), a = h.getSphere().center, h.reset();
    }
    await s.controls.setLookAt(
      r.x,
      r.y,
      r.z,
      a.x,
      a.y,
      a.z,
      e
    );
  }
  /**
   * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
   *
   * @remarks
   * This function retrieves the camera's position, direction, and aspect ratio from the world's camera and renderer.
   * It then calculates the camera's perspective or orthographic settings based on the camera type.
   * Finally, it updates the viewpoint's camera settings and updates the viewpoint to the Viewpoints manager.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  updateCamera(t) {
    const { camera: e, renderer: s } = t ?? this.world;
    if (!s)
      throw new Error("Viewpoint: the world needs to have a renderer!");
    if (!e.hasCameraControls())
      throw new Error("Viewpoint: world's camera need camera controls!");
    const i = new A.Vector3();
    e.controls.getPosition(i);
    const n = e.three, r = new A.Vector3(0, 0, -1).applyEuler(
      n.rotation
    ), { width: o, height: a } = s.getSize();
    let c = o / a;
    Number.isNaN(c) && (c = 1);
    const h = this._components.get(fe);
    i.applyMatrix4(h.baseCoordinationMatrix.clone().invert());
    const f = {
      aspectRatio: c,
      position: { x: i.x, y: i.y, z: i.z },
      direction: { x: r.x, y: r.y, z: r.z }
    };
    n instanceof A.PerspectiveCamera ? this.camera = {
      ...f,
      fov: n.fov
    } : n instanceof A.OrthographicCamera && (this.camera = {
      ...f,
      viewToWorldScale: n.top - n.bottom
    }), this._components.get(Dt).list.set(this.guid, this);
  }
  applyVisibility() {
    const t = this._components.get(vd);
    t.set(this.defaultVisibility), t.set(!this.defaultVisibility, this.exception), t.set(!0, this.selection);
  }
  /**
   * Applies color to the components in the viewpoint based on their GUIDs.
   *
   * This function iterates through the `componentColors` map, retrieves the fragment IDs
   * corresponding to each color, and then uses the `Classifier` to apply the color to those fragments.
   *
   * @remarks
   * The color is applied using the `Classifier.setColor` method, which sets the color of the specified fragments.
   * The color is provided as a hexadecimal string, prefixed with a '#'.
   */
  applyColors() {
    const t = this._components.get(Dt), e = this._components.get(fe), s = this._components.get(Wr);
    for (const [i, n] of this.componentColors) {
      const r = e.guidToFragmentIdMap(n);
      s.setColor(r, i, t.config.overwriteColors);
    }
  }
  /**
   * Resets the colors of all components in the viewpoint to their original color.
   */
  resetColors() {
    const t = this._components.get(fe), e = this._components.get(Wr);
    for (const [s, i] of this.componentColors) {
      const n = t.guidToFragmentIdMap(i);
      e.resetColor(n);
    }
  }
  async createComponentTags(t) {
    var e, s;
    const i = this._components.get(fe), n = this._components.get(Xe);
    let r = "";
    if (n.config.includeSelectionTag) {
      const o = t === "selection" ? this._selectionModelIdMap : this._exceptionModelIdMap;
      for (const a in o) {
        const c = i.groups.get(a);
        if (!c)
          continue;
        const h = o[a];
        for (const f of h) {
          const u = await c.getProperties(f);
          if (!u)
            continue;
          const d = (e = u.GlobalId) == null ? void 0 : e.value;
          if (!d)
            continue;
          const p = (s = u.Tag) == null ? void 0 : s.value;
          let m = null;
          p && (m = `AuthoringToolId="${p}"`), r += `
<Component IfcGuid="${d}" ${m ?? ""} />`;
        }
      }
    } else
      r = [...this.selectionComponents].map((o) => `<Component IfcGuid="${o}" />`).join(`
`);
    return r;
  }
  createColorTags() {
    let t = "";
    for (const [e, s] of this.componentColors.entries()) {
      const i = `#${e.getHexString()}`, n = s.map((r) => `
<Component IfcGuid="${r}" />`).join(`
`);
      t += `<Color Color="${i}">
${n}
</Color>`;
    }
    return t.length !== 0 ? `<Coloring>
${t}
</Coloring>` : "<Coloring />";
  }
  /**
   * Serializes the viewpoint into a buildingSMART compliant XML string for export.
   *
   * @param version - The version of the BCF Manager to use for serialization.
   *                   If not provided, the current version of the manager will be used.
   *
   * @returns A Promise that resolves to an XML string representing the viewpoint.
   *          The XML string follows the BCF VisualizationInfo schema.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  async serialize(t = this._managerVersion) {
    const e = this._components.get(fe), s = this.position;
    s.applyMatrix4(e.baseCoordinationMatrix.clone().invert());
    const i = this.direction;
    i.normalize();
    const n = new A.Matrix4().makeRotationX(Math.PI / 2), r = i.clone().applyMatrix4(n);
    r.normalize();
    const o = `<CameraViewPoint>
      <X>${s.x}</X>
      <Y>${-s.z}</Y>
      <Z>${s.y}</Z>
    </CameraViewPoint>`, a = `<CameraDirection>
      <X>${i.x}</X>
      <Y>${-i.z}</Y>
      <Z>${i.y}</Z>
    </CameraDirection>`, c = `<CameraUpVector>
      <X>${r.x}</X>
      <Y>${-r.z}</Y>
      <Z>${r.y}</Z>
    </CameraUpVector>`, h = `<AspectRatio>${this.camera.aspectRatio}</AspectRatio>`;
    let f = "";
    "viewToWorld" in this.camera ? f = `<OrthogonalCamera>
        ${o}
        ${a}
        ${c}
        ${h}
        <ViewToWorldScale>${this.camera.viewToWorld}</ViewToWorldScale>
      </OrthogonalCamera>` : "fov" in this.camera && (f = `<PerspectiveCamera>
        ${o}
        ${a}
        ${c}
        ${h}
        <FieldOfView>${this.camera.fov}</FieldOfView>
      </PerspectiveCamera>`);
    const u = `<ViewSetupHints SpacesVisible="${this.spacesVisible ?? !1}" SpaceBoundariesVisible="${this.spaceBoundariesVisible ?? !1}" OpeningsVisible="${this.openingsVisible ?? !1}" />`, d = (await this.createComponentTags("selection")).trim(), p = (await this.createComponentTags("exception")).trim(), m = this.createColorTags();
    return `<?xml version="1.0" encoding="UTF-8"?>
    <VisualizationInfo Guid="${this.guid}">
      <Components>
        ${t === "2.1" ? u : ""}
        ${d.length !== 0 ? `<Selection>${d}</Selection>` : ""}
        <Visibility DefaultVisibility="${this.defaultVisibility}">
          ${t === "3" ? u : ""}
          ${p.length !== 0 ? `<Exceptions>${p}</Exceptions>` : ""}
        </Visibility>
        ${m}
      </Components>
      ${f}
    </VisualizationInfo>`;
  }
}
class Ld extends zs {
  constructor() {
    super(...arguments), y(this, "_config", {
      overwriteColors: {
        value: !1,
        type: "Boolean"
      }
    });
  }
  get overwriteColors() {
    return this._config.overwriteColors.value;
  }
  set overwriteColors(t) {
    this._config.overwriteColors.value = t;
  }
}
const ec = class Xr extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), y(this, "list", new mt()), y(this, "isSetup", !1), y(this, "onSetup", new Y()), y(this, "config", new Ld(
      this,
      this.components,
      "Viewpoints",
      Xr.uuid
    )), y(this, "onDisposed", new Y()), t.add(Xr.uuid, this);
  }
  /**
   * Creates a new Viewpoint instance and adds it to the list.
   *
   * @param world - The world in which the Viewpoint will be created.
   * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
   *
   * @returns The newly created Viewpoint instance.
   */
  create(t, e) {
    const s = new $l(this.components, t, { data: e });
    return e || this.list.set(s.guid, s), s;
  }
  setup() {
  }
  /**
   * Disposes of the Viewpoints component and its associated resources.
   *
   * This method is responsible for cleaning up any resources held by the Viewpoints component,
   * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
   * onDisposed event.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
y(ec, "uuid", "ee867824-a796-408d-8aa0-4e5962a83c66");
let Dt = ec;
class Md extends zs {
  constructor() {
    super(...arguments), y(this, "_config", {
      visible: {
        value: !0,
        type: "Boolean"
      },
      lockRotation: {
        value: !0,
        type: "Boolean"
      },
      zoom: {
        type: "Number",
        interpolable: !0,
        value: 0.05,
        min: 1e-3,
        max: 5
      },
      frontOffset: {
        type: "Number",
        interpolable: !0,
        value: 0,
        min: 0,
        max: 100
      },
      sizeX: {
        type: "Number",
        interpolable: !0,
        value: 320,
        min: 20,
        max: 5e3
      },
      sizeY: {
        type: "Number",
        interpolable: !0,
        value: 160,
        min: 20,
        max: 5e3
      },
      backgroundColor: {
        value: new A.Color(),
        type: "Color"
      }
    });
  }
  /**
   * Whether the minimap is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the minimap is visible or not.
   */
  set visible(t) {
    this._config.visible.value = t;
    const e = this._component.renderer.domElement.style;
    e.display = t ? "block" : "none";
  }
  /**
   * Whether to lock the rotation of the top camera in the minimap.
   */
  get lockRotation() {
    return this._config.lockRotation.value;
  }
  /**
   * Whether to lock the rotation of the top camera in the minimap.
   */
  set lockRotation(t) {
    this._config.lockRotation.value = t, this._component.lockRotation = t;
  }
  /**
   * The zoom of the camera in the minimap.
   */
  get zoom() {
    return this._config.zoom.value;
  }
  /**
   * The zoom of the camera in the minimap.
   */
  set zoom(t) {
    this._config.zoom.value = t, this._component.zoom = t;
  }
  /**
   * The front offset of the minimap.
   * It determines how much the minimap's view is offset from the camera's view.
   * By pushing the map to the front, what the user sees on screen corresponds with what they see on the map
   */
  get frontOffset() {
    return this._config.frontOffset.value;
  }
  /**
   * The front offset of the minimap.
   * It determines how much the minimap's view is offset from the camera's view.
   * By pushing the map to the front, what the user sees on screen corresponds with what they see on the map
   */
  set frontOffset(t) {
    this._config.frontOffset.value = t, this._component.frontOffset = t;
  }
  /**
   * The horizontal dimension of the minimap.
   */
  get sizeX() {
    return this._config.sizeX.value;
  }
  /**
   * The horizontal dimension of the minimap.
   */
  set sizeX(t) {
    this._config.sizeX.value = t;
    const { sizeX: e, sizeY: s } = this._config, i = new A.Vector2(e.value, s.value);
    this._component.resize(i);
  }
  /**
   * The vertical dimension of the minimap.
   */
  get sizeY() {
    return this._config.sizeY.value;
  }
  /**
   * The vertical dimension of the minimap.
   */
  set sizeY(t) {
    this._config.sizeY.value = t;
    const { sizeX: e, sizeY: s } = this._config, i = new A.Vector2(e.value, s.value);
    this._component.resize(i);
  }
  /**
   * The color of the background of the minimap.
   */
  get backgroundColor() {
    return this._config.backgroundColor.value;
  }
  /**
   * The color of the background of the minimap.
   */
  set backgroundColor(t) {
    this._config.backgroundColor.value = t, this._component.backgroundColor = t;
  }
}
class bd {
  constructor(t, e) {
    if (y(this, "onDisposed", new Y()), y(this, "onAfterUpdate", new Y()), y(this, "onBeforeUpdate", new Y()), y(this, "onResize", new Y()), y(this, "onSetup", new Y()), y(this, "frontOffset", 0), y(this, "overrideMaterial", new A.MeshDepthMaterial()), y(this, "backgroundColor", new A.Color(395274)), y(this, "renderer"), y(this, "enabled", !0), y(this, "world"), y(this, "config"), y(this, "isSetup", !1), y(this, "_defaultConfig", {
      visible: !0,
      lockRotation: !1,
      zoom: 0.05,
      frontOffset: 0,
      sizeX: 320,
      sizeY: 160,
      backgroundColor: new A.Color(395274)
    }), y(this, "_lockRotation", !0), y(this, "_size", new A.Vector2(320, 160)), y(this, "_camera"), y(this, "_plane"), y(this, "_tempVector1", new A.Vector3()), y(this, "_tempVector2", new A.Vector3()), y(this, "_tempTarget", new A.Vector3()), y(this, "down", new A.Vector3(0, -1, 0)), y(this, "updatePlanes", () => {
      if (!this.world.renderer)
        throw new Error("The given world must have a renderer!");
      const n = [], r = this.world.renderer.three;
      for (const o of r.clippingPlanes)
        n.push(o);
      n.push(this._plane), this.renderer.clippingPlanes = n;
    }), this.world = t, !this.world.renderer)
      throw new Error("The given world must have a renderer!");
    this.renderer = new A.WebGLRenderer(), this.renderer.setSize(this._size.x, this._size.y);
    const s = 1, i = this._size.x / this._size.y;
    this._camera = new A.OrthographicCamera(
      s * i / -2,
      s * i / 2,
      s / 2,
      s / -2
    ), this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes), this._camera.position.set(0, 200, 0), this._camera.zoom = 0.1, this._camera.rotation.x = -Math.PI / 2, this._plane = new A.Plane(this.down, 200), this.updatePlanes(), this.config = new Md(this, e, "MiniMap");
  }
  /**
   * Gets or sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   */
  get lockRotation() {
    return this._lockRotation;
  }
  /**
   * Sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   * @param active - If `true`, rotation is locked. If `false`, rotation is not locked.
   */
  set lockRotation(t) {
    this._lockRotation = t, t && (this._camera.rotation.z = 0);
  }
  /**
   * Gets the current zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @returns The current zoom level of the minimap.
   */
  get zoom() {
    return this._camera.zoom;
  }
  /**
   * Sets the zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @param value - The new zoom level of the minimap.
   */
  set zoom(t) {
    this._camera.zoom = t, this._camera.updateProjectionMatrix();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.onResize.reset(), this.overrideMaterial.dispose(), this.renderer.forceContextLoss(), this.renderer.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** Returns the camera used by the MiniMap */
  get() {
    return this._camera;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const t = this.world.scene.three, e = this.world.camera;
    if (!e.hasCameraControls())
      throw new Error("The given world must use camera controls!");
    if (!(t instanceof A.Scene))
      throw new Error("The given world must have a THREE.Scene as a root!");
    const s = e.controls;
    if (s.getPosition(this._tempVector1), this._camera.position.x = this._tempVector1.x, this._camera.position.z = this._tempVector1.z, this.frontOffset !== 0 && (s.getTarget(this._tempVector2), this._tempVector2.sub(this._tempVector1), this._tempVector2.normalize().multiplyScalar(this.frontOffset), this._camera.position.x += this._tempVector2.x, this._camera.position.z += this._tempVector2.z), !this._lockRotation) {
      s.getTarget(this._tempTarget);
      const n = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = n + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const i = t.background;
    t.background = this.backgroundColor, this.renderer.render(t, this._camera), t.background = i, this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return this._size;
  }
  /** {@link Resizeable.resize} */
  resize(t = this._size) {
    this._size.copy(t), this.renderer.setSize(t.x, t.y);
    const e = t.x / t.y, s = 1;
    this._camera.left = s * e / -2, this._camera.right = s * e / 2, this._camera.top = s / 2, this._camera.bottom = -1 / 2, this._camera.updateProjectionMatrix(), this.onResize.trigger(t);
  }
  /** {@link Configurable.setup} */
  setup(t) {
    const e = { ...this._defaultConfig, ...t };
    this.config.visible = !0, this.config.lockRotation = e.lockRotation, this.config.zoom = e.zoom, this.config.frontOffset = e.frontOffset, this.config.sizeX = e.sizeX, this.config.sizeY = e.sizeY, this.config.backgroundColor = e.backgroundColor, this.isSetup = !0, this.onSetup.trigger();
  }
}
const Dd = class tc extends ue {
  constructor(t) {
    super(t), y(this, "onAfterUpdate", new Y()), y(this, "onBeforeUpdate", new Y()), y(this, "onDisposed", new Y()), y(this, "onSetup", new Y()), y(this, "enabled", !0), y(this, "list", /* @__PURE__ */ new Map()), this.components.add(tc.uuid, this);
  }
  /**
   * Creates a new {@link MiniMap} instance associated with the given world.
   * If a {@link MiniMap} instance already exists for the given world, an error will be thrown.
   *
   * @param world - The {@link World} for which to create a {@link MiniMap} instance.
   * @returns The newly created {@link MiniMap} instance.
   * @throws Will throw an error if a {@link MiniMap} instance already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a minimap!");
    const e = new bd(t, this.components);
    return this.list.set(t.uuid, e), e;
  }
  /**
   * Deletes a {@link MiniMap} instance associated with the given world ID.
   * If a {@link MiniMap} instance does not exist for the given ID, nothing happens.
   *
   * @param id - The unique identifier of the world for which to delete the {@link MiniMap} instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t);
    e && e.dispose(), this.list.delete(t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update() {
    for (const [t, e] of this.list)
      e.update();
  }
};
y(Dd, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
const sc = class ic extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), t.add(ic.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(t, e, s, i = !1) {
    const n = new A.Line3(), r = new A.Vector3();
    return n.set(e, s), n.closestPointToPoint(t, i, r), r.distanceTo(t);
  }
  /**
   * Method to get the face of a mesh that contains a given triangle index.
   * It also returns the edges of the found face and their indices.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param triangleIndex - The index of the triangle within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the edges of the found face and their indices, or null if no face was found.
   */
  getFace(t, e, s) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const i = /* @__PURE__ */ new Map(), n = t.geometry.index.array, { plane: r } = this.getFaceData(
      e,
      s,
      t
    ), o = [];
    for (let f = 0; f < n.length / 3; f++) {
      const { plane: u, edges: d } = this.getFaceData(f, s, t);
      if (u.equals(r)) {
        o.push({ index: f, edges: d });
        for (const { id: p, points: m, distance: E } of d)
          i.set(p, { points: m, distance: E });
      }
    }
    let a = 0;
    const c = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map();
    for (const { index: f, edges: u } of o) {
      const d = /* @__PURE__ */ new Map();
      for (const { id: C } of u)
        if (c.has(C)) {
          const F = c.get(C);
          d.set(C, F);
        }
      const p = u.map((C) => C.id);
      if (!d.size) {
        const C = a++;
        for (const { id: F } of u)
          c.set(F, C);
        h.set(C, {
          edges: new Set(p),
          indices: /* @__PURE__ */ new Set([f])
        });
        continue;
      }
      let m = null;
      const E = /* @__PURE__ */ new Set(), I = new Set(p);
      for (const [C, F] of d) {
        m === null ? m = F : F !== m && E.add(F), c.delete(C);
        const { edges: O } = h.get(F);
        O.delete(C), I.delete(C);
      }
      if (m === null)
        throw new Error("Error computing face!");
      const g = h.get(m), { indices: T } = g;
      T.add(f);
      for (const C of I) {
        c.set(C, m);
        const { edges: F } = g;
        F.add(C);
      }
      for (const C of E) {
        const F = h.get(C), { edges: O, indices: P } = F, M = h.get(m), { edges: L, indices: b } = M;
        for (const B of O)
          L.add(B), c.set(B, m);
        for (const B of P)
          b.add(B);
        h.delete(C);
      }
    }
    for (const [f, { indices: u, edges: d }] of h)
      if (u.has(e)) {
        const p = [];
        for (const m of d) {
          const E = i.get(m);
          p.push(E);
        }
        return { edges: p, indices: u };
      }
    return null;
  }
  /**
   * Method to get the vertices and normal of a mesh face at a given index.
   * It also applies instance transformation if provided.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param faceIndex - The index of the face within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the vertices and normal of the face.
   * @throws Will throw an error if the geometry is not indexed.
   */
  getVerticesAndNormal(t, e, s) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const i = t.geometry.index.array, n = t.geometry.attributes.position.array, r = t.geometry.attributes.normal.array, o = i[e * 3] * 3, a = i[e * 3 + 1] * 3, c = i[e * 3 + 2] * 3, h = new A.Vector3(n[o], n[o + 1], n[o + 2]), f = new A.Vector3(n[a], n[a + 1], n[a + 2]), u = new A.Vector3(n[c], n[c + 1], n[c + 2]), d = new A.Vector3(r[o], r[o + 1], r[o + 2]), p = new A.Vector3(r[a], r[a + 1], r[a + 2]), m = new A.Vector3(r[c], r[c + 1], r[c + 2]), E = (d.x + p.x + m.x) / 3, I = (d.y + p.y + m.y) / 3, g = (d.z + p.z + m.z) / 3, T = new A.Vector3(E, I, g);
    if (s !== void 0 && t instanceof A.InstancedMesh) {
      const C = new A.Matrix4();
      t.getMatrixAt(s, C);
      const F = new A.Matrix4();
      F.extractRotation(C), T.applyMatrix4(F), h.applyMatrix4(C), f.applyMatrix4(C), u.applyMatrix4(C);
    }
    return { p1: h, p2: f, p3: u, faceNormal: T };
  }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
  /**
   * Calculates the volume of a set of fragments.
   *
   * @param frags - A map of fragment IDs to their corresponding item IDs.
   * @returns The total volume of the fragments and the bounding sphere.
   *
   * @remarks
   * This method creates a set of instanced meshes from the given fragments and item IDs.
   * It then calculates the volume of each mesh and returns the total volume and its bounding sphere.
   *
   * @throws Will throw an error if the geometry of the meshes is not indexed.
   * @throws Will throw an error if the fragment manager is not available.
   */
  getVolumeFromFragments(t) {
    const e = this.components.get(fe), s = new A.Matrix4(), i = [];
    for (const r in t) {
      const o = e.list.get(r);
      if (!o)
        continue;
      const a = t[r];
      let c = 0;
      for (const u of a) {
        const d = o.getInstancesIDs(u);
        d && (c += d.size);
      }
      const h = new A.InstancedMesh(
        o.mesh.geometry,
        void 0,
        c
      );
      let f = 0;
      for (const u of a) {
        const d = o.getInstancesIDs(u);
        if (d)
          for (const p of d)
            o.mesh.getMatrixAt(p, s), h.setMatrixAt(f++, s);
      }
      i.push(h);
    }
    const n = this.getVolumeFromMeshes(i);
    for (const r of i)
      r.geometry = null, r.material = [], r.dispose();
    return n;
  }
  /**
   * Calculates the total volume of a set of meshes.
   *
   * @param meshes - An array of meshes or instanced meshes to calculate the volume from.
   * @returns The total volume of the meshes and the bounding sphere.
   *
   * @remarks
   * This method calculates the volume of each mesh in the provided array and returns the total volume
   * and its bounding sphere.
   *
   */
  getVolumeFromMeshes(t) {
    let e = 0;
    for (const s of t)
      e += this.getVolumeOfMesh(s);
    return e;
  }
  getFaceData(t, e, s) {
    const i = this.getVerticesAndNormal(s, t, e), { p1: n, p2: r, p3: o, faceNormal: a } = i;
    this.round(n), this.round(r), this.round(o), this.round(a);
    const c = [
      { id: `${n.x}|${n.y}|${n.z}`, value: n },
      { id: `${r.x}|${r.y}|${r.z}`, value: r },
      { id: `${o.x}|${o.y}|${o.z}`, value: o }
    ];
    c.sort((g, T) => g.id < T.id ? -1 : g.id > T.id ? 1 : 0);
    const [
      { id: h, value: f },
      { id: u, value: d },
      { id: p, value: m }
    ] = c, E = [
      {
        id: `${h}|${u}`,
        distance: f.distanceTo(d),
        points: [f, d]
      },
      {
        id: `${u}|${p}`,
        distance: d.distanceTo(m),
        points: [d, m]
      },
      {
        id: `${h}|${p}`,
        distance: f.distanceTo(m),
        points: [f, m]
      }
    ], I = new A.Plane();
    return I.setFromNormalAndCoplanarPoint(a, n), I.constant = Math.round(I.constant * 10) / 10, { plane: I, edges: E };
  }
  // https://stackoverflow.com/a/1568551
  getVolumeOfMesh(t) {
    let e = 0;
    const s = new A.Vector3(), i = new A.Vector3(), n = new A.Vector3(), { index: r } = t.geometry, o = t.geometry.attributes.position.array;
    if (!r)
      return console.warn("Geometry must be indexed to compute its volume!"), 0;
    const a = [];
    if (t instanceof A.InstancedMesh)
      for (let h = 0; h < t.count; h++) {
        const f = new A.Matrix4();
        t.getMatrixAt(h, f), a.push(f);
      }
    else
      a.push(new A.Matrix4().identity());
    const { matrixWorld: c } = t;
    for (let h = 0; h < r.array.length - 2; h += 3)
      for (const f of a) {
        const u = f.multiply(c), d = r.array[h] * 3, p = r.array[h + 1] * 3, m = r.array[h + 2] * 3;
        s.set(o[d], o[d + 1], o[d + 2]).applyMatrix4(u), i.set(o[p], o[p + 1], o[p + 2]).applyMatrix4(u), n.set(o[m], o[m + 1], o[m + 2]).applyMatrix4(u), e += this.getSignedVolumeOfTriangle(s, i, n);
      }
    return Math.abs(e);
  }
  getSignedVolumeOfTriangle(t, e, s) {
    const i = s.x * e.y * t.z, n = e.x * s.y * t.z, r = s.x * t.y * e.z, o = t.x * s.y * e.z, a = e.x * t.y * s.z, c = t.x * e.y * s.z;
    return 1 / 6 * (-i + n + r - o - a + c);
  }
};
y(sc, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
let hs = sc;
class Xn {
  constructor(t) {
    y(this, "cardinality", "required"), y(this, "instructions"), y(this, "evalRequirement", (e, s, i, n) => {
      const r = {
        parameter: i,
        currentValue: e,
        requiredValue: s.parameter,
        pass: !1
      };
      n && this.addCheckResult(r, n);
      let o = !1;
      if (s.type === "simple" && (o = e === s.parameter), s.type === "enumeration" && (o = s.parameter.includes(e)), s.type === "pattern" && (o = new RegExp(s.parameter).test(String(e))), s.type === "length") {
        const { min: a, length: c, max: h } = s.parameter;
        c !== void 0 && (o = String(e).length === c), a !== void 0 && (o = String(e).length >= a), h !== void 0 && (o = String(e).length <= h);
      }
      if (s.type === "bounds" && typeof e == "number") {
        const { min: a, minInclusive: c, max: h, maxInclusive: f } = s.parameter;
        let u = !0, d = !0;
        a !== void 0 && (u = c ? e >= a : e > a), h !== void 0 && (d = f ? e <= h : e < h), o = u && d;
      }
      return this.cardinality === "prohibited" && (o = !o), this.cardinality === "optional" && (o = !0), r.pass = o, r.pass;
    }), y(this, "testResult", []), this.components = t;
  }
  addCheckResult(t, e) {
    const s = e.findIndex(
      ({ parameter: i }) => i === t.parameter
    );
    s !== -1 ? e[s] = t : e.push(t);
  }
  saveResult(t, e) {
    const { GlobalId: s } = t;
    if (!s)
      return;
    const { value: i } = s, n = {
      expressID: i,
      pass: e,
      checks: [],
      cardinality: this.cardinality
    };
    this.testResult.push(n);
  }
}
const Ut = (l, t) => {
  let e = "";
  if (!t)
    return e;
  if (t.type === "simple" && (e = `<simpleValue>${t.parameter}</simpleValue>`), t.type === "enumeration" && (e = `<xs:restriction base="xs:string">
    ${t.parameter.map((n) => `<xs:enumeration value="${n}" />`).join(`
`)}
    </xs:restriction>`), t.type === "pattern" && (e = `<xs:restriction base="xs:string">
      <xs:pattern value="${t.parameter}" />
    </xs:restriction>`), t.type === "bounds") {
    const { min: i, minInclusive: n, max: r, maxInclusive: o } = t.parameter;
    let a = "";
    i !== void 0 && (a = `<xs:min${n ? "Inclusive" : "Exclusive"} value="${i}">`);
    let c = "";
    r !== void 0 && (c = `<xs:max${o ? "Inclusive" : "Exclusive"} value="${r}">`), e = `<xs:restriction base="xs:double">
      ${a}
      ${c}
    </xs:restriction>`;
  }
  if (t.type === "length") {
    const { length: i, min: n, max: r } = t.parameter;
    let o = "";
    i !== void 0 && n === void 0 && r === void 0 && (o = `<xs:length value="${i}" />`);
    let a = "";
    n !== void 0 && i === void 0 && (a = `<xs:minLength value="${n}" />`);
    let c = "";
    r !== void 0 && i === void 0 && (c = `<xs:maxLength value="${r}" />`), e = `<xs:restriction base="xs:string">
      ${o}
      ${a}
      ${c}
    </xs:restriction>`;
  }
  return `<${l[0].toLowerCase() + l.slice(1)}>
    ${e}
  </${l[0].toLowerCase() + l.slice(1)}>`;
};
class _d extends Xn {
  constructor(t, e) {
    super(t), y(this, "facetType", "Attribute"), y(this, "name"), y(this, "value"), this.name = e;
  }
  serialize(t) {
    const e = Ut("Name", this.name), s = Ut("Value", this.value);
    let i = "";
    return t === "requirement" && (i += `cardinality="${this.cardinality}"`, i += this.instructions ? `instructions="${this.instructions}"` : ""), `<attribute ${i}>
  ${e}
  ${s}
</attribute>`;
  }
  // This can be very ineficcient as we do not have an easy way to get an entity based on an attribute
  // Right now, all entities must be iterated.
  // When the new IfcEntitiesFinder comes, this can become easier.
  // This may be greatly increase in performance if the applicability has any of the other facets and this is applied the latest
  async getEntities() {
    return [];
  }
  // async getEntities(
  //   model: FRAGS.FragmentsGroup,
  //   collector: FRAGS.IfcProperties = {},
  // ) {
  //   return [];
  //   // for (const expressID in model) {
  //   //   if (collector[expressID]) continue;
  //   //   const entity = model[expressID];
  //   //   // Check if the attribute exists
  //   //   const attribute = entity[this.name];
  //   //   const attributeExists = !!attribute;
  //   //   // Check if the attribute value matches
  //   //   let valueMatches = true;
  //   //   if (attributeExists && this.value && this.value.value) {
  //   //     if (this.value.type === "simpleValue") {
  //   //       valueMatches = attribute.value === this.value.value;
  //   //     }
  //   //     if (this.value.type === "restriction") {
  //   //       const regex = new RegExp(this.value.value);
  //   //       valueMatches = regex.test(attribute.value);
  //   //     }
  //   //   }
  //   //   if (attributeExists && valueMatches) {
  //   //     collector[entity.expressID] = entity;
  //   //   }
  //   // }
  // }
  // https://github.com/buildingSMART/IDS/tree/development/Documentation/ImplementersDocumentation/TestCases/attribute
  // Test cases from buildingSMART repo have been tested and they all match with the expected result
  // All invalid cases have been treated as failures
  // FragmentsGroup do not hold some of the entities used in the tests
  async test(t) {
    var e;
    this.testResult = [];
    for (const i in t) {
      const n = Number(i), r = t[n], o = [], a = {
        guid: (e = r.GlobalId) == null ? void 0 : e.value,
        expressID: n,
        pass: !1,
        checks: o,
        cardinality: this.cardinality
      };
      this.testResult.push(a);
      const h = Object.keys(r).filter((u) => {
        const d = this.evalRequirement(u, this.name, "Name"), p = r[u];
        return d && p === null ? this.cardinality === "optional" || this.cardinality === "prohibited" : d && (p == null ? void 0 : p.type) === 3 && p.value === 2 || d && Array.isArray(p) && p.length === 0 || d && (p == null ? void 0 : p.type) === 1 && p.value.trim() === "" ? !1 : d;
      }), f = h.length > 0;
      if (o.push({
        parameter: "Name",
        currentValue: f ? h[0] : null,
        requiredValue: this.name.parameter,
        pass: this.cardinality === "prohibited" ? !f : f
      }), this.value)
        if (h[0]) {
          const u = r[h[0]];
          (u == null ? void 0 : u.type) === 5 ? o.push({
            parameter: "Value",
            currentValue: null,
            requiredValue: this.value.parameter,
            pass: this.cardinality === "prohibited"
          }) : this.evalRequirement(
            u ? u.value : null,
            this.value,
            "Value",
            o
          );
        } else
          o.push({
            parameter: "Value",
            currentValue: null,
            requiredValue: this.value.parameter,
            pass: this.cardinality === "prohibited"
          });
      a.pass = o.every(({ pass: u }) => u);
    }
    const s = [...this.testResult];
    return this.testResult = [], s;
  }
}
class Ud extends Xn {
  constructor(t, e) {
    super(t), y(this, "facetType", "Classification"), y(this, "system"), y(this, "value"), y(this, "uri"), this.system = e;
  }
  serialize(t) {
    const e = Ut("System", this.system), s = Ut("Value", this.value);
    let i = "";
    return t === "requirement" && (i += `cardinality="${this.cardinality}"`, i += this.uri ? `uri=${this.uri}` : "", i += this.instructions ? `instructions="${this.instructions}"` : ""), `<classification ${i}>
  ${e}
  ${s}
</classification>`;
  }
  async getEntities(t, e = {}) {
    var s;
    const i = [], n = await t.getAllPropertiesOfType(
      W.IFCCLASSIFICATIONREFERENCE
    ), r = await t.getAllPropertiesOfType(
      W.IFCCLASSIFICATION
    ), o = { ...n, ...r }, a = [];
    for (const h in o) {
      const f = Number(h), u = await t.getProperties(f);
      if (!u)
        continue;
      const d = (s = u.ReferencedSource) == null ? void 0 : s.value;
      if (!d)
        continue;
      const p = await t.getProperties(d);
      !p || !this.evalSystem(p) || !this.evalValue(u) || !this.evalURI(u) || a.push(f);
    }
    const c = this.components.get(et);
    for (const h of a) {
      const f = c.getEntitiesWithRelation(
        t,
        "HasAssociations",
        h
      );
      for (const u of f) {
        if (u in e)
          continue;
        const d = await t.getProperties(u);
        d && (e[u] = d, i.push(u));
      }
    }
    return i;
  }
  async test(t, e) {
    var s;
    this.testResult = [];
    for (const n in t) {
      const r = Number(n), o = t[r], a = [], c = {
        guid: (s = o.GlobalId) == null ? void 0 : s.value,
        expressID: r,
        pass: !1,
        checks: a,
        cardinality: this.cardinality
      };
      this.testResult.push(c);
      let h = !0;
      const f = await this.getSystems(e, r), u = f.map((d) => this.getSystemName(d)).filter((d) => d);
      for (const d of f) {
        if (!this.evalSystem(d, a))
          continue;
        if (h = !1, !(this.value && this.system))
          break;
        if (d.type !== W.IFCCLASSIFICATIONREFERENCE)
          continue;
        const m = !this.value || this.evalValue(d, a), E = !this.uri || this.evalURI(d, a);
        if (m && E)
          break;
      }
      h && this.addCheckResult(
        {
          parameter: "System",
          currentValue: u,
          requiredValue: this.system,
          pass: this.cardinality === "optional"
        },
        a
      ), c.pass = a.every(({ pass: d }) => d);
    }
    const i = [...this.testResult];
    return this.testResult = [], i;
  }
  async processReferencedSource(t, e) {
    var s;
    const i = (s = e.ReferencedSource) == null ? void 0 : s.value;
    if (!i)
      return null;
    const n = await t.getProperties(i);
    return n ? (n.type === W.IFCCLASSIFICATIONREFERENCE && (n.ReferencedSource = await this.processReferencedSource(
      t,
      n
    )), n) : null;
  }
  async getSystems(t, e) {
    var s;
    const i = [], n = this.components.get(et), r = n.getEntityRelations(
      t,
      e,
      "HasAssociations"
    );
    if (r)
      for (const f of r) {
        const u = await t.getProperties(f);
        u && (u.type === W.IFCCLASSIFICATION && i.push(u), u.type === W.IFCCLASSIFICATIONREFERENCE && (u.ReferencedSource = await this.processReferencedSource(
          t,
          u
        ), u.ReferencedSource && i.push(u)));
      }
    const o = i.map((f) => {
      var u, d, p;
      return f.type === W.IFCCLASSIFICATION ? (u = f.Name) == null ? void 0 : u.value : f.type === W.IFCCLASSIFICATIONREFERENCE ? (p = (d = f.ReferencedSource) == null ? void 0 : d.Name) == null ? void 0 : p.value : null;
    }).filter((f) => f), a = n.getEntityRelations(t, e, "IsTypedBy");
    if (!(a && a[0]))
      return i;
    const c = a[0], h = n.getEntityRelations(
      t,
      c,
      "HasAssociations"
    );
    if (h)
      for (const f of h) {
        const u = await t.getProperties(f);
        if (u) {
          if (u.type === W.IFCCLASSIFICATION) {
            if (o.includes((s = u.Name) == null ? void 0 : s.value))
              continue;
            i.push(u);
          }
          u.type === W.IFCCLASSIFICATIONREFERENCE && (u.ReferencedSource = await this.processReferencedSource(
            t,
            u
          ), u.ReferencedSource && i.push(u));
        }
      }
    return i;
  }
  getSystemName(t) {
    var e, s, i, n;
    if (t.type === W.IFCCLASSIFICATION)
      return (e = t.Name) == null ? void 0 : e.value;
    if (t.type === W.IFCCLASSIFICATIONREFERENCE) {
      if (((s = t.ReferencedSource) == null ? void 0 : s.type) === W.IFCCLASSIFICATIONREFERENCE)
        return this.getSystemName(t.ReferencedSource);
      if (((i = t.ReferencedSource) == null ? void 0 : i.type) === W.IFCCLASSIFICATION)
        return (n = t.ReferencedSource.Name) == null ? void 0 : n.value;
    }
    return null;
  }
  getAllReferenceIdentifications(t) {
    if (t.type !== W.IFCCLASSIFICATIONREFERENCE)
      return null;
    const e = [];
    if (t.Identification && e.push(t.Identification.value), t.ReferencedSource) {
      const s = this.getAllReferenceIdentifications(
        t.ReferencedSource
      );
      s && e.push(...s);
    }
    return e;
  }
  evalSystem(t, e) {
    const s = this.getSystemName(t);
    return this.evalRequirement(s, this.system, "System", e);
  }
  evalValue(t, e) {
    if (!this.value)
      return !0;
    const s = this.getAllReferenceIdentifications(t);
    if (!s)
      return !1;
    const i = s.find((n) => this.value ? this.evalRequirement(n, this.value, "Value") : !1);
    return e && this.addCheckResult(
      {
        parameter: "Value",
        currentValue: i ?? null,
        requiredValue: this.value,
        pass: !!i
      },
      e
    ), !!i;
  }
  evalURI(t, e) {
    var s;
    return this.uri ? this.evalRequirement(
      (s = t.Location) == null ? void 0 : s.value,
      {
        type: "simple",
        parameter: this.uri
      },
      "URI",
      e
    ) : !0;
  }
}
class Bd extends Xn {
  constructor(t, e) {
    super(t), y(this, "facetType", "Entity"), y(this, "name"), y(this, "predefinedType"), this.name = e;
  }
  serialize(t) {
    const e = Ut("Name", this.name), s = Ut("Name", this.predefinedType);
    let i = "";
    return t === "requirement" && (i += `cardinality="${this.cardinality}"`, i += this.instructions ? `instructions="${this.instructions}"` : ""), `<entity ${i}>
  ${e}
  ${s}
</entity>`;
  }
  // IFCSURFACESTYLEREFRACTION is not present in the FragmentsGroup
  // IFCSURFACESTYLERENDERING is not present in the FragmentsGroup
  async getEntities(t, e = {}) {
    const s = Object.entries(Cn), i = [];
    for (const [o] of s)
      await this.evalName({ type: o }) && i.push(Number(o));
    let n = {};
    for (const o of i) {
      const a = await t.getAllPropertiesOfType(o);
      a && (n = { ...n, ...a });
    }
    if (!this.predefinedType) {
      for (const o in n)
        o in e || (e[o] = n[o]);
      return Object.keys(n).map(Number);
    }
    const r = [];
    for (const o in n) {
      const a = Number(o);
      if (a in e)
        continue;
      const c = n[a];
      await this.evalPredefinedType(t, c) && (e[a] = c, r.push(a));
    }
    return r;
  }
  async test(t, e) {
    var s;
    this.testResult = [];
    for (const i in t) {
      const n = Number(i), r = t[n], o = [], a = {
        guid: (s = r.GlobalId) == null ? void 0 : s.value,
        expressID: n,
        pass: !1,
        checks: o,
        cardinality: this.cardinality
      };
      this.testResult.push(a), await this.evalName(r, o), await this.evalPredefinedType(e, r, o), a.pass = o.every(({ pass: c }) => c);
    }
    return this.testResult;
  }
  async evalName(t, e) {
    const s = Cn[t.type];
    return this.evalRequirement(s, this.name, "Name", e);
  }
  async evalPredefinedType(t, e, s) {
    var i, n, r, o;
    if (!this.predefinedType)
      return null;
    const a = this.components.get(et), c = typeof this.predefinedType.parameter == "string" && this.predefinedType.parameter === "USERDEFINED";
    let h = (i = e.PredefinedType) == null ? void 0 : i.value;
    if (h === "USERDEFINED" && !c) {
      const d = Object.keys(e).find(
        (p) => /^((?!Predefined).)*Type$/.test(p)
      );
      h = d ? (n = e[d]) == null ? void 0 : n.value : "USERDEFINED";
    }
    if (!h) {
      const u = a.getEntityRelations(
        t,
        e.expressID,
        "IsTypedBy"
      );
      if (u && u[0]) {
        const d = await t.getProperties(u[0]);
        if (d && (h = (r = d.PredefinedType) == null ? void 0 : r.value, h === "USERDEFINED" && !c)) {
          const m = Object.keys(d).find(
            (E) => /^((?!Predefined).)*Type$/.test(E)
          );
          h = m ? (o = d[m]) == null ? void 0 : o.value : "USERDEFINED";
        }
      }
    }
    return this.evalRequirement(
      h,
      this.predefinedType,
      "PredefinedType",
      s
    );
  }
}
class Vd extends Xn {
  constructor(t, e, s) {
    super(t), y(this, "facetType", "Property"), y(this, "propertySet"), y(this, "baseName"), y(this, "value"), y(this, "dataType"), y(this, "uri"), y(this, "_unsupportedTypes", [
      W.IFCCOMPLEXPROPERTY,
      W.IFCPHYSICALCOMPLEXQUANTITY
    ]), this.propertySet = e, this.baseName = s;
  }
  serialize(t) {
    const e = Ut("PropertySet", this.propertySet), s = Ut("BaseName", this.baseName), i = Ut("Value", this.value), n = this.dataType ? `dataType=${this.dataType}` : "";
    let r = "";
    return t === "requirement" && (r += `cardinality="${this.cardinality}"`, r += this.uri ? `uri=${this.uri}` : "", r += this.instructions ? `instructions="${this.instructions}"` : ""), `<property ${n} ${r}>
  ${e}
  ${s}
  ${i}
</property>`;
  }
  async getEntities(t, e = {}) {
    var s, i;
    let n = {};
    const r = await t.getAllPropertiesOfType(W.IFCPROPERTYSET);
    n = { ...n, ...r };
    const o = await t.getAllPropertiesOfType(W.IFCELEMENTQUANTITY);
    if (n = { ...n, ...o }, Object.keys(n).length === 0)
      return [];
    const a = [];
    for (const h in n) {
      const f = Number(h), u = await t.getProperties(f);
      if (!u || !(((s = u.Name) == null ? void 0 : s.value) === this.propertySet.parameter))
        continue;
      let p;
      if (u.type === W.IFCPROPERTYSET && (p = "HasProperties"), u.type === W.IFCELEMENTQUANTITY && (p = "Quantities"), !!p)
        for (const m of u[p]) {
          const E = await t.getProperties(m.value);
          if (!(!E || !(((i = E.Name) == null ? void 0 : i.value) === this.baseName.parameter))) {
            if (this.value) {
              const g = Object.keys(E).find(
                (C) => C.endsWith("Value")
              );
              if (!g || !(E[g].value === this.value.parameter))
                continue;
            }
            a.push(f);
          }
        }
    }
    const c = this.components.get(et);
    for (const h of a) {
      const f = c.getEntitiesWithRelation(
        t,
        "IsDefinedBy",
        h
      );
      for (const u of f) {
        if (u in e)
          continue;
        const d = await t.getProperties(u);
        d && (e[u] = d);
      }
    }
    return [];
  }
  async test(t, e) {
    var s;
    this.testResult = [];
    for (const n in t) {
      const r = Number(n), o = t[r], a = [], c = {
        guid: (s = o.GlobalId) == null ? void 0 : s.value,
        expressID: r,
        pass: !1,
        checks: a,
        cardinality: this.cardinality
      };
      this.testResult.push(c);
      const f = (await this.getPsets(e, r)).filter((u) => this.evalRequirement(
        u.Name ?? null,
        this.propertySet,
        "PropertySet"
      ) ? (a.push({
        currentValue: u.Name,
        parameter: "PropertySet",
        pass: !0,
        requiredValue: this.propertySet.parameter
      }), !0) : !1);
      if (f.length === 0) {
        a.push({
          currentValue: null,
          parameter: "PropertySet",
          pass: !1,
          requiredValue: this.propertySet.parameter
        });
        continue;
      }
      for (const u of f) {
        if (!("Properties" in u)) {
          a.push({
            currentValue: null,
            parameter: "BaseName",
            pass: !1,
            requiredValue: this.baseName.parameter
          });
          continue;
        }
        const p = u.Properties.filter((m) => {
          var E;
          return this._unsupportedTypes.includes(m.type) || !this.evalRequirement(
            ((E = m.Name) == null ? void 0 : E.value) ?? null,
            this.baseName,
            "BaseName"
          ) ? !1 : (a.push({
            currentValue: m.Name.value,
            parameter: "BaseName",
            pass: !0,
            requiredValue: this.baseName.parameter
          }), !0);
        });
        if (p.length === 0) {
          a.push({
            currentValue: null,
            parameter: "BaseName",
            pass: !1,
            requiredValue: this.baseName.parameter
          });
          continue;
        }
        for (const m of p)
          this.evalValue(m, a), this.evalDataType(m, a), this.evalURI();
      }
      c.pass = a.every(({ pass: u }) => u);
    }
    const i = [...this.testResult];
    return this.testResult = [], i;
  }
  getItemsAttrName(t) {
    let e;
    return t === W.IFCPROPERTYSET && (e = "HasProperties"), t === W.IFCELEMENTQUANTITY && (e = "Quantities"), e;
  }
  getValueKey(t) {
    return Object.keys(t).find(
      (e) => e.endsWith("Value") || e.endsWith("Values")
    );
  }
  async simplifyPset(t, e, s) {
    var i;
    const n = [], r = e[s];
    if (!r)
      return e;
    for (const { value: a } of r) {
      const c = await t.getProperties(a);
      c && n.push(c);
    }
    return {
      Name: (i = e.Name) == null ? void 0 : i.value,
      Properties: n,
      type: e.type
    };
  }
  async getTypePsets(t, e) {
    const s = [], n = this.components.get(et).getEntityRelations(t, e, "IsTypedBy");
    if (!(n && n[0]))
      return s;
    const r = await t.getProperties(n[0]);
    if (!(r && "HasPropertySets" in r && Array.isArray(r.HasPropertySets)))
      return s;
    for (const { value: o } of r.HasPropertySets) {
      const a = await t.getProperties(o);
      if (!(a && "HasProperties" in a && Array.isArray(a.HasProperties)))
        continue;
      const c = await this.simplifyPset(t, a, "HasProperties");
      s.push(c);
    }
    return s;
  }
  async getPsets(t, e) {
    var s;
    const i = await this.getTypePsets(t, e), r = this.components.get(et).getEntityRelations(
      t,
      e,
      "IsDefinedBy"
    );
    if (!r)
      return i;
    const o = [];
    for (const a of r) {
      const c = await t.getProperties(a);
      if (!c)
        continue;
      const h = this.getItemsAttrName(c.type);
      if (!h)
        continue;
      const f = await this.simplifyPset(
        t,
        c,
        h
      ), u = i.find(
        ({ Name: d }) => d === f.Name
      );
      if (u)
        for (const d of u.Properties) {
          const p = (s = d.Name) == null ? void 0 : s.value;
          f.Properties.find(
            ({ Name: E }) => E.value === p
          ) || f.Properties.push(d);
        }
      o.push(f);
    }
    return o;
  }
  // IFCPROPERTYBOUNDEDVALUE are not supported yet
  // IFCPROPERTYTABLEVALUE are not supported yet
  // Work must to be done to convert numerical value units to IDS-nominated standard units https://github.com/buildingSMART/IDS/blob/development/Documentation/UserManual/units.md
  evalValue(t, e) {
    const s = this.getValueKey(t), i = t[s];
    if (this.value) {
      if (!i)
        return e == null || e.push({
          parameter: "Value",
          currentValue: null,
          pass: !1,
          requiredValue: this.value.parameter
        }), !1;
      const n = structuredClone(this.value);
      if (i.name === "IFCLABEL" && n.type === "simple" && (n.parameter = String(n.parameter)), (t.type === W.IFCPROPERTYLISTVALUE || t.type === W.IFCPROPERTYENUMERATEDVALUE) && Array.isArray(i)) {
        const o = i.map((c) => c.value), a = i.find((c) => n ? this.evalRequirement(c.value, n, "Value") : !1);
        return e == null || e.push({
          currentValue: o,
          pass: !!a,
          parameter: "Value",
          requiredValue: n.parameter
        }), !!a;
      }
      return this.evalRequirement(
        i.value,
        n,
        "Value",
        e
      );
    }
    return s ? i.type === 3 && i.value === 2 ? (e == null || e.push({
      parameter: "Value",
      currentValue: null,
      pass: !1,
      requiredValue: null
    }), !1) : i.type === 1 && i.value.trim() === "" ? (e == null || e.push({
      parameter: "Value",
      currentValue: "",
      pass: !1,
      requiredValue: null
    }), !1) : !0 : !0;
  }
  evalDataType(t, e) {
    if (!this.dataType)
      return !0;
    const s = this.getValueKey(t), i = t[s];
    if (!i)
      return e == null || e.push({
        parameter: "DataType",
        currentValue: null,
        pass: !1,
        requiredValue: this.dataType
      }), !1;
    if ((t.type === W.IFCPROPERTYLISTVALUE || t.type === W.IFCPROPERTYENUMERATEDVALUE) && Array.isArray(i) && i[0]) {
      const r = i[0].name;
      return this.evalRequirement(
        r,
        {
          type: "simple",
          parameter: this.dataType
        },
        "DataType",
        e
      );
    }
    return this.evalRequirement(
      i.name,
      {
        type: "simple",
        parameter: this.dataType
      },
      "DataType",
      e
    );
  }
  evalURI() {
    return !0;
  }
}
class zd {
  constructor(t, e, s) {
    y(this, "name"), y(this, "ifcVersion", /* @__PURE__ */ new Set()), y(this, "identifier", zt.create()), y(this, "description"), y(this, "instructions"), y(this, "requirementsDescription"), y(this, "applicability", new qt()), y(this, "requirements", new qt()), y(this, "components"), this.components = t, this.name = e;
    for (const i of s)
      this.ifcVersion.add(i);
  }
  set(t) {
    const e = t, s = this;
    for (const n in t) {
      if (n === "identifier")
        continue;
      const r = e[n];
      n in this && (s[n] = r);
    }
    return this.components.get(Hd).list.set(this.identifier, this), this;
  }
  /**
   * Tests the model to test against the specification's requirements.
   *
   * @param model - The model to be tested.
   * @returns An array representing the test results.
   * If no requirements are defined for the specification, an empty array is returned.
   */
  async test(t) {
    let e = [];
    if (this.requirements.size === 0)
      return e;
    const s = {};
    for (const n of this.applicability)
      await n.getEntities(t, s);
    return e = await [...this.requirements][0].test(s, t), e;
  }
  /**
   * Serializes the IDSSpecification instance into XML format.
   *
   * @remarks This method is not meant to be used directly. It is used by the IDSSpecifications component.
   *
   * @returns The XML representation of the IDSSpecification.
   */
  serialize() {
    const t = `name="${this.name}"`, e = this.identifier ? `identifier="${this.identifier}"` : "", s = this.description ? `description="${this.description}"` : "", i = this.instructions ? `instructions="${this.instructions}"` : "";
    return `<specification ifcVersion="${[...this.ifcVersion].join(" ")}" ${t} ${e} ${s} ${i}>
      <applicability minOccurs="1" maxOccurs="unbounded">
        ${[...this.applicability].map((r) => r.serialize("applicability")).join(`
`)}
      </applicability>
      <requirements>
        ${[...this.requirements].map((r) => r.serialize("requirement")).join(`
`)}
      </requirements>
    </specification>`;
  }
}
const Bt = (l) => {
  if (!l)
    return;
  const t = {};
  if ("simpleValue" in l && (t.type = "simple", t.parameter = l.simpleValue), "restriction" in l) {
    const e = l.restriction;
    if ("pattern" in e && (t.type = "pattern", t.parameter = e.pattern.value), "enumeration" in e) {
      t.type = "enumeration";
      const s = e.enumeration.map(
        ({ value: i }) => i
      );
      t.parameter = s;
    }
  }
  if (t.parameter !== void 0)
    return t;
}, ma = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.name, n = Bt(i);
    if (!n)
      continue;
    const r = new Bd(l, n);
    s.cardinality && (r.cardinality = s.cardinality), r.predefinedType = Bt(s.predefinedType), r.instructions = s.instructions, e.push(r);
  }
  return e;
}, kd = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.name, n = Bt(i);
    if (!n)
      continue;
    const r = new _d(l, n);
    s.cardinality && (r.cardinality = s.cardinality), r.value = Bt(s.value), r.instructions = s.instructions, e.push(r);
  }
  return e;
}, Gd = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.system, n = Bt(i);
    if (!n)
      continue;
    const r = new Ud(l, n);
    s.cardinality && (r.cardinality = s.cardinality);
    const o = Bt(s.value);
    (o == null ? void 0 : o.type) === "simple" && (o.parameter = String(o.parameter)), (o == null ? void 0 : o.type) === "enumeration" && Array.isArray(o.parameter) && (o.parameter = o.parameter.map(String)), r.value = o, r.uri = s.uri, r.instructions = s.instructions, e.push(r);
  }
  return e;
}, Yd = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.propertySet, n = s.baseName, r = Bt(i), o = Bt(n);
    if (!(o && r))
      continue;
    const a = new Vd(l, r, o);
    s.cardinality && (a.cardinality = s.cardinality);
    const c = Bt(s.value);
    (c == null ? void 0 : c.type) === "enumeration" && Array.isArray(c.parameter) && (c.parameter = c.parameter.map(String)), a.value = c, a.dataType = s.dataType, a.uri = s.uri, a.instructions = s.instructions, e.push(a);
  }
  return e;
}, uo = class Zr extends ue {
  constructor(t) {
    super(t), y(this, "enabled", !0), y(this, "list", new mt()), t.add(Zr.uuid, this);
  }
  /**
   * Retrieves a FragmentIdMap based on the given IDSCheckResult array.
   * The map separates the IDs into two categories: pass and fail.
   *
   * @param model - The FragmentsGroup model from which to retrieve the fragment map.
   * @param result - An array of IDSCheckResult objects, each representing a check result.
   *
   * @returns An object containing two properties:
   * - `pass`: A FragmentIdMap that passed the checks.
   * - `fail`: A FragmentIdMap that failed the checks.
   */
  getFragmentIdMap(t, e) {
    const i = e.filter((c) => c.pass).map((c) => c.expressID), n = t.getFragmentMap(i), o = e.filter((c) => !c.pass).map((c) => c.expressID), a = t.getFragmentMap(o);
    return { pass: n, fail: a };
  }
  /**
   * Creates a new IDSSpecification instance and adds it to the list.
   *
   * @param name - The name of the IDSSpecification.
   * @param ifcVersion - An array of IfcVersion values that the specification supports.
   *
   * @returns The newly created IDSSpecification instance.
   */
  create(t, e, s) {
    const i = new zd(
      this.components,
      t,
      e
    );
    return s && (i.identifier = s), this.list.set(i.identifier, i), i;
  }
  /**
   * Parses and processes an XML string containing Information Delivery Specification (IDS) data.
   * It creates IDSSpecification instances based on the parsed data and returns them in an array.
   * Also, the instances are added to the list array.
   *
   * @param data - The XML string to parse.
   *
   * @returns An array of IDSSpecification instances created from the parsed data.
   */
  load(t) {
    const e = [], s = Zr.xmlParser.parse(t).ids, { specifications: i } = s;
    if (i && i.specification) {
      const n = Array.isArray(i.specification) ? i.specification : [i.specification];
      for (const r of n) {
        const { name: o, ifcVersion: a, description: c, instructions: h, identifier: f } = r;
        if (!(o && a))
          continue;
        const u = [], d = [], { applicability: p, requirements: m } = r;
        if (p) {
          const { maxOccurs: I, ...g } = p, T = Array.isArray(g) ? g : [g];
          for (const C of T)
            for (const F in C) {
              const O = Array.isArray(C[F]) ? C[F] : [C[F]];
              if (F === "entity") {
                const P = ma(this.components, O);
                u.push(...P);
              }
            }
        }
        let E;
        if (m) {
          const { maxOccurs: I, ...g } = m;
          E = m.description;
          const T = Array.isArray(g) ? g : [g];
          for (const C of T)
            for (const F in C) {
              const O = Array.isArray(C[F]) ? C[F] : [C[F]];
              if (F === "entity") {
                const P = ma(this.components, O);
                d.push(...P);
              }
              if (F === "attribute") {
                const P = kd(this.components, O);
                d.push(...P);
              }
              if (F === "classification") {
                const P = Gd(
                  this.components,
                  O
                );
                d.push(...P);
              }
              if (F === "property") {
                const P = Yd(this.components, O);
                d.push(...P);
              }
            }
        }
        if (u.length > 0 && d.length > 0) {
          const I = this.create(
            o,
            a.split(/\s+/),
            f
          );
          I.description = c, I.instructions = h, I.requirementsDescription = E, I.applicability.add(...u), I.requirements.add(...d), e.push(I);
        }
      }
    }
    return e;
  }
  /**
   * Exports the IDSSpecifications data into an XML string.
   *
   * @param info - The metadata information for the exported XML.
   * @param specifications - An optional iterable of IDSSpecification instances to export.
   * If not provided, all specifications in the list will be exported.
   *
   * @returns A string containing the exported IDSSpecifications data in XML format.
   */
  export(t, e = this.list.values()) {
    const s = e ?? this.list;
    return `<ids xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://standards.buildingsmart.org/IDS http://standards.buildingsmart.org/IDS/1.0/ids.xsd" xmlns:ids="http://standards.buildingsmart.org/IDS">
  <!-- Made with That Open Engine ${nl.release} (https://github.com/thatopen/engine_components) -->
  <info>
    <title>${t.title}</title>
    ${t.copyright ? `<copyright>${t.copyright}</copyright>` : ""}
    ${t.version ? `<version>${t.version}</version>` : ""}
    ${t.description ? `<description>${t.description}</description>` : ""}
    ${t.author ? `<author>${t.author}</author>` : ""}
    ${t.date ? `<date>${t.date.toISOString().split("T")[0]}</date>` : ""}
    ${t.purpose ? `<purpose>${t.purpose}</purpose>` : ""}
    ${t.milestone ? `<milestone>${t.milestone}</milestone>` : ""}
  </info>
  <specifications>
    ${[...s].map((n) => n.serialize()).join(`
`)}
  </specifications>
</ids>`;
  }
};
y(uo, "uuid", "9f0b9f78-9b2e-481a-b766-2fbfd01f342c");
y(uo, "xmlParser", new _l.XMLParser({
  allowBooleanAttributes: !0,
  attributeNamePrefix: "",
  ignoreAttributes: !1,
  ignoreDeclaration: !0,
  ignorePiTags: !0,
  numberParseOptions: { leadingZeros: !0, hex: !0 },
  parseAttributeValue: !0,
  preserveOrder: !1,
  processEntities: !1,
  removeNSPrefix: !0,
  trimValues: !0
}));
let Hd = uo;
const Ia = new qe(), rn = new q();
class nc extends wc {
  /**
   * Constructs a new line segments geometry.
   */
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const t = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], e = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], s = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(s), this.setAttribute("position", new Us(t, 3)), this.setAttribute("uv", new Us(e, 2));
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {LineSegmentsGeometry} A reference to this instance.
   */
  applyMatrix4(t) {
    const e = this.attributes.instanceStart, s = this.attributes.instanceEnd;
    return e !== void 0 && (e.applyMatrix4(t), s.applyMatrix4(t), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Sets the given line positions for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end vertex in the pattern `(xyz xyz)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setPositions(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const s = new Fr(e, 6, 1);
    return this.setAttribute("instanceStart", new Ls(s, 3, 0)), this.setAttribute("instanceEnd", new Ls(s, 3, 3)), this.instanceCount = this.attributes.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  /**
   * Sets the given line colors for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end color in the pattern `(rgb rgb)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setColors(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const s = new Fr(e, 6, 1);
    return this.setAttribute("instanceColorStart", new Ls(s, 3, 0)), this.setAttribute("instanceColorEnd", new Ls(s, 3, 3)), this;
  }
  /**
   * Setups this line segments geometry from the given wireframe geometry.
   *
   * @param {WireframeGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromWireframeGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  /**
   * Setups this line segments geometry from the given edges geometry.
   *
   * @param {EdgesGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromEdgesGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  /**
   * Setups this line segments geometry from the given mesh.
   *
   * @param {Mesh} mesh - The mesh geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromMesh(t) {
    return this.fromWireframeGeometry(new vc(t.geometry)), this;
  }
  /**
   * Setups this line segments geometry from the given line segments.
   *
   * @param {LineSegments} lineSegments - The line segments that should be used as a data source for this geometry.
   * Assumes the source geometry is not using indices.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromLineSegments(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new qe());
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    t !== void 0 && e !== void 0 && (this.boundingBox.setFromBufferAttribute(t), Ia.setFromBufferAttribute(e), this.boundingBox.union(Ia));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Un()), this.boundingBox === null && this.computeBoundingBox();
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    if (t !== void 0 && e !== void 0) {
      const s = this.boundingSphere.center;
      this.boundingBox.getCenter(s);
      let i = 0;
      for (let n = 0, r = t.count; n < r; n++)
        rn.fromBufferAttribute(t, n), i = Math.max(i, s.distanceToSquared(rn)), rn.fromBufferAttribute(e, n), i = Math.max(i, s.distanceToSquared(rn));
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
}
hn.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Be(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
un.line = {
  uniforms: $r.merge([
    hn.common,
    hn.fog,
    hn.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class wi extends nt {
  /**
   * Constructs a new line segments geometry.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(t) {
    super({
      type: "LineMaterial",
      uniforms: $r.clone(un.line.uniforms),
      vertexShader: un.line.vertexShader,
      fragmentShader: un.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(t);
  }
  /**
   * The material's color.
   *
   * @type {Color}
   * @default (1,1,1)
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(t) {
    this.uniforms.diffuse.value = t;
  }
  /**
   * Whether the material's sizes (width, dash gaps) are in world units.
   *
   * @type {boolean}
   * @default false
   */
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(t) {
    t === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  /**
   * Controls line thickness in CSS pixel units when `worldUnits` is `false` (default),
   * or in world units when `worldUnits` is `true`.
   *
   * @type {number}
   * @default 1
   */
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(t) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = t);
  }
  /**
   * Whether the line is dashed, or solid.
   *
   * @type {boolean}
   * @default false
   */
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(t) {
    t === !0 !== this.dashed && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  /**
   * The scale of the dashes and gaps.
   *
   * @type {number}
   * @default 1
   */
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(t) {
    this.uniforms.dashScale.value = t;
  }
  /**
   * The size of the dash.
   *
   * @type {number}
   * @default 1
   */
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(t) {
    this.uniforms.dashSize.value = t;
  }
  /**
   * Where in the dash cycle the dash starts.
   *
   * @type {number}
   * @default 0
   */
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(t) {
    this.uniforms.dashOffset.value = t;
  }
  /**
   * The size of the gap.
   *
   * @type {number}
   * @default 0
   */
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(t) {
    this.uniforms.gapSize.value = t;
  }
  /**
   * The opacity.
   *
   * @type {number}
   * @default 1
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(t) {
    this.uniforms && (this.uniforms.opacity.value = t);
  }
  /**
   * The size of the viewport, in screen pixels. This must be kept updated to make
   * screen-space rendering accurate.The `LineSegments2.onBeforeRender` callback
   * performs the update for visible objects.
   *
   * @type {Vector2}
   */
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
  /**
   * Whether to use alphaToCoverage or not. When enabled, this can improve the
   * anti-aliasing of line edges when using MSAA.
   *
   * @type {boolean}
   */
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(t) {
    this.defines && (t === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), t === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const Rr = new Fi(), Ea = new q(), ga = new q(), Ve = new Fi(), ze = new Fi(), Rt = new Fi(), Sr = new q(), Ar = new Ce(), ke = new dt(), Ca = new q(), on = new qe(), an = new Un(), St = new Fi();
let vt, us;
function Ta(l, t, e) {
  return St.set(0, 0, -t, 1).applyMatrix4(l.projectionMatrix), St.multiplyScalar(1 / St.w), St.x = us / e.width, St.y = us / e.height, St.applyMatrix4(l.projectionMatrixInverse), St.multiplyScalar(1 / St.w), Math.abs(Math.max(St.x, St.y));
}
function Wd(l, t) {
  const e = l.matrixWorld, s = l.geometry, i = s.attributes.instanceStart, n = s.attributes.instanceEnd, r = Math.min(s.instanceCount, i.count);
  for (let o = 0, a = r; o < a; o++) {
    ke.start.fromBufferAttribute(i, o), ke.end.fromBufferAttribute(n, o), ke.applyMatrix4(e);
    const c = new q(), h = new q();
    vt.distanceSqToSegment(ke.start, ke.end, h, c), h.distanceTo(c) < us * 0.5 && t.push({
      point: h,
      pointOnLine: c,
      distance: vt.origin.distanceTo(h),
      object: l,
      face: null,
      faceIndex: o,
      uv: null,
      uv1: null
    });
  }
}
function Xd(l, t, e) {
  const s = t.projectionMatrix, n = l.material.resolution, r = l.matrixWorld, o = l.geometry, a = o.attributes.instanceStart, c = o.attributes.instanceEnd, h = Math.min(o.instanceCount, a.count), f = -t.near;
  vt.at(1, Rt), Rt.w = 1, Rt.applyMatrix4(t.matrixWorldInverse), Rt.applyMatrix4(s), Rt.multiplyScalar(1 / Rt.w), Rt.x *= n.x / 2, Rt.y *= n.y / 2, Rt.z = 0, Sr.copy(Rt), Ar.multiplyMatrices(t.matrixWorldInverse, r);
  for (let u = 0, d = h; u < d; u++) {
    if (Ve.fromBufferAttribute(a, u), ze.fromBufferAttribute(c, u), Ve.w = 1, ze.w = 1, Ve.applyMatrix4(Ar), ze.applyMatrix4(Ar), Ve.z > f && ze.z > f)
      continue;
    if (Ve.z > f) {
      const T = Ve.z - ze.z, C = (Ve.z - f) / T;
      Ve.lerp(ze, C);
    } else if (ze.z > f) {
      const T = ze.z - Ve.z, C = (ze.z - f) / T;
      ze.lerp(Ve, C);
    }
    Ve.applyMatrix4(s), ze.applyMatrix4(s), Ve.multiplyScalar(1 / Ve.w), ze.multiplyScalar(1 / ze.w), Ve.x *= n.x / 2, Ve.y *= n.y / 2, ze.x *= n.x / 2, ze.y *= n.y / 2, ke.start.copy(Ve), ke.start.z = 0, ke.end.copy(ze), ke.end.z = 0;
    const m = ke.closestPointToPointParameter(Sr, !0);
    ke.at(m, Ca);
    const E = Oc.lerp(Ve.z, ze.z, m), I = E >= -1 && E <= 1, g = Sr.distanceTo(Ca) < us * 0.5;
    if (I && g) {
      ke.start.fromBufferAttribute(a, u), ke.end.fromBufferAttribute(c, u), ke.start.applyMatrix4(r), ke.end.applyMatrix4(r);
      const T = new q(), C = new q();
      vt.distanceSqToSegment(ke.start, ke.end, C, T), e.push({
        point: C,
        pointOnLine: T,
        distance: vt.origin.distanceTo(C),
        object: l,
        face: null,
        faceIndex: u,
        uv: null,
        uv1: null
      });
    }
  }
}
class Zd extends oe {
  /**
   * Constructs a new wide line.
   *
   * @param {LineSegmentsGeometry} [geometry] - The line geometry.
   * @param {LineMaterial} [material] - The line material.
   */
  constructor(t = new nc(), e = new wi({ color: Math.random() * 16777215 })) {
    super(t, e), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {LineSegments2} A reference to this instance.
   */
  computeLineDistances() {
    const t = this.geometry, e = t.attributes.instanceStart, s = t.attributes.instanceEnd, i = new Float32Array(2 * e.count);
    for (let r = 0, o = 0, a = e.count; r < a; r++, o += 2)
      Ea.fromBufferAttribute(e, r), ga.fromBufferAttribute(s, r), i[o] = o === 0 ? 0 : i[o - 1], i[o + 1] = i[o] + Ea.distanceTo(ga);
    const n = new Fr(i, 2, 1);
    return t.setAttribute("instanceDistanceStart", new Ls(n, 1, 0)), t.setAttribute("instanceDistanceEnd", new Ls(n, 1, 1)), this;
  }
  /**
   * Computes intersection points between a casted ray and this instance.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(t, e) {
    const s = this.material.worldUnits, i = t.camera;
    i === null && !s && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const n = t.params.Line2 !== void 0 && t.params.Line2.threshold || 0;
    vt = t.ray;
    const r = this.matrixWorld, o = this.geometry, a = this.material;
    us = a.linewidth + n, o.boundingSphere === null && o.computeBoundingSphere(), an.copy(o.boundingSphere).applyMatrix4(r);
    let c;
    if (s)
      c = us * 0.5;
    else {
      const f = Math.max(i.near, an.distanceToPoint(vt.origin));
      c = Ta(i, f, a.resolution);
    }
    if (an.radius += c, vt.intersectsSphere(an) === !1)
      return;
    o.boundingBox === null && o.computeBoundingBox(), on.copy(o.boundingBox).applyMatrix4(r);
    let h;
    if (s)
      h = us * 0.5;
    else {
      const f = Math.max(i.near, on.distanceToPoint(vt.origin));
      h = Ta(i, f, a.resolution);
    }
    on.expandByScalar(h), vt.intersectsBox(on) !== !1 && (s ? Wd(this, e) : Xd(this, i, e));
  }
  onBeforeRender(t) {
    const e = this.material.uniforms;
    e && e.resolution && (t.getViewport(Rr), this.material.uniforms.resolution.value.set(Rr.z, Rr.w));
  }
}
class yn extends nc {
  /**
   * Constructs a new line geometry.
   */
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  /**
   * Sets the given line positions for this geometry.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineGeometry} A reference to this geometry.
   */
  setPositions(t) {
    const e = t.length - 3, s = new Float32Array(2 * e);
    for (let i = 0; i < e; i += 3)
      s[2 * i] = t[i], s[2 * i + 1] = t[i + 1], s[2 * i + 2] = t[i + 2], s[2 * i + 3] = t[i + 3], s[2 * i + 4] = t[i + 4], s[2 * i + 5] = t[i + 5];
    return super.setPositions(s), this;
  }
  /**
   * Sets the given line colors for this geometry.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineGeometry} A reference to this geometry.
   */
  setColors(t) {
    const e = t.length - 3, s = new Float32Array(2 * e);
    for (let i = 0; i < e; i += 3)
      s[2 * i] = t[i], s[2 * i + 1] = t[i + 1], s[2 * i + 2] = t[i + 2], s[2 * i + 3] = t[i + 3], s[2 * i + 4] = t[i + 4], s[2 * i + 5] = t[i + 5];
    return super.setColors(s), this;
  }
  /**
   * Setups this line segments geometry from the given sequence of points.
   *
   * @param {Array<Vector3|Vector2>} points - An array of points in 2D or 3D space.
   * @return {LineGeometry} A reference to this geometry.
   */
  setFromPoints(t) {
    const e = t.length - 1, s = new Float32Array(6 * e);
    for (let i = 0; i < e; i++)
      s[6 * i] = t[i].x, s[6 * i + 1] = t[i].y, s[6 * i + 2] = t[i].z || 0, s[6 * i + 3] = t[i + 1].x, s[6 * i + 4] = t[i + 1].y, s[6 * i + 5] = t[i + 1].z || 0;
    return super.setPositions(s), this;
  }
  /**
   * Setups this line segments geometry from the given line.
   *
   * @param {Line} line - The line that should be used as a data source for this geometry.
   * @return {LineGeometry} A reference to this geometry.
   */
  fromLine(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
}
class rc extends Zd {
  /**
   * Constructs a new wide line.
   *
   * @param {LineGeometry} [geometry] - The line geometry.
   * @param {LineMaterial} [material] - The line material.
   */
  constructor(t = new yn(), e = new wi({ color: Math.random() * 16777215 })) {
    super(t, e), this.isLine2 = !0, this.type = "Line2";
  }
}
const An = class An {
  constructor(t, e) {
    w(this, "scene");
    w(this, "onSelect", new Y());
    w(this, "type");
    w(this, "selectCurve");
    w(this, "selectPoints");
    w(this, "hoverCurve");
    w(this, "hoverPoints");
    w(this, "caster", new A.Raycaster());
    this.scene = t, this.type = e, this.hoverCurve = this.newCurve(3e-3, 4473924, !1), this.hoverPoints = this.newPoints(5, 4473924), this.selectCurve = this.newCurve(5e-3, 16777215, !0), this.selectPoints = this.newPoints(7, 16777215);
  }
  dispose() {
    this.selectCurve && this.scene.remove(this.selectCurve), this.selectCurve.material.dispose(), this.selectCurve.geometry.dispose(), this.selectCurve = null, this.hoverCurve.material.dispose(), this.hoverCurve.geometry.dispose(), this.hoverCurve = null, this.hoverPoints.material.dispose(), this.hoverPoints.geometry.dispose(), this.selectPoints.material.dispose(), this.selectPoints.geometry.dispose(), this.scene = null;
  }
  castRay(t, e, s, i) {
    const n = new A.Vector2(), r = s.getBoundingClientRect();
    n.x = (t.clientX - r.left) / r.width * 2 - 1, n.y = -((t.clientY - r.top) / r.height) * 2 + 1, this.caster.setFromCamera(n, e);
    const o = this.caster.intersectObjects(i);
    return o.length ? o[0] : null;
  }
  select(t) {
    this.highlight(t, this.selectCurve, this.selectPoints, !0), this.onSelect.trigger(t);
  }
  unSelect() {
    this.selectCurve.removeFromParent(), this.selectPoints.removeFromParent();
  }
  hover(t) {
    this.highlight(t, this.hoverCurve, this.hoverPoints, !1);
  }
  unHover() {
    this.hoverCurve.removeFromParent(), this.hoverPoints.removeFromParent();
  }
  setResolution({ x: t, y: e }) {
    this.selectCurve.material.resolution.set(t / e, 1), this.hoverCurve.material.resolution.set(t / e, 1);
  }
  highlight(t, e, s, i) {
    const { alignment: n } = t.curve;
    this.scene.add(e), this.scene.add(s);
    const r = [], o = [], a = [];
    for (const u of n[this.type]) {
      const d = u.mesh.geometry.attributes.position;
      for (const I of d.array)
        r.push(I);
      if (i) {
        let I;
        if (this.type === "absolute") {
          const { horizontal: T } = u.alignment;
          I = T[u.index].data.TYPE;
        } else
          I = u.data.TYPE;
        const g = An.settings.colors[I] || [1, 1, 1];
        for (let T = 0; T < d.count; T++)
          o.push(...g);
      }
      const [p, m, E] = d.array;
      a.push(new A.Vector3(p, m, E));
    }
    const c = r[r.length - 3], h = r[r.length - 2], f = r[r.length - 1];
    a.push(new A.Vector3(c, h, f)), r.length / 3 > e.geometry.attributes.position.count && (e.geometry.dispose(), e.geometry = new yn()), e.geometry.setPositions(r), i && e.geometry.setColors(o), s.geometry.setFromPoints(a);
  }
  newCurve(t, e, s) {
    const i = new yn(), n = new wi({
      color: e,
      linewidth: t,
      vertexColors: s,
      worldUnits: !1,
      depthTest: !1
    }), r = new rc(i, n);
    return this.scene.add(r), r;
  }
  newPoints(t, e) {
    const s = new A.BufferGeometry(), i = new A.BufferAttribute(new Float32Array(), 3);
    s.setAttribute("position", i);
    const n = new A.PointsMaterial({
      size: t,
      color: e,
      sizeAttenuation: !1,
      depthTest: !1
    }), r = new A.Points(s, n);
    return r.frustumCulled = !1, this.scene.add(r), r;
  }
};
w(An, "settings", {
  colors: {
    LINE: [213 / 255, 0 / 255, 255 / 255],
    CIRCULARARC: [0 / 255, 46, 255 / 255],
    CLOTHOID: [0 / 255, 255 / 255, 0 / 255],
    PARABOLICARC: [0 / 255, 255 / 255, 72 / 255],
    CONSTANTGRADIENT: [213 / 255, 0 / 255, 255 / 255]
  }
});
let Rn = An;
class jd extends In {
  /**
   * Constructs a new CSS2D object.
   *
   * @param {DOMElement} [element] - The DOM element.
   */
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = !0, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new Be(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof e.element.ownerDocument.defaultView.Element && e.element.parentNode !== null && e.element.remove();
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(!0), this.center = t.center, this;
  }
}
const Ps = new q(), ya = new Ce(), Ra = new Ce(), Sa = new q(), Aa = new q();
class Qd {
  /**
   * Constructs a new CSS2D renderer.
   *
   * @param {CSS2DRenderer~Parameters} [parameters] - The parameters.
   */
  constructor(t = {}) {
    const e = this;
    let s, i, n, r;
    const o = {
      objects: /* @__PURE__ */ new WeakMap()
    }, a = t.element !== void 0 ? t.element : document.createElement("div");
    a.style.overflow = "hidden", this.domElement = a, this.getSize = function() {
      return {
        width: s,
        height: i
      };
    }, this.render = function(p, m) {
      p.matrixWorldAutoUpdate === !0 && p.updateMatrixWorld(), m.parent === null && m.matrixWorldAutoUpdate === !0 && m.updateMatrixWorld(), ya.copy(m.matrixWorldInverse), Ra.multiplyMatrices(m.projectionMatrix, ya), h(p, p, m), d(p);
    }, this.setSize = function(p, m) {
      s = p, i = m, n = s / 2, r = i / 2, a.style.width = p + "px", a.style.height = m + "px";
    };
    function c(p) {
      p.isCSS2DObject && (p.element.style.display = "none");
      for (let m = 0, E = p.children.length; m < E; m++)
        c(p.children[m]);
    }
    function h(p, m, E) {
      if (p.visible === !1) {
        c(p);
        return;
      }
      if (p.isCSS2DObject) {
        Ps.setFromMatrixPosition(p.matrixWorld), Ps.applyMatrix4(Ra);
        const I = Ps.z >= -1 && Ps.z <= 1 && p.layers.test(E.layers) === !0, g = p.element;
        g.style.display = I === !0 ? "" : "none", I === !0 && (p.onBeforeRender(e, m, E), g.style.transform = "translate(" + -100 * p.center.x + "%," + -100 * p.center.y + "%)translate(" + (Ps.x * n + n) + "px," + (-Ps.y * r + r) + "px)", g.parentNode !== a && a.appendChild(g), p.onAfterRender(e, m, E));
        const T = {
          distanceToCameraSquared: f(E, p)
        };
        o.objects.set(p, T);
      }
      for (let I = 0, g = p.children.length; I < g; I++)
        h(p.children[I], m, E);
    }
    function f(p, m) {
      return Sa.setFromMatrixPosition(p.matrixWorld), Aa.setFromMatrixPosition(m.matrixWorld), Sa.distanceToSquared(Aa);
    }
    function u(p) {
      const m = [];
      return p.traverseVisible(function(E) {
        E.isCSS2DObject && m.push(E);
      }), m;
    }
    function d(p) {
      const m = u(p).sort(function(I, g) {
        if (I.renderOrder !== g.renderOrder)
          return g.renderOrder - I.renderOrder;
        const T = o.objects.get(I).distanceToCameraSquared, C = o.objects.get(g).distanceToCameraSquared;
        return T - C;
      }), E = m.length;
      for (let I = 0, g = m.length; I < g; I++)
        m[I].element.style.zIndex = E - I;
    }
  }
}
class Ke {
  // Define marker as setup configuration?
  constructor(t, e, s) {
    /**
     * The CSS object representing the marker.
     */
    w(this, "three");
    /**
     * The world in which the marker exists.
     */
    w(this, "world");
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    this.world = t;
    let i;
    e ? i = e : (i = document.createElement("div"), i.style.width = "15px", i.style.height = "15px", i.style.border = "5px solid red"), this.three = new jd(i), (s || t.scene.three).add(this.three), this.visible = !0;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(t) {
    this.three.visible = t;
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /**
   * Toggles the visibility of the marker.
   *
   * This method changes the `visible` property of the marker to its opposite value.
   * If the marker is currently visible, it will be hidden, and vice versa.
   *
   * @returns {void}
   */
  toggleVisibility() {
    this.visible = !this.visible;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.three.removeFromParent(), this.three.element.remove(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
}
class Kd extends Au {
  constructor(e, s, i) {
    super(e, s, i);
    /**
     * This renderer is used to render 2D objects (CSS2DObjects) in a 3D scene.
     */
    w(this, "three2D", new Qd());
    this.onAfterUpdate.add(() => {
      if (this.onBeforeUpdate.trigger(this), !this.enabled || !this.currentWorld)
        return;
      const n = this.currentWorld.scene.three, r = this.currentWorld.camera.three;
      n instanceof A.Scene && this.three2D.render(n, r);
    }), this.onDisposed.add(() => {
      this.three2D.domElement.remove();
    }), this.onResize.add(({ x: n, y: r }) => {
      this.three2D.setSize(n, r);
    }), this.setupHtmlRenderer(), this.resize();
  }
  setupHtmlRenderer() {
    this.three2D.domElement.style.position = "absolute", this.three2D.domElement.style.top = "0px", this.three2D.domElement.style.pointerEvents = "none", this.container && this.container.appendChild(this.three2D.domElement);
  }
}
const Fn = class Fn extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /**
     * The distance threshold for clustering markers.
     * Markers within this distance will be considered for clustering.
     * Default value is 50.
     */
    w(this, "threshold", 50);
    /**
     * Indicates whether markers should be automatically clustered.
     * If true, markers will be clustered based on the threshold value.
     * Default value is true.
     */
    w(this, "autoCluster", !0);
    /**
     * A Map containing the markers grouped by world UUID.
     * Each world can have its own set of markers.
     */
    w(this, "list", /* @__PURE__ */ new Map());
    w(this, "clusterLabels", /* @__PURE__ */ new Set());
    w(this, "currentKeys", /* @__PURE__ */ new Set());
    w(this, "_color", "white");
    // TODO: Replace with UUID for the marker key
    w(this, "_markerKey", 0);
    w(this, "_clusterKey", 0);
    w(this, "_worldEvents", /* @__PURE__ */ new Map());
    w(this, "_setupWorlds", /* @__PURE__ */ new Set());
    e.add(Fn.uuid, this);
  }
  /**
   * Getter for the color property.
   * Returns the current color of the markers.
   *
   * @returns {string} The current color of the markers.
   */
  get color() {
    return this._color;
  }
  /**
   * Setter for the color property.
   * Updates the color of all the markers to the new value.
   *
   * @param {string} value - The new color value for the markers.
   */
  set color(e) {
    this._color = e;
    for (const [s, i] of this.list)
      for (const [n, r] of i)
        r.label.three.element.style.color = e;
  }
  /**
   * Creates a new marker at the specified point in the world.
   *
   * @param world - The world where the marker will be created.
   * @param text - The text content of the marker.
   * @param point - The 3D position where the marker will be placed.
   * @param isStatic - Indicates whether the marker should be static and not clustered.
   * @returns The unique key of the created marker.
   */
  create(e, s, i, n = !1) {
    this.setupEvents(e, !0);
    const r = this._markerKey.toString(), o = this.getWorldMarkerList(e);
    if (o.has(r))
      return;
    const a = document.createElement("span");
    a.innerHTML = s, a.style.color = this._color;
    const c = new Ke(e, a);
    return c.three.position.copy(i), o.set(r, {
      key: r,
      label: c,
      merged: !1,
      static: n
    }), this._markerKey++, r;
  }
  /**
   * Deletes a marker with the specified ID from all worlds.
   *
   * @param id - The unique identifier of the marker to be deleted.
   *
   * @remarks
   * This method iterates through all the worlds and their respective markers.
   * If a marker with the specified ID is found, it disposes of the marker's label
   * and removes the marker from the world's marker list.
   *
   */
  delete(e) {
    for (const [s, i] of this.list) {
      const n = i.get(e);
      n && n.label.dispose(), i.delete(e);
    }
  }
  /**
   * Retrieves the list of markers associated with a specific world.
   * If the list does not exist for the given world, it creates a new one.
   *
   * @param world - The world for which the marker list is to be retrieved.
   * @returns A Map containing the markers associated with the given world.
   *
   * @remarks
   * This method is used to manage markers per world. It ensures that each world has its own set of markers.
   * If a marker list for the given world does not exist, it creates a new one and associates it with the world.
   */
  getWorldMarkerList(e) {
    return this.list.has(e.uuid) || this.list.set(e.uuid, /* @__PURE__ */ new Map()), this.list.get(e.uuid);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose(e) {
    for (const [s, i] of this.list) {
      const n = [...i.keys()];
      for (const r of n) {
        const o = i.get(r);
        e && o.type !== e || (o.label.dispose(), i.delete(r));
      }
    }
    if (!e) {
      this.list.clear(), this._markerKey = 0;
      for (const s of this.clusterLabels)
        s.label.dispose();
      this.clusterLabels.clear(), this._clusterKey = 0, this.currentKeys.clear();
    }
    this.onDisposed.trigger();
  }
  /**
   * Sets up event listeners for clustering markers in the given world.
   *
   * @param world - The world where the event listeners will be set up.
   * @param enabled - Indicates whether the event listeners should be enabled or disabled.
   *
   * @remarks
   * This method checks if the event listeners are already set up for the given world.
   * If the event listeners are already set up and the `enabled` parameter is true, the method returns without doing anything.
   * If the world does not have camera controls, the method returns without doing anything.
   *
   * The method then retrieves the event listener for the given world using the `getWorldEvent` method.
   * It removes the existing event listeners for the "sleep" and "rest" events from the world's camera controls.
   *
   * If the `enabled` parameter is true, the method adds the event listener for the "sleep" and "rest" events to the world's camera controls.
   */
  setupEvents(e, s) {
    if (s && this._setupWorlds.has(e.uuid) || !e.camera.hasCameraControls())
      return;
    const i = this.getWorldEvent(e);
    e.camera.controls.removeEventListener("sleep", i), e.camera.controls.removeEventListener("rest", i), s && (e.camera.controls.addEventListener("sleep", i), e.camera.controls.addEventListener("rest", i));
  }
  /**
   * Performs clustering of markers in the given world.
   *
   * @param world - The world where clustering will be performed.
   *
   */
  cluster(e) {
    if (!this.autoCluster)
      return;
    this.resetMarkers();
    const s = this.list.get(e.uuid);
    if (s) {
      for (const [i, n] of s)
        if (!n.merged && !n.static) {
          this.currentKeys.clear();
          for (const [r, o] of s)
            o.static || n.key !== o.key && !o.merged && this.distance(n.label, o.label) < this.threshold && (this.currentKeys.add(o.key), o.merged = !0);
          if (this.currentKeys.size > 0) {
            this.currentKeys.add(n.key), n.merged = !0;
            const r = Array.from(this.currentKeys), o = this.getAveragePositionFromLabels(r), a = new Ke(
              n.label.world,
              this.createClusterElement(this._clusterKey.toString())
            ), { element: c } = a.three;
            c.textContent = r.length.toString(), a.three.position.copy(o), this.clusterLabels.add({
              key: this._clusterKey.toString(),
              markerKeys: r,
              label: a
            }), this._clusterKey++;
          }
        }
      this.removeMergeMarkers(e);
    }
  }
  getWorldEvent(e) {
    if (!this._worldEvents.has(e.uuid)) {
      const s = () => {
        this.cluster(e);
      };
      this._worldEvents.set(e.uuid, s);
    }
    return this._worldEvents.get(e.uuid);
  }
  resetMarkers() {
    for (const [e, s] of this.list)
      for (const [i, n] of s)
        n.merged = !1;
    for (const e of this.clusterLabels)
      e.label.dispose();
    this.clusterLabels.clear(), this._clusterKey = 0;
  }
  removeMergeMarkers(e) {
    const s = this.list.get(e.uuid);
    if (s) {
      for (const [i, n] of s)
        n.merged ? n.label.dispose() : n.label.world.scene.three.add(n.label.three);
      for (const i of this.clusterLabels)
        if (i.markerKeys.length === 1) {
          for (const [n, r] of this.list) {
            const o = r.get(i.markerKeys[0]);
            if (!o)
              continue;
            o.label.world.scene.three.add(o.label.three), o.merged = !1;
          }
          i.label.dispose(), this.clusterLabels.delete(i);
        }
    }
  }
  getAveragePositionFromLabels(e) {
    const s = e.map((i) => {
      for (const [n, r] of this.list) {
        const o = r.get(i);
        if (o)
          return o.label.three.position;
      }
      return new A.Vector3();
    });
    return s.reduce((i, n) => i.add(n), new A.Vector3()).divideScalar(s.length);
  }
  createClusterElement(e) {
    const s = document.createElement("div");
    return s.textContent = e, s.style.color = "#000000", s.style.background = "#FFFFFF", s.style.fontSize = "1.2rem", s.style.fontWeight = "500", s.style.pointerEvents = "auto", s.style.borderRadius = "50%", s.style.padding = "5px 11px", s.style.textAlign = "center", s.style.cursor = "pointer", s.addEventListener("pointerdown", () => {
      this.navigateToCluster(e);
    }), s.addEventListener("pointerover", () => {
      s.style.background = "#BCF124";
    }), s.addEventListener("pointerout", () => {
      s.style.background = "#FFFFFF";
    }), s;
  }
  getScreenPosition(e) {
    const s = new A.Vector3();
    if (!e.world.renderer)
      throw new Error("Renderer not found!");
    const i = e.three.position.clone();
    i.project(e.world.camera.three);
    const n = e.world.renderer.getSize();
    return s.x = i.x * n.x / 2 + n.x / 2, s.y = -(i.y * n.y / 2) + n.y / 2, s;
  }
  distance(e, s) {
    const i = this.getScreenPosition(e), n = this.getScreenPosition(s), r = i.x - n.x, o = i.y - n.y, a = Math.sqrt(r * r + o * o) * 0.5;
    return a === 0 ? this.threshold + 1 : a;
  }
  navigateToCluster(e) {
    const s = [], i = Array.from(this.clusterLabels).find(
      (f) => f.key === e
    );
    if (!i)
      return;
    const n = i.label.world.camera;
    if (!n.hasCameraControls()) {
      console.warn("Zoom to clusters only supported with Camera Controls!");
      return;
    }
    for (const f of i.markerKeys)
      for (const [u, d] of this.list) {
        const p = d.get(f);
        if (p) {
          const { x: m, y: E, z: I } = p.label.three.position;
          s.push(m, E, I);
        }
      }
    i.label.dispose(), this.clusterLabels.delete(i);
    const r = new A.BufferGeometry(), o = new Float32Array(s), a = new A.BufferAttribute(o, 3);
    r.setAttribute("position", a);
    const c = new A.Mesh(r);
    c.geometry.computeBoundingSphere(), c.geometry.boundingSphere && n.controls.fitToSphere(c, !0), r.dispose(), c.clear(), s.length = 0;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Fn, "uuid", "4079eb91-79b0-4ede-bcf2-15b837129236");
let Mt = Fn;
function qd(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var fo = { exports: {} };
fo.exports = Zn;
fo.exports.default = Zn;
function Zn(l, t, e) {
  e = e || 2;
  var s = t && t.length, i = s ? t[0] * e : l.length, n = oc(l, 0, i, e, !0), r = [];
  if (!n || n.next === n.prev)
    return r;
  var o, a, c, h, f, u, d;
  if (s && (n = sp(l, t, n, e)), l.length > 80 * e) {
    o = c = l[0], a = h = l[1];
    for (var p = e; p < i; p += e)
      f = l[p], u = l[p + 1], f < o && (o = f), u < a && (a = u), f > c && (c = f), u > h && (h = u);
    d = Math.max(c - o, h - a), d = d !== 0 ? 32767 / d : 0;
  }
  return yi(n, r, e, o, a, d, 0), r;
}
function oc(l, t, e, s, i) {
  var n, r;
  if (i === Kr(l, t, e, s) > 0)
    for (n = t; n < e; n += s)
      r = Fa(n, l[n], l[n + 1], r);
  else
    for (n = e - s; n >= t; n -= s)
      r = Fa(n, l[n], l[n + 1], r);
  return r && jn(r, r.next) && (Si(r), r = r.next), r;
}
function ps(l, t) {
  if (!l)
    return l;
  t || (t = l);
  var e = l, s;
  do
    if (s = !1, !e.steiner && (jn(e, e.next) || xe(e.prev, e, e.next) === 0)) {
      if (Si(e), e = t = e.prev, e === e.next)
        break;
      s = !0;
    } else
      e = e.next;
  while (s || e !== t);
  return t;
}
function yi(l, t, e, s, i, n, r) {
  if (l) {
    !r && n && ap(l, s, i, n);
    for (var o = l, a, c; l.prev !== l.next; ) {
      if (a = l.prev, c = l.next, n ? $d(l, s, i, n) : Jd(l)) {
        t.push(a.i / e | 0), t.push(l.i / e | 0), t.push(c.i / e | 0), Si(l), l = c.next, o = c.next;
        continue;
      }
      if (l = c, l === o) {
        r ? r === 1 ? (l = ep(ps(l), t, e), yi(l, t, e, s, i, n, 2)) : r === 2 && tp(l, t, e, s, i, n) : yi(ps(l), t, e, s, i, n, 1);
        break;
      }
    }
  }
}
function Jd(l) {
  var t = l.prev, e = l, s = l.next;
  if (xe(t, e, s) >= 0)
    return !1;
  for (var i = t.x, n = e.x, r = s.x, o = t.y, a = e.y, c = s.y, h = i < n ? i < r ? i : r : n < r ? n : r, f = o < a ? o < c ? o : c : a < c ? a : c, u = i > n ? i > r ? i : r : n > r ? n : r, d = o > a ? o > c ? o : c : a > c ? a : c, p = s.next; p !== t; ) {
    if (p.x >= h && p.x <= u && p.y >= f && p.y <= d && Ds(i, o, n, a, r, c, p.x, p.y) && xe(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function $d(l, t, e, s) {
  var i = l.prev, n = l, r = l.next;
  if (xe(i, n, r) >= 0)
    return !1;
  for (var o = i.x, a = n.x, c = r.x, h = i.y, f = n.y, u = r.y, d = o < a ? o < c ? o : c : a < c ? a : c, p = h < f ? h < u ? h : u : f < u ? f : u, m = o > a ? o > c ? o : c : a > c ? a : c, E = h > f ? h > u ? h : u : f > u ? f : u, I = jr(d, p, t, e, s), g = jr(m, E, t, e, s), T = l.prevZ, C = l.nextZ; T && T.z >= I && C && C.z <= g; ) {
    if (T.x >= d && T.x <= m && T.y >= p && T.y <= E && T !== i && T !== r && Ds(o, h, a, f, c, u, T.x, T.y) && xe(T.prev, T, T.next) >= 0 || (T = T.prevZ, C.x >= d && C.x <= m && C.y >= p && C.y <= E && C !== i && C !== r && Ds(o, h, a, f, c, u, C.x, C.y) && xe(C.prev, C, C.next) >= 0))
      return !1;
    C = C.nextZ;
  }
  for (; T && T.z >= I; ) {
    if (T.x >= d && T.x <= m && T.y >= p && T.y <= E && T !== i && T !== r && Ds(o, h, a, f, c, u, T.x, T.y) && xe(T.prev, T, T.next) >= 0)
      return !1;
    T = T.prevZ;
  }
  for (; C && C.z <= g; ) {
    if (C.x >= d && C.x <= m && C.y >= p && C.y <= E && C !== i && C !== r && Ds(o, h, a, f, c, u, C.x, C.y) && xe(C.prev, C, C.next) >= 0)
      return !1;
    C = C.nextZ;
  }
  return !0;
}
function ep(l, t, e) {
  var s = l;
  do {
    var i = s.prev, n = s.next.next;
    !jn(i, n) && ac(i, s, s.next, n) && Ri(i, n) && Ri(n, i) && (t.push(i.i / e | 0), t.push(s.i / e | 0), t.push(n.i / e | 0), Si(s), Si(s.next), s = l = n), s = s.next;
  } while (s !== l);
  return ps(s);
}
function tp(l, t, e, s, i, n) {
  var r = l;
  do {
    for (var o = r.next.next; o !== r.prev; ) {
      if (r.i !== o.i && hp(r, o)) {
        var a = lc(r, o);
        r = ps(r, r.next), a = ps(a, a.next), yi(r, t, e, s, i, n, 0), yi(a, t, e, s, i, n, 0);
        return;
      }
      o = o.next;
    }
    r = r.next;
  } while (r !== l);
}
function sp(l, t, e, s) {
  var i = [], n, r, o, a, c;
  for (n = 0, r = t.length; n < r; n++)
    o = t[n] * s, a = n < r - 1 ? t[n + 1] * s : l.length, c = oc(l, o, a, s, !1), c === c.next && (c.steiner = !0), i.push(cp(c));
  for (i.sort(ip), n = 0; n < i.length; n++)
    e = np(i[n], e);
  return e;
}
function ip(l, t) {
  return l.x - t.x;
}
function np(l, t) {
  var e = rp(l, t);
  if (!e)
    return t;
  var s = lc(e, l);
  return ps(s, s.next), ps(e, e.next);
}
function rp(l, t) {
  var e = t, s = l.x, i = l.y, n = -1 / 0, r;
  do {
    if (i <= e.y && i >= e.next.y && e.next.y !== e.y) {
      var o = e.x + (i - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (o <= s && o > n && (n = o, r = e.x < e.next.x ? e : e.next, o === s))
        return r;
    }
    e = e.next;
  } while (e !== t);
  if (!r)
    return null;
  var a = r, c = r.x, h = r.y, f = 1 / 0, u;
  e = r;
  do
    s >= e.x && e.x >= c && s !== e.x && Ds(i < h ? s : n, i, c, h, i < h ? n : s, i, e.x, e.y) && (u = Math.abs(i - e.y) / (s - e.x), Ri(e, l) && (u < f || u === f && (e.x > r.x || e.x === r.x && op(r, e))) && (r = e, f = u)), e = e.next;
  while (e !== a);
  return r;
}
function op(l, t) {
  return xe(l.prev, l, t.prev) < 0 && xe(t.next, l, l.next) < 0;
}
function ap(l, t, e, s) {
  var i = l;
  do
    i.z === 0 && (i.z = jr(i.x, i.y, t, e, s)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== l);
  i.prevZ.nextZ = null, i.prevZ = null, lp(i);
}
function lp(l) {
  var t, e, s, i, n, r, o, a, c = 1;
  do {
    for (e = l, l = null, n = null, r = 0; e; ) {
      for (r++, s = e, o = 0, t = 0; t < c && (o++, s = s.nextZ, !!s); t++)
        ;
      for (a = c; o > 0 || a > 0 && s; )
        o !== 0 && (a === 0 || !s || e.z <= s.z) ? (i = e, e = e.nextZ, o--) : (i = s, s = s.nextZ, a--), n ? n.nextZ = i : l = i, i.prevZ = n, n = i;
      e = s;
    }
    n.nextZ = null, c *= 2;
  } while (r > 1);
  return l;
}
function jr(l, t, e, s, i) {
  return l = (l - e) * i | 0, t = (t - s) * i | 0, l = (l | l << 8) & 16711935, l = (l | l << 4) & 252645135, l = (l | l << 2) & 858993459, l = (l | l << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, l | t << 1;
}
function cp(l) {
  var t = l, e = l;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== l);
  return e;
}
function Ds(l, t, e, s, i, n, r, o) {
  return (i - r) * (t - o) >= (l - r) * (n - o) && (l - r) * (s - o) >= (e - r) * (t - o) && (e - r) * (n - o) >= (i - r) * (s - o);
}
function hp(l, t) {
  return l.next.i !== t.i && l.prev.i !== t.i && !up(l, t) && // dones't intersect other edges
  (Ri(l, t) && Ri(t, l) && fp(l, t) && // locally visible
  (xe(l.prev, l, t.prev) || xe(l, t.prev, t)) || // does not create opposite-facing sectors
  jn(l, t) && xe(l.prev, l, l.next) > 0 && xe(t.prev, t, t.next) > 0);
}
function xe(l, t, e) {
  return (t.y - l.y) * (e.x - t.x) - (t.x - l.x) * (e.y - t.y);
}
function jn(l, t) {
  return l.x === t.x && l.y === t.y;
}
function ac(l, t, e, s) {
  var i = cn(xe(l, t, e)), n = cn(xe(l, t, s)), r = cn(xe(e, s, l)), o = cn(xe(e, s, t));
  return !!(i !== n && r !== o || i === 0 && ln(l, e, t) || n === 0 && ln(l, s, t) || r === 0 && ln(e, l, s) || o === 0 && ln(e, t, s));
}
function ln(l, t, e) {
  return t.x <= Math.max(l.x, e.x) && t.x >= Math.min(l.x, e.x) && t.y <= Math.max(l.y, e.y) && t.y >= Math.min(l.y, e.y);
}
function cn(l) {
  return l > 0 ? 1 : l < 0 ? -1 : 0;
}
function up(l, t) {
  var e = l;
  do {
    if (e.i !== l.i && e.next.i !== l.i && e.i !== t.i && e.next.i !== t.i && ac(e, e.next, l, t))
      return !0;
    e = e.next;
  } while (e !== l);
  return !1;
}
function Ri(l, t) {
  return xe(l.prev, l, l.next) < 0 ? xe(l, t, l.next) >= 0 && xe(l, l.prev, t) >= 0 : xe(l, t, l.prev) < 0 || xe(l, l.next, t) < 0;
}
function fp(l, t) {
  var e = l, s = !1, i = (l.x + t.x) / 2, n = (l.y + t.y) / 2;
  do
    e.y > n != e.next.y > n && e.next.y !== e.y && i < (e.next.x - e.x) * (n - e.y) / (e.next.y - e.y) + e.x && (s = !s), e = e.next;
  while (e !== l);
  return s;
}
function lc(l, t) {
  var e = new Qr(l.i, l.x, l.y), s = new Qr(t.i, t.x, t.y), i = l.next, n = t.prev;
  return l.next = t, t.prev = l, e.next = i, i.prev = e, s.next = e, e.prev = s, n.next = s, s.prev = n, s;
}
function Fa(l, t, e, s) {
  var i = new Qr(l, t, e);
  return s ? (i.next = s.next, i.prev = s, s.next.prev = i, s.next = i) : (i.prev = i, i.next = i), i;
}
function Si(l) {
  l.next.prev = l.prev, l.prev.next = l.next, l.prevZ && (l.prevZ.nextZ = l.nextZ), l.nextZ && (l.nextZ.prevZ = l.prevZ);
}
function Qr(l, t, e) {
  this.i = l, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Zn.deviation = function(l, t, e, s) {
  var i = t && t.length, n = i ? t[0] * e : l.length, r = Math.abs(Kr(l, 0, n, e));
  if (i)
    for (var o = 0, a = t.length; o < a; o++) {
      var c = t[o] * e, h = o < a - 1 ? t[o + 1] * e : l.length;
      r -= Math.abs(Kr(l, c, h, e));
    }
  var f = 0;
  for (o = 0; o < s.length; o += 3) {
    var u = s[o] * e, d = s[o + 1] * e, p = s[o + 2] * e;
    f += Math.abs(
      (l[u] - l[p]) * (l[d + 1] - l[u + 1]) - (l[u] - l[d]) * (l[p + 1] - l[u + 1])
    );
  }
  return r === 0 && f === 0 ? 0 : Math.abs((f - r) / r);
};
function Kr(l, t, e, s) {
  for (var i = 0, n = t, r = e - s; n < e; n += s)
    i += (l[r] - l[n]) * (l[n + 1] + l[r + 1]), r = n;
  return i;
}
Zn.flatten = function(l) {
  for (var t = l[0][0].length, e = { vertices: [], holes: [], dimensions: t }, s = 0, i = 0; i < l.length; i++) {
    for (var n = 0; n < l[i].length; n++)
      for (var r = 0; r < t; r++)
        e.vertices.push(l[i][n][r]);
    i > 0 && (s += l[i - 1].length, e.holes.push(s));
  }
  return e;
};
var dp = fo.exports;
const pp = /* @__PURE__ */ qd(dp), mp = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class ks {
  /**
   * Constructs a new pass.
   */
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  /**
   * Sets the size of the pass.
   *
   * @abstract
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize() {
  }
  /**
   * This method holds the render logic of a pass. It must be implemented in all derived classes.
   *
   * @abstract
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   *
   * @abstract
   */
  dispose() {
  }
}
const Ip = new Ha(-1, 1, 1, -1, 0, 1);
class Ep extends En {
  constructor() {
    super(), this.setAttribute("position", new Us([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Us([0, 2, 0, 0, 2, 0], 2));
  }
}
const gp = new Ep();
class cc {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(t) {
    this._mesh = new oe(gp, t);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(t) {
    t.render(this._mesh, Ip);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
}
class hc extends ks {
  /**
   * Constructs a new shader pass.
   *
   * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
   * defines and uniforms. It's also valid to pass a custom shader material.
   * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
   * the read buffer.
   */
  constructor(t, e = "tDiffuse") {
    super(), this.textureID = e, this.uniforms = null, this.material = null, t instanceof nt ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = $r.clone(t.uniforms), this.material = new nt({
      name: t.name !== void 0 ? t.name : "unspecified",
      defines: Object.assign({}, t.defines),
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader
    })), this._fsQuad = new cc(this.material);
  }
  /**
   * Performs the shader pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = s.texture), this._fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this._fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this._fsQuad.render(t));
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this.material.dispose(), this._fsQuad.dispose();
  }
}
class wa extends ks {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The 3D objects in this scene will define the mask.
   * @param {Camera} camera - The camera.
   */
  constructor(t, e) {
    super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  /**
   * Performs a mask pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    const i = t.getContext(), n = t.state;
    n.buffers.color.setMask(!1), n.buffers.depth.setMask(!1), n.buffers.color.setLocked(!0), n.buffers.depth.setLocked(!0);
    let r, o;
    this.inverse ? (r = 0, o = 1) : (r = 1, o = 0), n.buffers.stencil.setTest(!0), n.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), n.buffers.stencil.setFunc(i.ALWAYS, r, 4294967295), n.buffers.stencil.setClear(o), n.buffers.stencil.setLocked(!0), t.setRenderTarget(s), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), n.buffers.color.setLocked(!1), n.buffers.depth.setLocked(!1), n.buffers.color.setMask(!0), n.buffers.depth.setMask(!0), n.buffers.stencil.setLocked(!1), n.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), n.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), n.buffers.stencil.setLocked(!0);
  }
}
class Cp extends ks {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super(), this.needsSwap = !1;
  }
  /**
   * Performs the clear of the currently defined mask.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t) {
    t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1);
  }
}
class Tp {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
   * be used as the internal read and write buffers. If not given, the composer creates
   * the buffers automatically.
   */
  constructor(t, e) {
    if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), e === void 0) {
      const s = t.getSize(new Be());
      this._width = s.width, this._height = s.height, e = new wt(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: ns }), e.texture.name = "EffectComposer.rt1";
    } else
      this._width = e.width, this._height = e.height;
    this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new hc(mp), this.copyPass.material.blending = Pc, this.clock = new Nc();
  }
  /**
   * Swaps the internal read/write buffers.
   */
  swapBuffers() {
    const t = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = t;
  }
  /**
   * Adds the given pass to the pass chain.
   *
   * @param {Pass} pass - The pass to add.
   */
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Inserts the given pass at a given index.
   *
   * @param {Pass} pass - The pass to insert.
   * @param {number} index - The index into the pass chain.
   */
  insertPass(t, e) {
    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Removes the given pass from the pass chain.
   *
   * @param {Pass} pass - The pass to remove.
   */
  removePass(t) {
    const e = this.passes.indexOf(t);
    e !== -1 && this.passes.splice(e, 1);
  }
  /**
   * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
   *
   * @param {number} passIndex - The pass index.
   * @return {boolean} Whether the the pass for the given index is the last pass in the pass chain.
   */
  isLastEnabledPass(t) {
    for (let e = t + 1; e < this.passes.length; e++)
      if (this.passes[e].enabled)
        return !1;
    return !0;
  }
  /**
   * Executes all enabled post-processing passes in order to produce the final frame.
   *
   * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
   * its own time delta value.
   */
  render(t) {
    t === void 0 && (t = this.clock.getDelta());
    const e = this.renderer.getRenderTarget();
    let s = !1;
    for (let i = 0, n = this.passes.length; i < n; i++) {
      const r = this.passes[i];
      if (r.enabled !== !1) {
        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i), r.render(this.renderer, this.writeBuffer, this.readBuffer, t, s), r.needsSwap) {
          if (s) {
            const o = this.renderer.getContext(), a = this.renderer.state.buffers.stencil;
            a.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), a.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        wa !== void 0 && (r instanceof wa ? s = !0 : r instanceof Cp && (s = !1));
      }
    }
    this.renderer.setRenderTarget(e);
  }
  /**
   * Resets the internal state of the EffectComposer.
   *
   * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
   * the one from the constructor. If set, it is used to setup the read and write buffers.
   */
  reset(t) {
    if (t === void 0) {
      const e = this.renderer.getSize(new Be());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  /**
   * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
   * this method honors the current pixel ration.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   */
  setSize(t, e) {
    this._width = t, this._height = e;
    const s = this._width * this._pixelRatio, i = this._height * this._pixelRatio;
    this.renderTarget1.setSize(s, i), this.renderTarget2.setSize(s, i);
    for (let n = 0; n < this.passes.length; n++)
      this.passes[n].setSize(s, i);
  }
  /**
   * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
   * Setting the pixel ratio will automatically resize the composer.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(t) {
    this._pixelRatio = t, this.setSize(this._width, this._height);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the composer is no longer used in your app.
   */
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class yp extends ks {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera.
   * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used
   * for all objects in the scene.
   * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.
   * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.
   */
  constructor(t, e, s = null, i = null, n = null) {
    super(), this.scene = t, this.camera = e, this.overrideMaterial = s, this.clearColor = i, this.clearAlpha = n, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new ai();
  }
  /**
   * Performs a beauty pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    const i = t.autoClear;
    t.autoClear = !1;
    let n, r;
    this.overrideMaterial !== null && (r = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (t.getClearColor(this._oldClearColor), t.setClearColor(this.clearColor, t.getClearAlpha())), this.clearAlpha !== null && (n = t.getClearAlpha(), t.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : s), this.clear === !0 && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor !== null && t.setClearColor(this._oldClearColor), this.clearAlpha !== null && t.setClearAlpha(n), this.overrideMaterial !== null && (this.scene.overrideMaterial = r), t.autoClear = i;
  }
}
const vi = new En();
vi.setAttribute("position", new Bn(new Float32Array([
  -1,
  -1,
  3,
  -1,
  -1,
  3
]), 2));
vi.setAttribute("uv", new Bn(new Float32Array([
  0,
  0,
  2,
  0,
  0,
  2
]), 2));
vi.boundingSphere = new Un();
vi.computeBoundingSphere = function() {
};
const Rp = new Ha();
class Ns {
  constructor(t) {
    this._mesh = new oe(vi, t), this._mesh.frustumCulled = !1;
  }
  render(t) {
    t.render(this._mesh, Rp);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
  dispose() {
    this._mesh.material.dispose(), this._mesh.geometry.dispose();
  }
}
const Sp = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    sceneNormal: {
      value: null
    },
    projMat: {
      value: new Ce()
    },
    viewMat: {
      value: new Ce()
    },
    projViewMat: {
      value: new Ce()
    },
    projectionMatrixInv: {
      value: new Ce()
    },
    viewMatrixInv: {
      value: new Ce()
    },
    cameraPos: {
      value: new q()
    },
    resolution: {
      value: new Be()
    },
    biasAdjustment: {
      value: new Be()
    },
    time: {
      value: 0
    },
    samples: {
      value: []
    },
    bluenoise: {
      value: null
    },
    distanceFalloff: {
      value: 1
    },
    radius: {
      value: 5
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: !1
    },
    ortho: {
      value: !1
    },
    screenSpaceRadius: {
      value: !1
    },
    frame: {
      value: 0
    }
  },
  depthWrite: !1,
  depthTest: !1,
  vertexShader: (
    /* glsl */
    `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1);
}`
  ),
  fragmentShader: (
    /* glsl */
    `
    #define SAMPLES 16
    #define FSAMPLES 16.0
uniform sampler2D sceneDiffuse;
uniform highp sampler2D sceneNormal;
uniform highp sampler2D sceneDepth;
uniform mat4 projectionMatrixInv;
uniform mat4 viewMatrixInv;
uniform mat4 projMat;
uniform mat4 viewMat;
uniform mat4 projViewMat;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform vec2 biasAdjustment;
uniform float time;
uniform vec3[SAMPLES] samples;
uniform float radius;
uniform float distanceFalloff;
uniform float near;
uniform float far;
uniform float frame;
uniform bool logDepth;
uniform bool ortho;
uniform bool screenSpaceRadius;
uniform sampler2D bluenoise;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      /*return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);*/
       #ifdef ORTHO

       return linearize_depth_ortho(d, nearZ, farZ);

        #else
        return linearize_depth(linDepth, nearZ, farZ);
        #endif
    }

    vec3 getWorldPosLog(vec3 posS) {
      vec2 uv = posS.xy;
      float z = posS.z;
      float nearZ =near;
      float farZ = far;
      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
      vec4 wpos = projectionMatrixInv * clipVec;
      return wpos.xyz / wpos.w;
    }
    vec3 getWorldPos(float depth, vec2 coord) {
      #ifdef LOGDEPTH
        #ifndef ORTHO
          return getWorldPosLog(vec3(coord, depth));
        #endif
      #endif
      float z = depth * 2.0 - 1.0;
      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
      // Perspective division
     vec4 worldSpacePosition = viewSpacePosition;
     worldSpacePosition.xyz /= worldSpacePosition.w;
      return worldSpacePosition.xyz;
  }

  vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    ivec2 p = ivec2(vUv * resolution);
    float c0 = texelFetch(sceneDepth, p, 0).x;
    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPos(c0, vUv).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;

    return normalize(cross(dpdx, dpdy));
}

mat3 makeRotationZ(float theta) {
	float c = cos(theta);
	float s = sin(theta);
	return mat3(c, - s, 0,
			s,  c, 0,
			0,  0, 1);
  }

void main() {
      vec4 diffuse = texture2D(sceneDiffuse, vUv);
      float depth = texture2D(sceneDepth, vUv).x;
      if (depth == 1.0) {
        gl_FragColor = vec4(vec3(1.0), 1.0);
        return;
      }
      vec3 worldPos = getWorldPos(depth, vUv);
      #ifdef HALFRES
        vec3 normal = texture2D(sceneNormal, vUv).rgb;
      #else
        vec3 normal = computeNormal(worldPos, vUv);
      #endif
      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);
      vec2 harmoniousNumbers = vec2(
        1.618033988749895,
        1.324717957244746
      );
      noise.rg += harmoniousNumbers * frame;
      noise.rg = fract(noise.rg);
        vec3 helperVec = vec3(0.0, 1.0, 0.0);
        if (dot(helperVec, normal) > 0.99) {
          helperVec = vec3(1.0, 0.0, 0.0);
        }
        vec3 tangent = normalize(cross(helperVec, normal));
        vec3 bitangent = cross(normal, tangent);
        mediump mat3 tbn = mat3(tangent, bitangent, normal) *  makeRotationZ( noise.r * 3.1415962 * 2.0) ;

      mediump float occluded = 0.0;
      mediump float totalWeight = 0.0;
      float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : radiusToUse * distanceFalloff * 0.2;
      float bias = (min(
        0.1,
        distanceFalloffToUse * 0.1
      ) / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;
      bias = biasAdjustment.x + biasAdjustment.y * bias;
      mediump float offsetMove = noise.g;
      mediump float offsetMoveInv = 1.0 / FSAMPLES;
      float farTimesNear = far * near;
      float farMinusNear = far - near;
      
      for(int i = 0; i < SAMPLES; i++) {
        mediump vec3 sampleDirection = tbn * samples[i];

        float moveAmt = fract(offsetMove);
        offsetMove += offsetMoveInv;
        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;
        vec4 offset = projMat * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;
        
        if (all(greaterThan(offset.xyz * (1.0 - offset.xyz), vec3(0.0)))) {
          float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;

          /*#ifdef LOGDEPTH
          float distSample = linearize_depth_log(sampleDepth, near, far);
      #else
          #ifdef ORTHO
              float distSample = near + farMinusNear * sampleDepth;
          #else
              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);
          #endif
      #endif*/
      #ifdef ORTHO
          float distSample = near + sampleDepth * farMinusNear;
      #else
          #ifdef LOGDEPTH
              float distSample = linearize_depth_log(sampleDepth, near, far);
          #else
              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);
          #endif
      #endif
      
      #ifdef ORTHO
          float distWorld = near + offset.z * farMinusNear;
      #else
          float distWorld = (farTimesNear) / (far - offset.z * farMinusNear);
      #endif
          
          mediump float rangeCheck = smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));
          vec2 diff = gl_FragCoord.xy - floor(offset.xy * resolution);
          occluded += rangeCheck * float(distSample != distWorld) * float(sampleDepth != depth) * step(distSample + bias, distWorld) * step(
            1.0,
            dot(diff, diff)
          );
          
          totalWeight ++;
        }
      }
      float occ = clamp(1.0 - occluded / (totalWeight == 0.0 ? 1.0 : totalWeight), 0.0, 1.0);
      gl_FragColor = vec4(occ, 0.5 + 0.5 * normal);
}`
  )
}, Ap = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    transparencyDWFalse: {
      value: null
    },
    transparencyDWTrue: {
      value: null
    },
    transparencyDWTrueDepth: {
      value: null
    },
    transparencyAware: {
      value: !1
    },
    projMat: {
      value: new Ce()
    },
    viewMat: {
      value: new Ce()
    },
    projectionMatrixInv: {
      value: new Ce()
    },
    viewMatrixInv: {
      value: new Ce()
    },
    cameraPos: {
      value: new q()
    },
    resolution: {
      value: new Be()
    },
    color: {
      value: new q(0, 0, 0)
    },
    blueNoise: {
      value: null
    },
    downsampledDepth: {
      value: null
    },
    time: {
      value: 0
    },
    intensity: {
      value: 10
    },
    renderMode: {
      value: 0
    },
    gammaCorrection: {
      value: !1
    },
    logDepth: {
      value: !1
    },
    ortho: {
      value: !1
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    screenSpaceRadius: {
      value: !1
    },
    radius: {
      value: 0
    },
    distanceFalloff: {
      value: 1
    },
    fog: {
      value: !1
    },
    fogExp: {
      value: !1
    },
    fogDensity: {
      value: 0
    },
    fogNear: {
      value: 1 / 0
    },
    fogFar: {
      value: 1 / 0
    },
    colorMultiply: {
      value: !0
    },
    aoTones: {
      value: 0
    }
  },
  depthWrite: !1,
  depthTest: !1,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform highp sampler2D downsampledDepth;
    uniform highp sampler2D transparencyDWFalse;
    uniform highp sampler2D transparencyDWTrue;
    uniform highp sampler2D transparencyDWTrueDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform vec2 resolution;
    uniform vec3 color;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform float intensity;
    uniform float renderMode;
    uniform float near;
    uniform float far;
    uniform float aoTones;
    uniform bool gammaCorrection;
    uniform bool logDepth;
    uniform bool ortho;
    uniform bool screenSpaceRadius;
    uniform bool fog;
    uniform bool fogExp;
    uniform bool colorMultiply;
    uniform bool transparencyAware;
    uniform float fogDensity;
    uniform float fogNear;
    uniform float fogFar;
    uniform float radius;
    uniform float distanceFalloff;
    uniform vec3 cameraPos;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
       // if (logDepth) {
        #ifdef LOGDEPTH
          #ifndef ORTHO
            return getWorldPosLog(vec3(coord, depth));
          #endif
        #endif
      //  }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }

    #include <common>
    #include <dithering_pars_fragment>
    void main() {
        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);
        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);
        float depth = texture2D(
            sceneDepth,
            vUv
        ).x;
        #ifdef HALFRES 
        vec4 texel;
        if (depth == 1.0) {
            texel = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
        vec3 worldPos = getWorldPos(depth, vUv);
        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);
       // vec4 texel = texture2D(tDiffuse, vUv);
       // Find closest depth;
       float totalWeight = 0.0;
       float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
        for(float x = -1.0; x <= 1.0; x++) {
            for(float y = -1.0; y <= 1.0; y++) {
                vec2 offset = vec2(x, y);
                ivec2 p = ivec2(
                    (vUv * resolution * 0.5) + offset
                );
                vec2 pUv = vec2(p) / (resolution * 0.5);
                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;
                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);
                vec3 normalSample = sampleInfo.gba * 2.0 - 1.0;
                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);
                float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);
                float weight = rangeCheck;
                totalWeight += weight;
                texel += sampleInfo * weight;
            }
        }
        if (totalWeight == 0.0) {
            texel = texture2D(tDiffuse, vUv);
        } else {
            texel /= totalWeight;
        }
    }
        #else
        vec4 texel = texture2D(tDiffuse, vUv);
        #endif

        #ifdef LOGDEPTH
        texel.r = clamp(texel.r, 0.0, 1.0);
        if (texel.r == 0.0) {
          texel.r = 1.0;
        }
        #endif
     
        float finalAo = pow(texel.r, intensity);
        if (aoTones > 0.0) {
            finalAo = ceil(finalAo * aoTones) / aoTones;
        }
        float fogFactor;
        float fogDepth = distance(
            cameraPos,
            getWorldPos(depth, vUv)
        );
        if (fog) {
            if (fogExp) {
                fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
            } else {
                fogFactor = smoothstep( fogNear, fogFar, fogDepth );
            }
        }
        if (transparencyAware) {
            float transparencyDWOff = texture2D(transparencyDWFalse, vUv).a;
            float transparencyDWOn = texture2D(transparencyDWTrue, vUv).a;
            float adjustmentFactorOff = transparencyDWOff;
            float adjustmentFactorOn = (1.0 - transparencyDWOn) * (
                texture2D(transparencyDWTrueDepth, vUv).r == texture2D(sceneDepth, vUv).r ? 1.0 : 0.0
            );
            float adjustmentFactor = max(adjustmentFactorOff, adjustmentFactorOn);
            finalAo = mix(finalAo, 1.0, adjustmentFactor);
        }
        finalAo = mix(finalAo, 1.0, fogFactor);
        vec3 aoApplied = color * mix(vec3(1.0), sceneTexel.rgb, float(colorMultiply));
        if (renderMode == 0.0) {
            gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 1.0) {
            gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 2.0) {
            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
        } else if (renderMode == 3.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        } else if (renderMode == 4.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        }
        #include <dithering_fragment>
        if (gammaCorrection) {
            gl_FragColor = sRGBTransferOETF(gl_FragColor);
        }
    }
    `
  )
}, Fp = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    projMat: {
      value: new Ce()
    },
    viewMat: {
      value: new Ce()
    },
    projectionMatrixInv: {
      value: new Ce()
    },
    viewMatrixInv: {
      value: new Ce()
    },
    cameraPos: {
      value: new q()
    },
    resolution: {
      value: new Be()
    },
    time: {
      value: 0
    },
    r: {
      value: 5
    },
    blueNoise: {
      value: null
    },
    radius: {
      value: 12
    },
    worldRadius: {
      value: 5
    },
    index: {
      value: 0
    },
    poissonDisk: {
      value: []
    },
    distanceFalloff: {
      value: 1
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: !1
    },
    screenSpaceRadius: {
      value: !1
    }
  },
  depthWrite: !1,
  depthTest: !1,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1.0);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform vec2 resolution;
    uniform float r;
    uniform float radius;
     uniform float worldRadius;
    uniform float index;
     uniform float near;
     uniform float far;
     uniform float distanceFalloff;
     uniform bool logDepth;
     uniform bool screenSpaceRadius;
    varying vec2 vUv;

    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        highp float z_n = 2.0 * d - 1.0;
        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     return linearize_depth(linDepth, nearZ, farZ);
   }
   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
     return nearZ + (farZ - nearZ) * d;
   }
   vec3 getWorldPosLog(vec3 posS) {
     vec2 uv = posS.xy;
     float z = posS.z;
     float nearZ =near;
     float farZ = far;
     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
     vec4 wpos = projectionMatrixInv * clipVec;
     return wpos.xyz / wpos.w;
   }
    vec3 getWorldPos(float depth, vec2 coord) {
     #ifdef LOGDEPTH
      #ifndef ORTHO
          return getWorldPosLog(vec3(coord, depth));
      #endif
     #endif
        
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
    #include <common>
    #define NUM_SAMPLES 16
    uniform vec2 poissonDisk[NUM_SAMPLES];
    void main() {
        const float pi = 3.14159;
        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec2 uv = vUv;
        vec4 data = texture2D(tDiffuse, vUv);
        float occlusion = data.r;
        float baseOcc = data.r;
        vec3 normal = data.gba * 2.0 - 1.0;
        float count = 1.0;
        float d = texture2D(sceneDepth, vUv).x;
        if (d == 1.0) {
          gl_FragColor = data;
          return;
        }
        vec3 worldPos = getWorldPos(d, vUv);
        float size = radius;
        float angle;
        if (index == 0.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;
        } else if (index == 1.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;
        } else if (index == 2.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;
        } else {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;
        }

        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        float radiusToUse = screenSpaceRadius ? distance(
          worldPos,
          getWorldPos(d, vUv +
            vec2(worldRadius, 0.0) / resolution)
        ) : worldRadius;
        float distanceFalloffToUse =screenSpaceRadius ?
        radiusToUse * distanceFalloff
    : radiusToUse * distanceFalloff * 0.2;

        float invDistance = (1.0 / distanceFalloffToUse);
        for(int i = 0; i < NUM_SAMPLES; i++) {
            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;
            vec4 dataSample = texture2D(tDiffuse, uv + offset);
            float occSample = dataSample.r;
            vec3 normalSample = dataSample.gba * 2.0 - 1.0;
            float dSample = texture2D(sceneDepth, uv + offset).x;
            vec3 worldPosSample = getWorldPos(dSample, uv + offset);
            float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
            float rangeCheck = float(dSample != 1.0) * exp(-1.0 * tangentPlaneDist * invDistance ) * max(dot(normal, normalSample), 0.0);
            occlusion += occSample * rangeCheck;
            count += rangeCheck;
        }
        if (count > 0.0) {
          occlusion /= count;
        }
        #ifdef LOGDEPTH
          occlusion = clamp(occlusion, 0.0, 1.0);
          if (occlusion == 0.0) {
            occlusion = 1.0;
          }
        #endif
        gl_FragColor = vec4(occlusion, 0.5 + 0.5 * normal);
    }
    `
  )
}, wp = {
  uniforms: {
    sceneDepth: {
      value: null
    },
    resolution: {
      value: new Be()
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    viewMatrixInv: {
      value: new Ce()
    },
    projectionMatrixInv: {
      value: new Ce()
    },
    logDepth: {
      value: !1
    },
    ortho: {
      value: !1
    }
  },
  depthWrite: !1,
  depthTest: !1,
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1);
    }`
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform highp sampler2D sceneDepth;
    uniform vec2 resolution;
    uniform float near;
    uniform float far;
    uniform bool logDepth;
    uniform bool ortho;
    uniform mat4 viewMatrixInv;
    uniform mat4 projectionMatrixInv;
    varying vec2 vUv;
    layout(location = 1) out vec4 gNormal;
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
        if (logDepth && !ortho) {
          return getWorldPosLog(vec3(coord, depth));
        }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }
    void main() {
        vec2 uv = vUv - vec2(0.5) / resolution;
        vec2 pixelSize = vec2(1.0) / resolution;
        highp vec2[4] uvSamples;
        uvSamples[0] = uv;
        uvSamples[1] = uv + vec2(pixelSize.x, 0.0);
        uvSamples[2] = uv + vec2(0.0, pixelSize.y);
        uvSamples[3] = uv + pixelSize;
        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;
        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;
        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;
        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;
        float minDepth = min(min(depth00, depth10), min(depth01, depth11));
        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));
        float targetDepth = minDepth;
        // Checkerboard pattern to avoid artifacts
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { 
            targetDepth = maxDepth;
        }
        int chosenIndex = 0;
        float[4] samples;
        samples[0] = depth00;
        samples[1] = depth10;
        samples[2] = depth01;
        samples[3] = depth11;
        for(int i = 0; i < 4; ++i) {
            if (samples[i] == targetDepth) {
                chosenIndex = i;
                break;
            }
        }
        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]
        ), 0.0);
    }`
  )
};
var uc = "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";
const vp = parseInt(Wa.replace(/\D+/g, "")), Op = vp >= 162 ? class extends wt {
  constructor(l = 1, t = 1, e = 1, s = {}) {
    super(l, t, {
      ...s,
      count: e
    }), this.isWebGLMultipleRenderTargets = !0;
  }
  get texture() {
    return this.textures;
  }
} : class extends wt {
  constructor(l = 1, t = 1, e = 1, s = {}) {
    super(l, t, s), this.isWebGLMultipleRenderTargets = !0;
    const i = this.texture;
    this.texture = [];
    for (let n = 0; n < e; n++)
      this.texture[n] = i.clone(), this.texture[n].isRenderTargetTexture = !0;
  }
  setSize(l, t, e = 1) {
    if (this.width !== l || this.height !== t || this.depth !== e) {
      this.width = l, this.height = t, this.depth = e;
      for (let s = 0, i = this.texture.length; s < i; s++)
        this.texture[s].image.width = l, this.texture[s].image.height = t, this.texture[s].image.depth = e;
      this.dispose();
    }
    this.viewport.set(0, 0, l, t), this.scissor.set(0, 0, l, t);
  }
  copy(l) {
    this.dispose(), this.width = l.width, this.height = l.height, this.depth = l.depth, this.scissor.copy(l.scissor), this.scissorTest = l.scissorTest, this.viewport.copy(l.viewport), this.depthBuffer = l.depthBuffer, this.stencilBuffer = l.stencilBuffer, l.depthTexture !== null && (this.depthTexture = l.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, e = l.texture.length; t < e; t++)
      this.texture[t] = l.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
};
Uint8Array.from(atob(uc), (l) => l.charCodeAt(0));
const Pp = Uint8Array.from(atob(uc), (l) => l.charCodeAt(0));
function fc(l, t, e) {
  if (t.getQueryParameter(l, t.QUERY_RESULT_AVAILABLE)) {
    const n = t.getQueryParameter(l, t.QUERY_RESULT) / 1e6;
    e.lastTime = e.lastTime === 0 ? n : e.timeRollingAverage * e.lastTime + (1 - e.timeRollingAverage) * n;
  } else
    setTimeout(() => {
      fc(l, t, e);
    }, 1);
}
class Np extends ks {
  /**
   * 
   * @param {THREE.Scene} scene
   * @param {THREE.Camera} camera 
   * @param {number} width 
   * @param {number} height
   *  
   * @property {THREE.Scene} scene
   * @property {THREE.Camera} camera
   * @property {number} width
   * @property {number} height
   */
  constructor(t, e, s = 512, i = 512) {
    super(), this.width = s, this.height = i, this.clear = !0, this.camera = e, this.scene = t, this.configuration = new Proxy({
      aoSamples: 16,
      aoRadius: 5,
      aoTones: 0,
      denoiseSamples: 8,
      denoiseRadius: 12,
      distanceFalloff: 1,
      intensity: 5,
      denoiseIterations: 2,
      renderMode: 0,
      biasOffset: 0,
      biasMultiplier: 0,
      color: new ai(0, 0, 0),
      gammaCorrection: !0,
      logarithmicDepthBuffer: !1,
      screenSpaceRadius: !1,
      halfRes: !1,
      depthAwareUpsampling: !0,
      autoRenderBeauty: !0,
      colorMultiply: !0,
      transparencyAware: !1,
      stencil: !1,
      accumulate: !1
    }, {
      set: (n, r, o) => {
        const a = n[r];
        return n[r] = o, o.equals ? o.equals(a) || this.firstFrame() : a !== o && this.firstFrame(), r === "aoSamples" && a !== o && this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), r === "denoiseSamples" && a !== o && this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), r === "halfRes" && a !== o && (this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureHalfResTargets(), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.setSize(this.width, this.height)), r === "depthAwareUpsampling" && a !== o && this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), r === "transparencyAware" && a !== o && (this.autoDetectTransparency = !1, this.configureTransparencyTarget()), r === "stencil" && a !== o && (this.beautyRenderTarget.dispose(), this.beautyRenderTarget = new wt(this.width, this.height, {
          minFilter: Et,
          magFilter: gt,
          type: ns,
          format: Gt,
          stencilBuffer: o
        }), this.beautyRenderTarget.depthTexture = new Kn(this.width, this.height, o ? xc : qn), this.beautyRenderTarget.depthTexture.format = o ? Lc : go), !0;
      }
    }), this.samples = [], this.samplesDenoise = [], this.autoDetectTransparency = !0, this.frame = 0, this.lastViewMatrix = new Ce(), this.lastProjectionMatrix = new Ce(), this.beautyRenderTarget = new wt(this.width, this.height, {
      minFilter: Et,
      magFilter: gt,
      type: ns,
      format: Gt,
      stencilBuffer: !1
    }), this.beautyRenderTarget.depthTexture = new Kn(this.width, this.height, qn), this.beautyRenderTarget.depthTexture.format = go, this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureSampleDependentPasses(), this.configureHalfResTargets(), this.detectTransparency(), this.configureTransparencyTarget(), this.writeTargetInternal = new wt(this.width, this.height, {
      minFilter: Et,
      magFilter: Et,
      depthBuffer: !1,
      format: Gt
    }), this.readTargetInternal = new wt(this.width, this.height, {
      minFilter: Et,
      magFilter: Et,
      depthBuffer: !1,
      format: Gt
    }), this.accumulationRenderTarget = new wt(this.width, this.height, {
      minFilter: Et,
      magFilter: Et,
      depthBuffer: !1,
      format: Gt,
      type: ns,
      stencilBuffer: !1,
      depthBuffer: !1,
      alpha: !0
    }), this.bluenoise = new Mc(Pp, 128, 128), this.accumulationQuad = new Ns(new nt({
      uniforms: {
        frame: {
          value: 0
        },
        tDiffuse: {
          value: null
        }
      },
      transparent: !0,
      opacity: 1,
      vertexShader: `
             varying vec2 vUv;
             void main() {
                 vUv = uv;
                 gl_Position = vec4(position, 1);
             }`,
      fragmentShader: `
             uniform sampler2D tDiffuse;
             uniform float frame;
                varying vec2 vUv;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    gl_FragColor = vec4(color.rgb, 1.0 / (frame + 1.0));
                }
                `
    })), this.bluenoise.colorSpace = bc, this.bluenoise.wrapS = Co, this.bluenoise.wrapT = Co, this.bluenoise.minFilter = gt, this.bluenoise.magFilter = gt, this.bluenoise.needsUpdate = !0, this.lastTime = 0, this.timeRollingAverage = 0.99, this._r = new Be(), this._c = new ai();
  }
  configureHalfResTargets() {
    this.firstFrame(), this.configuration.halfRes ? (this.depthDownsampleTarget = new Op(this.width / 2, this.height / 2, 2), Wa <= 161 && (this.depthDownsampleTarget.textures = this.depthDownsampleTarget.texture), this.depthDownsampleTarget.textures[0].format = Dc, this.depthDownsampleTarget.textures[0].type = _c, this.depthDownsampleTarget.textures[0].minFilter = gt, this.depthDownsampleTarget.textures[0].magFilter = gt, this.depthDownsampleTarget.textures[0].depthBuffer = !1, this.depthDownsampleTarget.textures[1].format = Gt, this.depthDownsampleTarget.textures[1].type = ns, this.depthDownsampleTarget.textures[1].minFilter = gt, this.depthDownsampleTarget.textures[1].magFilter = gt, this.depthDownsampleTarget.textures[1].depthBuffer = !1, this.depthDownsampleQuad = new Ns(new nt(wp))) : (this.depthDownsampleTarget && (this.depthDownsampleTarget.dispose(), this.depthDownsampleTarget = null), this.depthDownsampleQuad && (this.depthDownsampleQuad.dispose(), this.depthDownsampleQuad = null));
  }
  detectTransparency() {
    if (this.autoDetectTransparency) {
      let t = !1;
      this.scene.traverse((e) => {
        e.material && e.material.transparent && (t = !0);
      }), this.configuration.transparencyAware = t;
    }
  }
  configureTransparencyTarget() {
    this.configuration.transparencyAware ? (this.transparencyRenderTargetDWFalse = new wt(this.width, this.height, {
      minFilter: Et,
      magFilter: gt,
      type: ns,
      format: Gt
    }), this.transparencyRenderTargetDWTrue = new wt(this.width, this.height, {
      minFilter: Et,
      magFilter: gt,
      type: ns,
      format: Gt
    }), this.transparencyRenderTargetDWTrue.depthTexture = new Kn(this.width, this.height, qn), this.depthCopyPass = new Ns(new nt({
      uniforms: {
        depthTexture: {
          value: this.beautyRenderTarget.depthTexture
        }
      },
      vertexShader: (
        /* glsl */
        `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1);
            }`
      ),
      fragmentShader: (
        /* glsl */
        `
            uniform sampler2D depthTexture;
            varying vec2 vUv;
            void main() {
               gl_FragDepth = texture2D(depthTexture, vUv).r + 0.00001;
               gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
            `
      )
    }))) : (this.transparencyRenderTargetDWFalse && (this.transparencyRenderTargetDWFalse.dispose(), this.transparencyRenderTargetDWFalse = null), this.transparencyRenderTargetDWTrue && (this.transparencyRenderTargetDWTrue.dispose(), this.transparencyRenderTargetDWTrue = null), this.depthCopyPass && (this.depthCopyPass.dispose(), this.depthCopyPass = null));
  }
  renderTransparency(t) {
    const e = this.scene.background, s = t.getClearColor(new ai()), i = t.getClearAlpha(), n = /* @__PURE__ */ new Map(), r = t.autoClearDepth;
    this.scene.traverse((o) => {
      n.set(o, o.visible);
    }), this.scene.background = null, t.autoClearDepth = !1, t.setClearColor(new ai(0, 0, 0), 0), this.depthCopyPass.material.uniforms.depthTexture.value = this.beautyRenderTarget.depthTexture, t.setRenderTarget(this.transparencyRenderTargetDWFalse), this.scene.traverse((o) => {
      o.material && (o.visible = n.get(o) && (o.material.transparent && !o.material.depthWrite && !o.userData.treatAsOpaque || !!o.userData.cannotReceiveAO));
    }), t.clear(!0, !0, !0), this.depthCopyPass.render(t), t.render(this.scene, this.camera), t.setRenderTarget(this.transparencyRenderTargetDWTrue), this.scene.traverse((o) => {
      o.material && (o.visible = n.get(o) && o.material.transparent && o.material.depthWrite && !o.userData.treatAsOpaque);
    }), t.clear(!0, !0, !0), this.depthCopyPass.render(t), t.render(this.scene, this.camera), this.scene.traverse((o) => {
      o.visible = n.get(o);
    }), t.setClearColor(s, i), this.scene.background = e, t.autoClearDepth = r;
  }
  configureSampleDependentPasses() {
    this.firstFrame(), this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
  }
  configureAOPass(t = !1, e = !1) {
    this.firstFrame(), this.samples = this.generateHemisphereSamples(this.configuration.aoSamples);
    const s = {
      ...Sp
    };
    s.fragmentShader = s.fragmentShader.replace("16", this.configuration.aoSamples).replace("16.0", this.configuration.aoSamples + ".0"), t && (s.fragmentShader = `#define LOGDEPTH
` + s.fragmentShader), e && (s.fragmentShader = `#define ORTHO
` + s.fragmentShader), this.configuration.halfRes && (s.fragmentShader = `#define HALFRES
` + s.fragmentShader), this.effectShaderQuad ? (this.effectShaderQuad.material.dispose(), this.effectShaderQuad.material = new nt(s)) : this.effectShaderQuad = new Ns(new nt(s));
  }
  configureDenoisePass(t = !1, e = !1) {
    this.firstFrame(), this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);
    const s = {
      ...Fp
    };
    s.fragmentShader = s.fragmentShader.replace("16", this.configuration.denoiseSamples), t && (s.fragmentShader = `#define LOGDEPTH
` + s.fragmentShader), e && (s.fragmentShader = `#define ORTHO
` + s.fragmentShader), this.poissonBlurQuad ? (this.poissonBlurQuad.material.dispose(), this.poissonBlurQuad.material = new nt(s)) : this.poissonBlurQuad = new Ns(new nt(s));
  }
  configureEffectCompositer(t = !1, e = !1) {
    this.firstFrame();
    const s = {
      ...Ap
    };
    t && (s.fragmentShader = `#define LOGDEPTH
` + s.fragmentShader), e && (s.fragmentShader = `#define ORTHO
` + s.fragmentShader), this.configuration.halfRes && this.configuration.depthAwareUpsampling && (s.fragmentShader = `#define HALFRES
` + s.fragmentShader), this.effectCompositerQuad ? (this.effectCompositerQuad.material.dispose(), this.effectCompositerQuad.material = new nt(s)) : this.effectCompositerQuad = new Ns(new nt(s));
  }
  /**
       * 
       * @param {Number} n 
       * @returns {THREE.Vector3[]}
       */
  generateHemisphereSamples(t) {
    const e = [];
    for (let s = 0; s < t; s++) {
      const i = 2.399963 * s;
      let n = Math.sqrt(s + 0.5) / Math.sqrt(t);
      const r = n * Math.cos(i), o = n * Math.sin(i), a = Math.sqrt(1 - (r * r + o * o));
      e.push(new q(r, o, a));
    }
    return e;
  }
  /**
       * 
       * @param {number} numSamples 
       * @param {number} numRings 
       * @returns {THREE.Vector2[]}
       */
  generateDenoiseSamples(t, e) {
    const s = 2 * Math.PI * e / t, i = 1 / t, n = i, r = [];
    let o = i, a = 0;
    for (let c = 0; c < t; c++)
      r.push(new Be(Math.cos(a), Math.sin(a)).multiplyScalar(Math.pow(o, 0.75))), o += n, a += s;
    return r;
  }
  setSize(t, e) {
    this.firstFrame(), this.width = t, this.height = e;
    const s = this.configuration.halfRes ? 0.5 : 1;
    this.beautyRenderTarget.setSize(t, e), this.writeTargetInternal.setSize(t * s, e * s), this.readTargetInternal.setSize(t * s, e * s), this.accumulationRenderTarget.setSize(t * s, e * s), this.configuration.halfRes && this.depthDownsampleTarget.setSize(t * s, e * s), this.configuration.transparencyAware && (this.transparencyRenderTargetDWFalse.setSize(t, e), this.transparencyRenderTargetDWTrue.setSize(t, e));
  }
  firstFrame() {
    this.needsFrame = !0;
  }
  render(t, e, s, i, n) {
    t.capabilities.logarithmicDepthBuffer !== this.configuration.logarithmicDepthBuffer && (this.configuration.logarithmicDepthBuffer = t.capabilities.logarithmicDepthBuffer, this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera)), this.detectTransparency(), this.camera.updateMatrixWorld(), this.lastViewMatrix.equals(this.camera.matrixWorldInverse) && this.lastProjectionMatrix.equals(this.camera.projectionMatrix) && this.configuration.accumulate && !this.needsFrame ? this.frame++ : (this.configuration.accumulate && (t.setRenderTarget(this.accumulationRenderTarget), t.clear(!0, !0, !0)), this.frame = 0, this.needsFrame = !1), this.lastViewMatrix.copy(this.camera.matrixWorldInverse), this.lastProjectionMatrix.copy(this.camera.projectionMatrix);
    let r, o, a;
    this.debugMode && (r = t.getContext(), o = r.getExtension("EXT_disjoint_timer_query_webgl2"), o === null && (console.error("EXT_disjoint_timer_query_webgl2 not available, disabling debug mode."), this.debugMode = !1)), this.configuration.autoRenderBeauty && (t.setRenderTarget(this.beautyRenderTarget), t.render(this.scene, this.camera), this.configuration.transparencyAware && this.renderTransparency(t)), this.debugMode && (a = r.createQuery(), r.beginQuery(o.TIME_ELAPSED_EXT, a));
    const c = t.xr.enabled;
    t.xr.enabled = !1, this._r.set(this.width, this.height);
    let h = this.configuration.aoRadius;
    if (this.configuration.halfRes && this.configuration.screenSpaceRadius && (h *= 0.5), this.frame < 1024 / this.configuration.aoSamples) {
      this.configuration.halfRes && (t.setRenderTarget(this.depthDownsampleTarget), this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.depthDownsampleQuad.material.uniforms.resolution.value = this._r, this.depthDownsampleQuad.material.uniforms.near.value = this.camera.near, this.depthDownsampleQuad.material.uniforms.far.value = this.camera.far, this.depthDownsampleQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.depthDownsampleQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.depthDownsampleQuad.material.uniforms.logDepth.value = this.configuration.logarithmicDepthBuffer, this.depthDownsampleQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.depthDownsampleQuad.render(t)), this.effectShaderQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectShaderQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture, this.effectShaderQuad.material.uniforms.sceneNormal.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[1] : null, this.effectShaderQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.effectShaderQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.effectShaderQuad.material.uniforms.projViewMat.value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone()), this.effectShaderQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectShaderQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectShaderQuad.material.uniforms.cameraPos.value = this.camera.getWorldPosition(new q()), this.effectShaderQuad.material.uniforms.biasAdjustment.value = new Be(this.configuration.biasOffset, this.configuration.biasMultiplier), this.effectShaderQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.effectShaderQuad.material.uniforms.time.value = performance.now() / 1e3, this.effectShaderQuad.material.uniforms.samples.value = this.samples, this.effectShaderQuad.material.uniforms.bluenoise.value = this.bluenoise, this.effectShaderQuad.material.uniforms.radius.value = h, this.effectShaderQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectShaderQuad.material.uniforms.near.value = this.camera.near, this.effectShaderQuad.material.uniforms.far.value = this.camera.far, this.effectShaderQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectShaderQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectShaderQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, this.effectShaderQuad.material.uniforms.frame.value = this.frame, t.setRenderTarget(this.writeTargetInternal), this.effectShaderQuad.render(t);
      for (let u = 0; u < this.configuration.denoiseIterations; u++)
        [this.writeTargetInternal, this.readTargetInternal] = [
          this.readTargetInternal,
          this.writeTargetInternal
        ], this.poissonBlurQuad.material.uniforms.tDiffuse.value = this.readTargetInternal.texture, this.poissonBlurQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture, this.poissonBlurQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.poissonBlurQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.poissonBlurQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.poissonBlurQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.poissonBlurQuad.material.uniforms.cameraPos.value = this.camera.getWorldPosition(new q()), this.poissonBlurQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.poissonBlurQuad.material.uniforms.time.value = performance.now() / 1e3, this.poissonBlurQuad.material.uniforms.blueNoise.value = this.bluenoise, this.poissonBlurQuad.material.uniforms.radius.value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1), this.poissonBlurQuad.material.uniforms.worldRadius.value = h, this.poissonBlurQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.poissonBlurQuad.material.uniforms.index.value = u, this.poissonBlurQuad.material.uniforms.poissonDisk.value = this.samplesDenoise, this.poissonBlurQuad.material.uniforms.near.value = this.camera.near, this.poissonBlurQuad.material.uniforms.far.value = this.camera.far, this.poissonBlurQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.poissonBlurQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, t.setRenderTarget(this.writeTargetInternal), this.poissonBlurQuad.render(t);
      t.setRenderTarget(this.accumulationRenderTarget);
      const f = t.autoClear;
      t.autoClear = !1, this.accumulationQuad.material.uniforms.tDiffuse.value = this.writeTargetInternal.texture, this.accumulationQuad.material.uniforms.frame.value = this.frame, this.accumulationQuad.render(t), t.autoClear = f;
    }
    this.configuration.transparencyAware && (this.effectCompositerQuad.material.uniforms.transparencyDWFalse.value = this.transparencyRenderTargetDWFalse.texture, this.effectCompositerQuad.material.uniforms.transparencyDWTrue.value = this.transparencyRenderTargetDWTrue.texture, this.effectCompositerQuad.material.uniforms.transparencyDWTrueDepth.value = this.transparencyRenderTargetDWTrue.depthTexture, this.effectCompositerQuad.material.uniforms.transparencyAware.value = !0), this.effectCompositerQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectCompositerQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.aoTones.value = this.configuration.aoTones, this.effectCompositerQuad.material.uniforms.near.value = this.camera.near, this.effectCompositerQuad.material.uniforms.far.value = this.camera.far, this.effectCompositerQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectCompositerQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectCompositerQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectCompositerQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectCompositerQuad.material.uniforms.downsampledDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.resolution.value = this._r, this.effectCompositerQuad.material.uniforms.blueNoise.value = this.bluenoise, this.effectCompositerQuad.material.uniforms.intensity.value = this.configuration.intensity, this.effectCompositerQuad.material.uniforms.renderMode.value = this.configuration.renderMode, this.effectCompositerQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, this.effectCompositerQuad.material.uniforms.radius.value = h, this.effectCompositerQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectCompositerQuad.material.uniforms.gammaCorrection.value = this.configuration.gammaCorrection, this.effectCompositerQuad.material.uniforms.tDiffuse.value = this.accumulationRenderTarget.texture, this.effectCompositerQuad.material.uniforms.color.value = this._c.copy(this.configuration.color).convertSRGBToLinear(), this.effectCompositerQuad.material.uniforms.colorMultiply.value = this.configuration.colorMultiply, this.effectCompositerQuad.material.uniforms.cameraPos.value = this.camera.getWorldPosition(new q()), this.effectCompositerQuad.material.uniforms.fog.value = !!this.scene.fog, this.scene.fog && (this.scene.fog.isFog ? (this.effectCompositerQuad.material.uniforms.fogExp.value = !1, this.effectCompositerQuad.material.uniforms.fogNear.value = this.scene.fog.near, this.effectCompositerQuad.material.uniforms.fogFar.value = this.scene.fog.far) : this.scene.fog.isFogExp2 ? (this.effectCompositerQuad.material.uniforms.fogExp.value = !0, this.effectCompositerQuad.material.uniforms.fogDensity.value = this.scene.fog.density) : console.error(`Unsupported fog type ${this.scene.fog.constructor.name} in SSAOPass.`)), t.setRenderTarget(this.renderToScreen ? null : e), this.effectCompositerQuad.render(t), this.debugMode && (r.endQuery(o.TIME_ELAPSED_EXT), fc(a, r, this)), t.xr.enabled = c;
  }
  /**
       * Enables the debug mode of the AO, meaning the lastTime value will be updated.
       */
  enableDebugMode() {
    this.debugMode = !0;
  }
  /**
       * Disables the debug mode of the AO, meaning the lastTime value will not be updated.
       */
  disableDebugMode() {
    this.debugMode = !1;
  }
  /**
       * Sets the display mode of the AO
       * @param {"Combined" | "AO" | "No AO" | "Split" | "Split AO"} mode - The display mode. 
       */
  setDisplayMode(t) {
    this.configuration.renderMode = [
      "Combined",
      "AO",
      "No AO",
      "Split",
      "Split AO"
    ].indexOf(t);
  }
  /**
       * 
       * @param {"Performance" | "Low" | "Medium" | "High" | "Ultra"} mode 
       */
  setQualityMode(t) {
    t === "Performance" ? (this.configuration.aoSamples = 8, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Low" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Medium" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 12) : t === "High" ? (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 6) : t === "Ultra" && (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 16, this.configuration.denoiseRadius = 6);
  }
}
const xp = {
  name: "GammaCorrectionShader",
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = sRGBTransferOETF( tex );

		}`
  )
};
function Lp() {
  return new A.ShaderMaterial({
    side: 2,
    clipping: !0,
    uniforms: {},
    vertexShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
    
       vec4 absPosition = vec4(position, 1.0);
       vec3 trueNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          trueNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       trueNormal = (normalize(modelMatrix * vec4(trueNormal, 0.))).xyz;
       
       vec3 planePosition = absPosition.xyz / 40.;
       float d = abs(dot(trueNormal, planePosition));
       vColor = vec4(abs(trueNormal), d);
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      gl_FragColor = vColor;
    }
    `
  });
}
function Mp() {
  return new A.ShaderMaterial({
    side: 2,
    clipping: !0,
    uniforms: {},
    vertexShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
       
       vec4 absPosition = vec4(position, 1.0);
       vNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          vNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       vNormal = (normalize(modelMatrix * vec4(vNormal, 0.))).xyz;
       
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       vCameraPosition = cameraPosition;
       vPosition = absPosition.xyz;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      vec3 cameraPixelVec = normalize(vCameraPosition - vPosition);
      float difference = abs(dot(vNormal, cameraPixelVec));
      
      // This achieves a double gloss effect: when the surface is perpendicular and when it's parallel
      difference = abs((difference * 2.) - 1.);
      
      gl_FragColor = vec4(difference, difference, difference, 1.);
    }
    `
  });
}
class bp extends ks {
  constructor(e, s, i, n, r) {
    super();
    w(this, "components");
    w(this, "resolution");
    w(this, "renderScene");
    w(this, "renderCamera");
    w(this, "fsQuad");
    w(this, "normalOverrideMaterial");
    w(this, "glossOverrideMaterial");
    w(this, "planeBuffer");
    w(this, "glossBuffer");
    w(this, "outlineBuffer");
    w(this, "excludedMeshes", []);
    w(this, "outlinedMeshes", {});
    w(this, "outlineScene", new A.Scene());
    w(this, "_outlineEnabled", !1);
    w(this, "_lineColor", 10066329);
    w(this, "_opacity", 0.4);
    w(this, "_tolerance", 3);
    w(this, "_glossEnabled", !0);
    w(this, "_glossExponent", 1.9);
    w(this, "_minGloss", -0.1);
    w(this, "_maxGloss", 0.1);
    if (!i.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = s, this.renderScene = n, this.renderCamera = r, this.resolution = new A.Vector2(e.x, e.y), this.fsQuad = new cc(), this.fsQuad.material = this.createOutlinePostProcessMaterial(), this.planeBuffer = this.newRenderTarget(), this.glossBuffer = this.newRenderTarget(), this.outlineBuffer = this.newRenderTarget();
    const o = Lp();
    o.clippingPlanes = i.renderer.clippingPlanes, this.normalOverrideMaterial = o;
    const a = Mp();
    a.clippingPlanes = i.renderer.clippingPlanes, this.glossOverrideMaterial = a;
  }
  get lineColor() {
    return this._lineColor;
  }
  set lineColor(e) {
    this._lineColor = e, this.fsQuad.material.uniforms.lineColor.value.set(e);
  }
  get tolerance() {
    return this._tolerance;
  }
  set tolerance(e) {
    this._tolerance = e;
    const s = this.fsQuad.material;
    s.uniforms.tolerance.value = e;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e) {
    this._opacity = e;
    const s = this.fsQuad.material;
    s.uniforms.opacity.value = e;
  }
  get glossEnabled() {
    return this._glossEnabled;
  }
  set glossEnabled(e) {
    if (e === this._glossEnabled)
      return;
    this._glossEnabled = e;
    const s = this.fsQuad.material;
    s.uniforms.glossEnabled.value = e ? 1 : 0;
  }
  get glossExponent() {
    return this._glossExponent;
  }
  set glossExponent(e) {
    this._glossExponent = e;
    const s = this.fsQuad.material;
    s.uniforms.glossExponent.value = e;
  }
  get minGloss() {
    return this._minGloss;
  }
  set minGloss(e) {
    this._minGloss = e;
    const s = this.fsQuad.material;
    s.uniforms.minGloss.value = e;
  }
  get maxGloss() {
    return new A.MeshBasicMaterial().color.convertLinearToSRGB(), this._maxGloss;
  }
  set maxGloss(e) {
    this._maxGloss = e;
    const s = this.fsQuad.material;
    s.uniforms.maxGloss.value = e;
  }
  get outlineEnabled() {
    return this._outlineEnabled;
  }
  set outlineEnabled(e) {
    if (e === this._outlineEnabled)
      return;
    this._outlineEnabled = e;
    const s = this.fsQuad.material;
    s.uniforms.outlineEnabled.value = e ? 1 : 0;
  }
  async dispose() {
    this.planeBuffer.dispose(), this.glossBuffer.dispose(), this.outlineBuffer.dispose(), this.normalOverrideMaterial.dispose(), this.glossOverrideMaterial.dispose(), this.fsQuad.material.dispose(), this.fsQuad.dispose(), this.excludedMeshes = [], this.outlineScene.children = [];
    const e = this.components.get(Ot);
    for (const s in this.outlinedMeshes) {
      const i = this.outlinedMeshes[s];
      for (const n of i.meshes) {
        e.destroy(n, !0, !0);
        const r = n;
        r.fragment && r.fragment.dispose(!0);
      }
      i.material.dispose();
    }
  }
  setSize(e, s) {
    this.planeBuffer.setSize(e, s), this.glossBuffer.setSize(e, s), this.outlineBuffer.setSize(e, s), this.resolution.set(e, s);
    const i = this.fsQuad.material;
    i.uniforms.screenSize.value.set(
      this.resolution.x,
      this.resolution.y,
      1 / this.resolution.x,
      1 / this.resolution.y
    ), i.uniformsNeedUpdate = !0;
  }
  render(e, s, i) {
    const n = s.depthBuffer;
    s.depthBuffer = !1;
    const r = this.renderScene.overrideMaterial, o = this.renderScene.background;
    this.renderScene.background = null;
    for (const c of this.excludedMeshes)
      c.visible = !1;
    e.setRenderTarget(this.planeBuffer), this.renderScene.overrideMaterial = this.normalOverrideMaterial, e.render(this.renderScene, this.renderCamera), this._glossEnabled && (e.setRenderTarget(this.glossBuffer), this.renderScene.overrideMaterial = this.glossOverrideMaterial, e.render(this.renderScene, this.renderCamera)), this.renderScene.overrideMaterial = r, e.setRenderTarget(this.outlineBuffer), this._outlineEnabled ? e.render(this.outlineScene, this.renderCamera) : e.clear();
    for (const c of this.excludedMeshes)
      c.visible = !0;
    this.renderScene.background = o;
    const a = this.fsQuad.material;
    a.uniforms.planeBuffer.value = this.planeBuffer.texture, a.uniforms.glossBuffer.value = this.glossBuffer.texture, a.uniforms.outlineBuffer.value = this.outlineBuffer.texture, a.uniforms.sceneColorBuffer.value = i.texture, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(s), this.fsQuad.render(e)), s.depthBuffer = n;
  }
  get vertexShader() {
    return `
	  varying vec2 vUv;
	  void main() {
	  	vUv = uv;
	  	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	  }
	`;
  }
  get fragmentShader() {
    return `
	  uniform sampler2D sceneColorBuffer;
	  uniform sampler2D planeBuffer;
	  uniform sampler2D glossBuffer;
	  uniform sampler2D outlineBuffer;
	  uniform vec4 screenSize;
	  uniform vec3 lineColor;
	  
	  uniform float outlineEnabled;
	  
      uniform int width;
	  uniform float opacity;
      uniform float tolerance;
      uniform float glossExponent;
      uniform float minGloss;
      uniform float maxGloss;
      uniform float glossEnabled;

	  varying vec2 vUv;

	  vec4 getValue(sampler2D buffer, int x, int y) {
	  	return texture2D(buffer, vUv + screenSize.zw * vec2(x, y));
	  }

      float normalDiff(vec3 normal1, vec3 normal2) {
        return ((dot(normal1, normal2) - 1.) * -1.) / 2.;
      }

      // Returns 0 if it's background, 1 if it's not
      float getIsBackground(vec3 normal) {
        float background = 1.0;
        background *= step(normal.x, 0.);
        background *= step(normal.y, 0.);
        background *= step(normal.z, 0.);
        background = (background - 1.) * -1.;
        return background;
      }

	  void main() {
	  
	    vec4 sceneColor = getValue(sceneColorBuffer, 0, 0);
	    vec3 normSceneColor = normalize(sceneColor.rgb);
  
        vec4 plane = getValue(planeBuffer, 0, 0);
	    vec3 normal = plane.xyz;
        float distance = plane.w;
  
        vec3 normalTop = getValue(planeBuffer, 0, width).rgb;
        vec3 normalBottom = getValue(planeBuffer, 0, -width).rgb;
        vec3 normalRight = getValue(planeBuffer, width, 0).rgb;
        vec3 normalLeft = getValue(planeBuffer, -width, 0).rgb;
        vec3 normalTopRight = getValue(planeBuffer, width, width).rgb;
        vec3 normalTopLeft = getValue(planeBuffer, -width, width).rgb;
        vec3 normalBottomRight = getValue(planeBuffer, width, -width).rgb;
        vec3 normalBottomLeft = getValue(planeBuffer, -width, -width).rgb;
  
        float distanceTop = getValue(planeBuffer, 0, width).a;
        float distanceBottom = getValue(planeBuffer, 0, -width).a;
        float distanceRight = getValue(planeBuffer, width, 0).a;
        float distanceLeft = getValue(planeBuffer, -width, 0).a;
        float distanceTopRight = getValue(planeBuffer, width, width).a;
        float distanceTopLeft = getValue(planeBuffer, -width, width).a;
        float distanceBottomRight = getValue(planeBuffer, width, -width).a;
        float distanceBottomLeft = getValue(planeBuffer, -width, -width).a;
        
        vec3 sceneColorTop = normalize(getValue(sceneColorBuffer, 1, 0).rgb);
        vec3 sceneColorBottom = normalize(getValue(sceneColorBuffer, -1, 0).rgb);
        vec3 sceneColorLeft = normalize(getValue(sceneColorBuffer, 0, -1).rgb);
        vec3 sceneColorRight = normalize(getValue(sceneColorBuffer, 0, 1).rgb);
        vec3 sceneColorTopRight = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomRight = normalize(getValue(sceneColorBuffer, -1, 1).rgb);
        vec3 sceneColorTopLeft = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomLeft = normalize(getValue(sceneColorBuffer, -1, 1).rgb);

        // Checks if the planes of this texel and the neighbour texels are different

        float planeDiff = 0.0;

        planeDiff += step(0.001, normalDiff(normal, normalTop));
        planeDiff += step(0.001, normalDiff(normal, normalBottom));
        planeDiff += step(0.001, normalDiff(normal, normalLeft));
        planeDiff += step(0.001, normalDiff(normal, normalRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopLeft));
        planeDiff += step(0.001, normalDiff(normal, normalBottomRight));
        planeDiff += step(0.001, normalDiff(normal, normalBottomLeft));
        
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTop));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottom));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorRight));
       	planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomLeft));

        planeDiff += step(0.001, abs(distance - distanceTop));
        planeDiff += step(0.001, abs(distance - distanceBottom));
        planeDiff += step(0.001, abs(distance - distanceLeft));
        planeDiff += step(0.001, abs(distance - distanceRight));
        planeDiff += step(0.001, abs(distance - distanceTopRight));
        planeDiff += step(0.001, abs(distance - distanceTopLeft));
        planeDiff += step(0.001, abs(distance - distanceBottomRight));
        planeDiff += step(0.001, abs(distance - distanceBottomLeft));

        // Add extra background outline

        int width2 = width + 1;
        vec3 normalTop2 = getValue(planeBuffer, 0, width2).rgb;
        vec3 normalBottom2 = getValue(planeBuffer, 0, -width2).rgb;
        vec3 normalRight2 = getValue(planeBuffer, width2, 0).rgb;
        vec3 normalLeft2 = getValue(planeBuffer, -width2, 0).rgb;
        vec3 normalTopRight2 = getValue(planeBuffer, width2, width2).rgb;
        vec3 normalTopLeft2 = getValue(planeBuffer, -width2, width2).rgb;
        vec3 normalBottomRight2 = getValue(planeBuffer, width2, -width2).rgb;
        vec3 normalBottomLeft2 = getValue(planeBuffer, -width2, -width2).rgb;

        planeDiff += -(getIsBackground(normalTop2) - 1.);
        planeDiff += -(getIsBackground(normalBottom2) - 1.);
        planeDiff += -(getIsBackground(normalRight2) - 1.);
        planeDiff += -(getIsBackground(normalLeft2) - 1.);
        planeDiff += -(getIsBackground(normalTopRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomLeft2) - 1.);

        // Tolerance sets the minimum amount of differences to consider
        // this texel an edge

        float line = step(tolerance, planeDiff);

        // Exclude background and apply opacity

        float background = getIsBackground(normal);
        line *= background;
        line *= opacity;
        
        // Add gloss
        
        vec3 gloss = getValue(glossBuffer, 0, 0).xyz;
        float diffGloss = abs(maxGloss - minGloss);
        vec3 glossExpVector = vec3(glossExponent,glossExponent,glossExponent);
        gloss = min(pow(gloss, glossExpVector), vec3(1.,1.,1.));
        gloss *= diffGloss;
        gloss += minGloss;
        vec4 glossedColor = sceneColor + vec4(gloss, 1.) * glossEnabled;
        
        vec4 corrected = mix(sceneColor, glossedColor, background);
        
        // Draw lines
        
        corrected = mix(corrected, vec4(lineColor, 1.), line);
        
        // Add outline
        
        vec4 outlinePreview =getValue(outlineBuffer, 0, 0);
        float outlineColorCorrection = 1. / max(0.2, outlinePreview.a);
        vec3 outlineColor = outlinePreview.rgb * outlineColorCorrection;
        
        // thickness between 10 and 2, opacity between 1 and 0.2
	    int outlineThickness = int(outlinePreview.a * 10.);
	    
	    float outlineDiff = 0.;
        
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, -outlineThickness).a);
        
        float outLine = step(4., outlineDiff) * step(outlineDiff, 12.) * outlineEnabled;
        corrected = mix(corrected, vec4(outlineColor, 1.), outLine);
        
        gl_FragColor = corrected;
	}
			`;
  }
  createOutlinePostProcessMaterial() {
    return new A.ShaderMaterial({
      uniforms: {
        opacity: { value: this._opacity },
        debugVisualize: { value: 0 },
        sceneColorBuffer: { value: null },
        tolerance: { value: this._tolerance },
        planeBuffer: { value: null },
        glossBuffer: { value: null },
        outlineBuffer: { value: null },
        glossEnabled: { value: 1 },
        minGloss: { value: this._minGloss },
        maxGloss: { value: this._maxGloss },
        outlineEnabled: { value: 0 },
        glossExponent: { value: this._glossExponent },
        width: { value: 1 },
        lineColor: { value: new A.Color(this._lineColor) },
        screenSize: {
          value: new A.Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        }
      },
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader
    });
  }
  newRenderTarget() {
    const e = new A.WebGLRenderTarget(
      this.resolution.x,
      this.resolution.y
    );
    return e.texture.colorSpace = "srgb-linear", e.texture.format = A.RGBAFormat, e.texture.type = A.HalfFloatType, e.texture.minFilter = A.NearestFilter, e.texture.magFilter = A.NearestFilter, e.texture.generateMipmaps = !1, e.stencilBuffer = !1, e;
  }
}
class Dp {
  constructor(t, e, s) {
    /**
     * The EffectComposer instance used for managing the post-processing effects.
     */
    w(this, "composer");
    /**
     * Flag indicating whether to override the clipping planes of the renderer.
     * Default: false
     */
    w(this, "overrideClippingPlanes", !1);
    w(this, "_components");
    w(this, "_world");
    w(this, "_renderTarget");
    w(this, "_enabled", !1);
    w(this, "_initialized", !1);
    w(this, "_n8ao");
    w(this, "_customEffects");
    w(this, "_basePass");
    w(this, "_gammaPass");
    w(this, "_depthTexture");
    w(this, "_renderer");
    w(this, "_settings", {
      gamma: !0,
      custom: !0,
      ao: !1
    });
    if (!s.renderer)
      throw new Error("The given world must have a renderer!");
    this._components = t, this._renderer = e, this._world = s, this._renderTarget = new A.WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight
    ), this._renderTarget.texture.colorSpace = "srgb-linear", this.composer = new Tp(e, this._renderTarget), this.composer.setSize(window.innerWidth, window.innerHeight);
  }
  /**
   * Getter for the base pass. Throws an error if the custom effects are not initialized.
   */
  get basePass() {
    if (!this._basePass)
      throw new Error("Custom effects not initialized!");
    return this._basePass;
  }
  /**
   * Getter for the gamma pass. Throws an error if the custom effects are not initialized.
   */
  get gammaPass() {
    if (!this._gammaPass)
      throw new Error("Custom effects not initialized!");
    return this._gammaPass;
  }
  /**
   * Getter for the custom effects pass. Throws an error if the custom effects are not initialized.
   */
  get customEffects() {
    if (!this._customEffects)
      throw new Error("Custom effects not initialized!");
    return this._customEffects;
  }
  /**
   * Getter for the N8AO pass. Throws an error if the custom effects are not initialized.
   */
  get n8ao() {
    if (!this._n8ao)
      throw new Error("Custom effects not initialized!");
    return this._n8ao;
  }
  /**
   * Getter for the enabled state of the post-processing effects.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the post-processing effects.
   * If the custom effects are not initialized, it calls the initialize method.
   * @param {boolean} active - The new enabled state.
   */
  set enabled(t) {
    this._initialized || this.initialize(), this._enabled = t;
  }
  /**
   * Getter for the current post-processing settings.
   */
  get settings() {
    return { ...this._settings };
  }
  /**
   * Disposes of the resources held by the post-processing manager.
   * This method should be called when the post-processing manager is no longer needed.
   * It releases the memory occupied by the render target, depth texture, custom effects pass, gamma pass, and N8AO pass.
   */
  dispose() {
    var t, e, s, i;
    this.composer.dispose(), this._renderTarget.dispose(), (t = this._depthTexture) == null || t.dispose(), (e = this._customEffects) == null || e.dispose(), (s = this._gammaPass) == null || s.dispose(), (i = this._n8ao) == null || i.dispose();
  }
  /**
   * Sets the post-processing settings and updates the passes accordingly.
   * This method checks if the settings have changed before updating the passes.
   *
   * @param settings - The new post-processing settings.
   * @returns {void}
   */
  setPasses(t) {
    let e = !1;
    for (const s in t) {
      const i = s;
      if (this.settings[i] !== t[i]) {
        e = !0;
        break;
      }
    }
    if (e) {
      for (const s in t) {
        const i = s;
        this._settings[i] !== void 0 && (this._settings[i] = t[i]);
      }
      this.updatePasses();
    }
  }
  /**
   * Sets the size of the render target and all related passes.
   * This method should be called when the window size changes to ensure that the post-processing effects are rendered correctly.
   *
   * @param width - The new width of the render target.
   * @param height - The new height of the render target.
   * @returns {void}
   */
  setSize(t, e) {
    if (!(t === 0 || e === 0) && this._initialized) {
      const s = this._settings.custom;
      s && this.setPasses({ custom: !1 }), this.setPasses({ custom: !1 }), this.composer.setSize(t, e), this.basePass.setSize(t, e), this.n8ao.setSize(t, e), this.customEffects.setSize(t, e), this.gammaPass.setSize(t, e), s && this.setPasses({ custom: !0 });
    }
  }
  /**
   * Updates the post-processing effects.
   * This method checks if the post-processing effects are enabled before rendering.
   * If the effects are enabled, it calls the `composer.render()` method to apply the effects.
   */
  update() {
    this._enabled && this.composer.render();
  }
  /**
   * Updates the camera settings for the post-processing effects.
   * This method is called whenever the camera settings change.
   * It updates the camera settings for the N8AO pass, custom effects pass, and base pass.
   */
  updateCamera() {
    const t = this._world.camera.three;
    this._n8ao && (this._n8ao.camera = t), this._customEffects && (this._customEffects.renderCamera = t), this._basePass && (this._basePass.camera = t);
  }
  /**
   * Updates the projection of the camera for the post-processing effects.
   * This method iterates over all passes in the EffectComposer and updates the camera property of each pass.
   * After updating the camera, it calls the update method to apply the changes.
   *
   * @param camera - The new camera to use for the post-processing effects.
   * @returns {void}
   */
  updateProjection(t) {
    this.composer.passes.forEach((e) => {
      e.camera = t;
    }), this.update();
  }
  initialize() {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const t = this._world.scene.three, e = this._world.camera.three;
    if (!(t instanceof A.Scene))
      throw new Error("The given scene must have a THREE.Scene as core!");
    const s = this._world.camera;
    s.projection && s.projection.onChanged.add(() => {
      this.updateCamera();
    });
    const i = this._world.renderer;
    this.overrideClippingPlanes || (this._renderer.clippingPlanes = i.clippingPlanes), this._renderer.outputColorSpace = "srgb", this._renderer.toneMapping = A.NoToneMapping, this.newBasePass(t, e), this.newSaoPass(t, e), this.newGammaPass(), this.newCustomPass(t, e), this._initialized = !0, this.updatePasses();
  }
  updatePasses() {
    for (const t of this.composer.passes)
      this.composer.removePass(t);
    this._basePass && this.composer.addPass(this.basePass), this._settings.gamma && this.composer.addPass(this.gammaPass), this._settings.ao && this.composer.addPass(this.n8ao), this._settings.custom && this.composer.addPass(this.customEffects);
  }
  newCustomPass(t, e) {
    this._customEffects = new bp(
      new A.Vector2(window.innerWidth, window.innerHeight),
      this._components,
      this._world,
      t,
      e
    );
  }
  newGammaPass() {
    this._gammaPass = new hc(xp);
  }
  newSaoPass(t, e) {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const { width: s, height: i } = this._world.renderer.getSize();
    this._n8ao = new Np(t, e, s, i);
    const { configuration: n } = this._n8ao;
    n.aoSamples = 16, n.denoiseSamples = 1, n.denoiseRadius = 13, n.aoRadius = 1, n.distanceFalloff = 4, n.aoRadius = 1, n.intensity = 4, n.halfRes = !0, n.color = new A.Color().setHex(13421772, "srgb-linear");
  }
  newBasePass(t, e) {
    this._basePass = new yp(t, e);
  }
}
class qr extends Kd {
  constructor(e, s, i) {
    super(e, s, i);
    w(this, "_postproduction");
    this.onResize.add((n) => this.resizePostproduction(n)), this.onWorldChanged.add(() => {
      this.currentWorld && (this._postproduction && this._postproduction.dispose(), this._postproduction = new Dp(
        e,
        this.three,
        this.currentWorld
      ), this.setPostproductionSize());
    });
  }
  /**
   * Getter for the postproduction instance.
   * Throws an error if the postproduction instance is not yet initialized.
   *
   * @returns The initialized Postproduction instance.
   */
  get postproduction() {
    if (!this._postproduction)
      throw new Error("Renderer not initialized yet with a world!");
    return this._postproduction;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger();
    const e = this.currentWorld.scene.three, s = this.currentWorld.camera.three;
    this.postproduction.enabled ? this.postproduction.composer.render() : this.three.render(e, s), e instanceof A.Scene && this.three2D.render(e, s), this.onAfterUpdate.trigger();
  }
  /** {@link OBC.Disposable.dispose}. */
  dispose() {
    super.dispose(), this.postproduction.dispose();
  }
  resizePostproduction(e) {
    this.postproduction && this.setPostproductionSize(e);
  }
  setPostproductionSize(e) {
    if (!this.container)
      return;
    const s = e ? e.x : this.container.clientWidth, i = e ? e.y : this.container.clientHeight;
    this.postproduction.setSize(s, i);
  }
}
class _p {
  constructor(t, e, s, i, n) {
    /**
     * The THREE.js mesh representing the fills.
     */
    w(this, "mesh", new A.Mesh(new A.BufferGeometry()));
    /**
     * The components instance associated with the clipping fills.
     */
    w(this, "components");
    /**
     * The world in which the clipping plane and fills exist.
     */
    w(this, "world");
    /**
     * The name of the style associated with this clipping fills.
     */
    w(this, "styleName");
    w(this, "_precission", 1e4);
    w(this, "_tempVector", new A.Vector3());
    w(this, "_plane");
    w(this, "_geometry");
    w(this, "_outlinedMesh");
    // Used to work in the 2D coordinate system of the plane
    w(this, "_plane2DCoordinateSystem", new A.Matrix4());
    // Used if the plane is orthogonal to the cartesian planes
    w(this, "_planeAxis");
    this.components = t, this.world = e, this.mesh.material = n, this.mesh.frustumCulled = !1, this.mesh.userData.indexFragmentMap = /* @__PURE__ */ new Map(), this._plane = s;
    const { x: r, y: o, z: a } = s.normal;
    Math.abs(r) === 1 ? this._planeAxis = "x" : Math.abs(o) === 1 ? this._planeAxis = "y" : Math.abs(a) === 1 && (this._planeAxis = "z"), this._geometry = i, this.mesh.geometry.attributes.position = i.attributes.position;
    const c = s.normal.clone().multiplyScalar(0.01);
    this._outlinedMesh = new A.Mesh(this.mesh.geometry), this.mesh.position.copy(c), this._outlinedMesh.position.copy(c), this.visible = !0;
  }
  /**
   * Gets the visibility of the clipping fills mesh.
   * @returns {boolean} Returns true if the mesh is visible, false otherwise.
   */
  get visible() {
    return this.mesh.parent !== null;
  }
  /**
   * Sets the visibility of the clipping fills mesh.
   * @param {boolean} value - The new visibility state. If true, the mesh will be added to the scene and the style's meshes set. If false, the mesh will be removed from the scene and the style's meshes set.
   */
  set visible(t) {
    const e = this.getStyleAndScene();
    if (t) {
      if (this.world.scene.three.add(this.mesh), e) {
        const { style: i, outlineScene: n } = e;
        this._outlinedMesh.material = i.material, i.meshes.add(this._outlinedMesh), n.add(this._outlinedMesh);
      }
    } else if (this.mesh.removeFromParent(), e) {
      const { style: s } = e;
      s.meshes.delete(this._outlinedMesh), this._outlinedMesh.removeFromParent();
    }
  }
  /**
   * Sets the geometry of the clipping fills mesh.
   * @param {THREE.BufferGeometry} geometry - The new geometry for the mesh. The position attribute of the geometry will be assigned to the mesh's geometry.
   */
  set geometry(t) {
    this._geometry = t, this.mesh.geometry.attributes.position = t.attributes.position;
  }
  /**
   * Disposes of the clipping fills mesh and its associated resources.
   * This method should be called when the clipping fills are no longer needed to free up memory.
   */
  dispose() {
    const t = this.getStyleAndScene();
    if (t) {
      const { style: e } = t;
      e.meshes.delete(this._outlinedMesh), this._outlinedMesh.removeFromParent();
    }
    this.mesh.material = [], this._outlinedMesh.material = [], this.mesh.userData.indexFragmentMap.clear(), this.mesh.userData = {}, this.mesh.geometry.dispose(), this.mesh.removeFromParent(), this.mesh.geometry = null, this._outlinedMesh.geometry = null, this.mesh = null, this._plane = null, this._geometry = null, this.components = null;
  }
  /**
   * Updates the clipping fills mesh with new indices.
   *
   * @param trianglesIndices - An array of indices representing triangles in the geometry.
   * @param indexFragMap - A map that allows to trace back the original fragment and id from each triangle of the fill mesh.
   *
   */
  update(t, e) {
    const s = this._geometry.attributes.position.array;
    if (!s)
      return;
    this.updatePlane2DCoordinateSystem();
    const { userData: i } = this.mesh, n = i.indexFragmentMap;
    n.clear();
    let r = 0;
    const o = [];
    let a = 0;
    const c = this.components.get(fe);
    for (const [h, f] of e)
      for (const u in f) {
        const d = c.list.get(u);
        d && (d.mesh.userData.fills || (d.mesh.userData.fills = /* @__PURE__ */ new Set()), d.mesh.userData.fills.add(this.mesh));
      }
    for (let h = 0; h < t.length; h++) {
      const f = t[h], u = [];
      for (let E = a; E < f; E += 2)
        u.push(E * 3);
      const d = this.computeFill(u, s), p = e.get(f);
      let m = 0;
      for (const E of d)
        o.push(E), p && m % 3 === 0 && n.set(r++, p), m++;
      a = f;
    }
    this.mesh.geometry.setIndex(o);
  }
  computeFill(t, e) {
    const s = /* @__PURE__ */ new Map(), i = {}, n = /* @__PURE__ */ new Map();
    let r = 0;
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), h = this._precission;
    for (let u = 0; u < t.length; u++) {
      const d = t[u];
      let p = 0, m = 0, E = 0, I = 0;
      const g = e[d], T = e[d + 1], C = e[d + 2], F = e[d + 3], O = e[d + 4], P = e[d + 5];
      if (this._tempVector.set(g, T, C), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), p = Math.trunc(this._tempVector.x * h) / h, m = Math.trunc(this._tempVector.y * h) / h, this._tempVector.set(F, O, P), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), E = Math.trunc(this._tempVector.x * h) / h, I = Math.trunc(this._tempVector.y * h) / h, p === E && m === I)
        continue;
      const M = `${p}|${m}`, L = `${E}|${I}`;
      s.has(M) || s.set(M, d / 3), s.has(L) || s.set(L, d / 3 + 1);
      const b = s.get(M), B = s.get(L);
      i[b] = [p, m], i[B] = [E, I];
      const v = a.has(b), D = o.has(b), R = a.has(B), _ = o.has(B);
      if (!v && !D && !R && !_)
        a.set(b, r), o.set(B, r), c.add(r), n.set(r, [b, B]), r++;
      else if (v && _) {
        const U = a.get(b), Z = o.get(B);
        if (U !== Z) {
          const J = n.get(Z), z = n.get(U);
          if (!J || !z)
            continue;
          n.delete(U), c.delete(U), o.set(z[z.length - 1], Z), o.delete(J[J.length - 1]);
          for (const k of z)
            J.push(k);
        } else
          c.delete(Z);
        a.delete(b), o.delete(B);
      } else if (D && R) {
        const U = a.get(B), Z = o.get(b);
        if (U !== Z) {
          const J = n.get(Z), z = n.get(U);
          if (!J || !z)
            continue;
          n.delete(U), c.delete(U), o.set(z[z.length - 1], Z), o.delete(J[J.length - 1]);
          for (const k of z)
            J.push(k);
        } else
          c.delete(Z);
        a.delete(B), o.delete(b);
      } else if (v && R) {
        const U = a.get(B), Z = a.get(b), H = n.get(Z), J = n.get(U);
        if (!H || !J)
          continue;
        n.delete(U), c.delete(U), a.delete(H[0]), a.delete(J[0]), o.delete(J[J.length - 1]), a.set(J[J.length - 1], Z), J.reverse(), H.splice(0, 0, ...J);
      } else if (D && _) {
        const U = o.get(B), Z = o.get(b), H = n.get(Z), J = n.get(U);
        if (!H || !J)
          continue;
        n.delete(U), c.delete(U), o.delete(H[H.length - 1]), o.delete(J[J.length - 1]), a.delete(J[0]), o.set(J[0], Z), J.reverse(), H.push(...J);
      } else if (v) {
        const U = a.get(b), Z = n.get(U);
        if (!Z)
          continue;
        Z.unshift(B), a.delete(b), a.set(B, U);
      } else if (D) {
        const U = o.get(b), Z = n.get(U);
        if (!Z)
          continue;
        Z.push(B), o.delete(b), o.set(B, U);
      } else if (R) {
        const U = a.get(B), Z = n.get(U);
        if (!Z)
          continue;
        Z.unshift(b), a.delete(B), a.set(b, U);
      } else if (_) {
        const U = o.get(B), Z = n.get(U);
        if (!Z)
          continue;
        Z.push(b), o.delete(B), o.set(b, U);
      }
    }
    const f = [];
    for (const [u, d] of n) {
      if (c.has(u))
        continue;
      const p = [], m = /* @__PURE__ */ new Map();
      let E = 0;
      for (const g of d) {
        const T = i[g];
        p.push(T[0], T[1]), m.set(E++, g);
      }
      const I = pp(p);
      for (const g of I) {
        const T = m.get(g);
        if (T === void 0)
          throw new Error("Map error!");
        f.push(T);
      }
    }
    return f;
  }
  updatePlane2DCoordinateSystem() {
    this._plane2DCoordinateSystem = new A.Matrix4();
    const t = new A.Vector3(1, 0, 0), e = new A.Vector3(0, 1, 0), s = this._plane.normal, i = new A.Vector3();
    this._plane.coplanarPoint(i), this._planeAxis === "x" ? t.crossVectors(e, s) : this._planeAxis === "y" ? e.crossVectors(s, t) : this._planeAxis === "z" || (t.crossVectors(e, s).normalize(), e.crossVectors(s, t)), this._plane2DCoordinateSystem.fromArray([
      t.x,
      t.y,
      t.z,
      0,
      e.x,
      e.y,
      e.z,
      0,
      s.x,
      s.y,
      s.z,
      0,
      i.x,
      i.y,
      i.z,
      1
    ]), this._plane2DCoordinateSystem.invert();
  }
  getStyleAndScene() {
    if (!this.world.renderer)
      return null;
    const t = this.world.renderer instanceof qr;
    if (this.styleName && t) {
      const e = this.world.renderer, i = e.postproduction.customEffects.outlinedMeshes[this.styleName], n = e.postproduction.customEffects.outlineScene;
      return { style: i, outlineScene: n };
    }
    return null;
  }
}
class Up {
  constructor(t, e, s) {
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** {@link OBC.Updateable.onAfterUpdate} */
    w(this, "onAfterUpdate", new Y());
    /** {@link OBC.Updateable.onBeforeUpdate} */
    w(this, "onBeforeUpdate", new Y());
    /** Indicates whether the component is enabled. */
    w(this, "enabled", !0);
    /** Indicates whether the fill needs to be updated. */
    w(this, "fillNeedsUpdate", !1);
    /** Reference to the components manager. */
    w(this, "components");
    /** Reference to the world. */
    w(this, "world");
    w(this, "_edges", {});
    w(this, "_visible", !0);
    w(this, "_inverseMatrix", new A.Matrix4());
    w(this, "_localPlane", new A.Plane());
    w(this, "_tempLine", new A.Line3());
    w(this, "_tempVector", new A.Vector3());
    w(this, "_plane");
    this.components = t, this.world = e, this._plane = s;
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this._visible;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(t) {
    this._visible = t;
    for (const e in this._edges) {
      const s = this._edges[e];
      t ? this.world.scene.three.add(s.mesh) : s.mesh.removeFromParent(), s.fill && (s.fill.visible = t);
    }
  }
  /**
   * Getter that returns an array of THREE.Mesh instances representing the fills of the edges.
   *
   * @returns An array of THREE.Mesh instances representing the fills of the edges.
   */
  get fillMeshes() {
    const t = [];
    for (const e in this._edges) {
      const s = this._edges[e];
      s.fill && t.push(s.fill.mesh);
    }
    return t;
  }
  /** {@link OBC.Updateable.update} */
  update() {
    const e = this.components.get(_s).styles.list;
    this.updateDeletedEdges(e);
    for (const s in e)
      this.drawEdges(s);
    this.fillNeedsUpdate = !1;
  }
  // TODO: Remove?
  get() {
    return this._edges;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    const t = Object.keys(this._edges);
    for (const e of t)
      this.disposeEdge(e);
    this.onDisposed.trigger(), this.onDisposed.reset();
  }
  newEdgesMesh(t) {
    const i = this.components.get(_s).styles.list[t].lineMaterial, n = new A.BufferGeometry(), r = new Float32Array(3e5), o = new A.BufferAttribute(r, 3, !1);
    o.setUsage(A.DynamicDrawUsage), n.setAttribute("position", o);
    const a = new A.LineSegments(n, i);
    return a.frustumCulled = !1, a;
  }
  newFillMesh(t, e) {
    const n = this.components.get(_s).styles.list[t], r = n.fillMaterial;
    if (r) {
      const o = new _p(
        this.components,
        this.world,
        this._plane,
        e,
        r
      );
      return this.newFillOutline(t, o, n), o;
    }
  }
  newFillOutline(t, e, s) {
    if (!s.outlineMaterial || !this.world.renderer)
      return;
    const i = this.world.renderer;
    if (i instanceof qr) {
      const r = i.postproduction.customEffects.outlinedMeshes;
      r[t] || (r[t] = {
        meshes: /* @__PURE__ */ new Set(),
        material: s.outlineMaterial
      }), e.styleName = t;
    }
  }
  // Source: https://gkjohnson.github.io/three-mesh-bvh/example/bundle/clippedEdges.html
  drawEdges(t) {
    const s = this.components.get(_s).styles.list[t];
    this._edges[t] || this.initializeStyle(t);
    const i = this._edges[t];
    let n = 0;
    const r = i.mesh.geometry.attributes.position;
    r.array.fill(0);
    const o = [];
    let a = 0;
    const c = /* @__PURE__ */ new Map();
    for (const u of s.meshes)
      if (u.geometry) {
        if (!u.geometry.boundsTree)
          throw new Error("Bounds tree not found for clipping edges subset.");
        if (u instanceof A.InstancedMesh) {
          if (u.count === 0)
            continue;
          const d = u;
          for (let p = 0; p < d.count; p++) {
            const m = d instanceof Bc, E = d, I = s.fragments[E.fragment.id];
            if (m && I) {
              const C = E.fragment.getItemID(p);
              if (C === null || !I.has(C))
                continue;
            }
            const g = new A.Mesh(u.geometry);
            g.matrix.copy(u.matrix);
            const T = new A.Matrix4();
            if (d.getMatrixAt(p, T), g.applyMatrix4(T), g.applyMatrix4(u.matrixWorld), g.updateMatrix(), g.updateMatrixWorld(), this._inverseMatrix.copy(g.matrixWorld).invert(), this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix), n = this.shapecast(g, r, n), n !== a) {
              if (m && I) {
                const C = E.fragment.getItemID(p);
                C !== null && c.set(n, {
                  [E.fragment.id]: /* @__PURE__ */ new Set([C])
                });
              }
              o.push(n), a = n;
            }
          }
        } else
          this._inverseMatrix.copy(u.matrixWorld).invert(), this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix), n = this.shapecast(u, r, n), n !== a && (o.push(n), a = n);
      }
    i.mesh.geometry.setDrawRange(0, n), i.mesh.position.copy(this._plane.normal).multiplyScalar(1e-4), r.needsUpdate = !0;
    const f = i.mesh.geometry.attributes.position;
    Number.isNaN(f.array[0]) || this.fillNeedsUpdate && i.fill && (i.fill.geometry = i.mesh.geometry, i.fill.update(o, c), i.fill.visible = this._visible);
  }
  initializeStyle(t) {
    const e = this.newEdgesMesh(t), s = e.geometry, i = this.newFillMesh(t, s);
    this._edges[t] = { mesh: e, name: t, fill: i };
  }
  shapecast(t, e, s) {
    return t.geometry.boundsTree.shapecast({
      intersectsBounds: (i) => this._localPlane.intersectsBox(i),
      // @ts-ignore
      intersectsTriangle: (i) => {
        let n = 0;
        if (this._tempLine.start.copy(i.a), this._tempLine.end.copy(i.b), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(s, r.x, r.y, r.z), n++, s++;
        }
        if (this._tempLine.start.copy(i.b), this._tempLine.end.copy(i.c), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(s, r.x, r.y, r.z), n++, s++;
        }
        if (this._tempLine.start.copy(i.c), this._tempLine.end.copy(i.a), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(s, r.x, r.y, r.z), n++, s++;
        }
        n !== 2 && (s -= n);
      }
    }), s;
  }
  updateDeletedEdges(t) {
    const e = Object.keys(this._edges);
    for (const s of e)
      t[s] === void 0 && (this.disposeEdge(s), this.disposeOutline(s));
  }
  disposeOutline(t) {
    if (!this.world.renderer)
      return;
    const e = this.world.renderer;
    if (e instanceof qr) {
      const s = e.postproduction.customEffects.outlinedMeshes;
      delete s[t];
    }
  }
  disposeEdge(t) {
    const e = this.components.get(Ot), s = this._edges[t];
    s.fill && s.fill.dispose(), e.destroy(s.mesh, !1), delete this._edges[t];
  }
}
class Sn extends Hn {
  constructor(e, s, i, n, r, o = 5, a = !0) {
    super(e, s, i, n, r, o, a);
    w(this, "edges");
    /**
     * The max rate in milliseconds at which edges can be regenerated.
     * To disable this behaviour set this to 0.
     */
    w(this, "edgesMaxUpdateRate", 50);
    w(this, "_visible", !0);
    w(this, "_edgesVisible", !0);
    /**
     * Updates the fill of the edges.
     * This method sets the `fillNeedsUpdate` flag to true, triggers the `update` method of the `edges`,
     * and sets the visibility of the `edges` to the current value of `_visible`.
     *
     * @returns {void}
     */
    w(this, "updateFill", () => {
      this.edges.fillNeedsUpdate = !0, this.edges.update();
    });
    this.edges = new Up(e, s, this.three), this.toggleControls(!0), this.edges.visible = !0, this.onDraggingEnded.add(() => {
      this.updateFill(), this.edges.visible = !0;
    }), this.onDraggingStarted.add(() => this.edges.visible = !1);
  }
  /**
   * Getter for the visibility state of the plane.
   * @returns {boolean} The current visibility state.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Setter for the visibility state of the plane.
   * Also toggles the visibility of the controls.
   * @param {boolean} state - The new visibility state.
   */
  set visible(e) {
    super.visible = e, this.toggleControls(e);
  }
  /**
   * Setter for the enabled state of the plane.
   * Also sets the enabled state in the renderer.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(e) {
    this._enabled = e, this.world.renderer && this.world.renderer.setPlane(e, this.three);
  }
  /**
   * Getter for the enabled state of the plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return super.enabled;
  }
  /**
   * Disposes of the EdgesPlane and its associated ClippingEdges.
   * This method should be called when the EdgesPlane is no longer needed to free up resources.
   * After calling this method, the EdgesPlane and its ClippingEdges should not be used anymore.
   */
  dispose() {
    super.dispose(), this.edges.dispose();
  }
}
class Bp {
  constructor() {
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * A boolean indicating whether the styles are enabled.
     * Default value is `true`.
     */
    w(this, "enabled", !0);
    /**
     * A dictionary of {@link ClipStyle} objects, where the keys are the names of the styles.
     * Default value is an empty object.
     */
    w(this, "list", {});
    w(this, "_defaultLineMaterial", new Ga({
      color: 0,
      linewidth: 1e-3
    }));
    /** {@link OBC.Updateable.onAfterUpdate} */
    w(this, "onAfterUpdate", new Y());
    /** {@link OBC.Updateable.onBeforeUpdate} */
    w(this, "onBeforeUpdate", new Y());
  }
  /** {@link OBC.Updateable.update} */
  update(t) {
    this.onBeforeUpdate.trigger(this.list), this.onAfterUpdate.trigger(this.list);
  }
  // Creates a new style that applies to all clipping edges for generic models
  /**
   * Creates a new style that applies to all clipping edges for generic models.
   *
   * @param name - The name of the style.
   * @param meshes - A set of meshes to apply the style to.
   * @param world - The world where the meshes are located.
   * @param lineMaterial - The material for the lines of the style. If not provided, the default material is used.
   * @param fillMaterial - The material for the fill of the style.
   * @param outlineMaterial - The material for the outline of the style.
   *
   * @returns The newly created style.
   *
   * @throws Will throw an error if the given world doesn't have a renderer.
   */
  create(t, e, s, i, n, r) {
    if (!s.renderer)
      throw new Error("The given world doesn't have a renderer!");
    i || (i = this._defaultLineMaterial);
    for (const c of e)
      c.geometry.boundsTree || c.geometry.computeBoundsTree();
    const o = s.renderer;
    i.clippingPlanes = o.clippingPlanes;
    const a = {
      name: t,
      lineMaterial: i,
      meshes: e,
      fillMaterial: n,
      outlineMaterial: r,
      fragments: {}
    };
    return this.list[t] = a, a;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    const t = Object.keys(this.list);
    for (const e of t)
      this.deleteStyle(e);
    this.list = {}, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Deletes a style from the list and optionally disposes of its materials.
   *
   * @param id - The id of the style to delete.
   * @param disposeMaterials - A boolean indicating whether to dispose of the materials associated with the style.
   *                           Default value is `true`.
   *
   * @throws Will throw an error if the style with the given id doesn't exist in the list.
   */
  deleteStyle(t, e = !0) {
    var i, n;
    const s = this.list[t];
    s && (s.meshes.clear(), e && (s.lineMaterial.dispose(), (i = s.fillMaterial) == null || i.dispose(), (n = s.outlineMaterial) == null || n.dispose())), delete this.list[t];
  }
}
const wn = class wn extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /**
     * The styling properties for the edges.
     */
    w(this, "styles");
    /**
     * A flag indicating whether the fills need to be updated.
     */
    w(this, "fillsNeedUpdate", !1);
    w(this, "_visible", !0);
    this.components.list.set(wn.uuid, this), this.styles = new Bp();
  }
  /**
   * Gets the visibility state of the edges.
   * @returns {boolean} The current visibility state.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Sets the visibility state of the edges.
   * Updates the visibility of the associated {@link EdgesPlane} instances.
   * @param {boolean} active - The new visibility state.
   */
  set visible(e) {
    this._visible = e;
    const s = this.components.get(Bs);
    for (const i of s.list)
      i instanceof Sn && (i.edges.visible = e);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.styles.dispose(), this.onDisposed.trigger();
  }
  /**
   * Updates all the lines of the component.
   *
   * @param {boolean} [updateFills=false] - If true, the fills will be updated regardless of the `fillsNeedUpdate` flag.
   * @returns {Promise<void>} - A promise that resolves when the update is complete.
   *
   * @remarks
   * This method iterates through all the {@link EdgesPlane} instances associated with the {@link Clipper} component.
   */
  async update(e = !1) {
    if (!this.enabled)
      return;
    const s = this.components.get(Bs);
    for (const i of s.list)
      i instanceof Sn && (e || this.fillsNeedUpdate ? i.updateFill() : i.update());
    this.fillsNeedUpdate = !1;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(wn, "uuid", "24dfc306-a3c4-410f-8071-babc4afa5e4d");
let _s = wn;
const Vp = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, zp = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, jt = class jt extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /**
     * Controls how far away the shadow is computed
     */
    w(this, "cameraHeight", 10);
    /**
     * The darkness of the shadow.
     * A higher value makes the shadow darker.
     */
    w(this, "darkness", 1.2);
    /**
     * The opacity of the shadow.
     * A higher value makes the shadow more opaque.
     */
    w(this, "opacity", 1);
    /**
     * The resolution of the shadow texture.
     * A higher value results in a higher-quality shadow.
     */
    w(this, "resolution", 512);
    /**
     * The amount of blur applied to the shadow.
     * A higher value makes the shadow more blurred.
     */
    w(this, "amount", 3.5);
    /**
     * The color of the shadow plane.
     * This color is used when the ground color plane is enabled.
     */
    w(this, "planeColor", 16777215);
    /**
     * The offset of the shadow from the ground.
     * A positive value moves the shadow upwards.
     */
    w(this, "shadowOffset", 0);
    /**
     * The extra scale factor applied to the shadow size.
     * A higher value makes the shadow larger.
     */
    w(this, "shadowExtraScaleFactor", 1.5);
    /**
     * A collection of shadows, where each shadow is identified by a unique ID.
     */
    w(this, "list", {});
    w(this, "tempMaterial", new A.MeshBasicMaterial({ visible: !1 }));
    w(this, "depthMaterial", new A.MeshDepthMaterial());
    this.components.add(jt.uuid, this), this.initializeDepthMaterial();
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    for (const e in this.list)
      this.deleteShadow(e);
    this.tempMaterial.dispose(), this.depthMaterial.dispose(), this.components = null, this.onDisposed.trigger(jt.uuid), this.onDisposed.reset();
  }
  /**
   * Creates a blurred dropped shadow of the given mesh.
   *
   * @param model - the mesh whose shadow to generate.
   * @param id - the name of this shadow.
   */
  create(e, s, i) {
    if (this.list[s])
      throw new Error(`There is already a shadow with ID ${s}`);
    const { size: n, center: r, min: o } = this.getSizeCenterMin(e), a = this.createShadow(s, n, i);
    return this.initializeShadow(a, r, o), this.createPlanes(a, n), this.bakeShadow(e, a), a.root;
  }
  /**
   * Deletes the specified shadow (if it exists).
   *
   * @param id - the name of this shadow.
   */
  deleteShadow(e) {
    const s = this.components.get(Ot), i = this.list[e];
    if (delete this.list[e], !i)
      throw new Error(`No shadow with ID ${e} was found.`);
    s.destroy(i.root), s.destroy(i.blurPlane), i.rt.dispose(), i.rtBlur.dispose();
  }
  createPlanes(e, s) {
    const i = new A.PlaneGeometry(s.x, s.z).rotateX(
      Math.PI / 2
    );
    this.createBasePlane(e, i), jt.createBlurPlane(e, i);
  }
  initializeShadow(e, s, i) {
    this.initializeRoot(e, s, i), jt.initializeRenderTargets(e), jt.initializeCamera(e);
  }
  bakeShadow(e, s) {
    const i = s.world.scene.three;
    if (!(i instanceof A.Scene))
      throw new Error("The core of the scene of the world must be a scene!");
    if (!s.world.renderer)
      throw new Error("The given world must have a renderer!");
    const n = s.world.renderer.three, r = e.map((h) => !!h.parent);
    for (let h = 0; h < e.length; h++)
      r[h] || i.add(e[h]);
    const o = i.children.filter(
      (h) => !e.includes(h) && h !== s.root
    );
    for (let h = o.length - 1; h >= 0; h--)
      i.remove(o[h]);
    const a = i.background;
    i.background = null, i.overrideMaterial = this.depthMaterial;
    const c = [];
    for (const h of e)
      c.push(h.visible), h.visible = !0;
    n.setRenderTarget(s.rt), n.render(i, s.camera), i.overrideMaterial = null, this.blurShadow(s, this.amount), this.blurShadow(s, this.amount * 0.4), n.setRenderTarget(null), i.background = a;
    for (let h = 0; h < e.length; h++)
      e[h].visible = c[h];
    for (let h = o.length - 1; h >= 0; h--)
      i.add(o[h]);
    for (let h = 0; h < e.length; h++)
      r[h] || i.remove(e[h]);
  }
  static initializeCamera(e) {
    e.camera.rotation.x = Math.PI / 2, e.root.add(e.camera);
  }
  static initializeRenderTargets(e) {
    e.rt.texture.generateMipmaps = !1, e.rtBlur.texture.generateMipmaps = !1;
  }
  initializeRoot(e, s, i) {
    const n = e.world.scene.three;
    e.root.position.set(s.x, i.y - this.shadowOffset, s.z), n.add(e.root);
  }
  // Plane simulating the "ground". This is not needed for BIM models generally
  // private createGroundColorPlane(_shadow: Shadow, planeGeometry: BufferGeometry) {
  //   const fillPlaneMaterial = new MeshBasicMaterial({
  //     color: this.planeColor,
  //     opacity: this.opacity,
  //     transparent: true,
  //     depthWrite: false,
  //     clippingPlanes: this.context.getClippingPlanes()
  //   });
  //   const fillPlane = new Mesh(planeGeometry, fillPlaneMaterial);
  //   fillPlane.rotateX(Math.PI);
  //   fillPlane.renderOrder = -1;
  //   shadow.root.add(fillPlane);
  // }
  createBasePlane(e, s) {
    const i = this.createPlaneMaterial(e), n = new A.Mesh(s, i);
    n.renderOrder = 2, e.root.add(n), n.scale.y = -1;
  }
  static createBlurPlane(e, s) {
    e.blurPlane.geometry = s, e.blurPlane.visible = !1, e.root.add(e.blurPlane);
  }
  createPlaneMaterial(e) {
    if (!e.world.renderer)
      throw new Error("The given world must have a renderer!");
    const s = e.world.renderer.three;
    return new A.MeshBasicMaterial({
      map: e.rt.texture,
      opacity: this.opacity,
      transparent: !0,
      depthWrite: !1,
      clippingPlanes: s.clippingPlanes
    });
  }
  // like MeshDepthMaterial, but goes from black to transparent
  initializeDepthMaterial() {
    this.depthMaterial.depthTest = !1, this.depthMaterial.depthWrite = !1;
    const e = "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", s = "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );";
    this.depthMaterial.userData.darkness = { value: this.darkness }, this.depthMaterial.onBeforeCompile = (i) => {
      i.uniforms.darkness = this.depthMaterial.userData.darkness, i.fragmentShader = /* glsl */
      `
						uniform float darkness;
						${i.fragmentShader.replace(e, s)}
					`;
    };
  }
  createShadow(e, s, i) {
    return this.list[e] = {
      root: new A.Group(),
      world: i,
      rt: new A.WebGLRenderTarget(this.resolution, this.resolution),
      rtBlur: new A.WebGLRenderTarget(this.resolution, this.resolution),
      blurPlane: new A.Mesh(),
      camera: this.createCamera(s)
    }, this.list[e];
  }
  createCamera(e) {
    return new A.OrthographicCamera(
      -e.x / 2,
      e.x / 2,
      e.z / 2,
      -e.z / 2,
      0,
      this.cameraHeight
    );
  }
  getSizeCenterMin(e) {
    const s = e[0].parent, i = new A.Group();
    i.children = e;
    const n = new A.Box3().setFromObject(i);
    s == null || s.add(...e);
    const r = new A.Vector3();
    n.getSize(r), r.x *= this.shadowExtraScaleFactor, r.z *= this.shadowExtraScaleFactor;
    const o = new A.Vector3();
    n.getCenter(o);
    const a = n.min;
    return { size: r, center: o, min: a };
  }
  blurShadow(e, s) {
    if (!e.world.renderer)
      throw new Error("The given world must have a renderer!");
    const i = new A.ShaderMaterial(
      Vp
    );
    i.depthTest = !1;
    const n = new A.ShaderMaterial(zp);
    n.depthTest = !1, e.blurPlane.visible = !0, e.blurPlane.material = i, e.blurPlane.material.uniforms.tDiffuse.value = e.rt.texture, i.uniforms.h.value = s * 1 / 256;
    const r = e.world.renderer.three;
    r.setRenderTarget(e.rtBlur), r.render(e.blurPlane, e.camera), e.blurPlane.material = n, e.blurPlane.material.uniforms.tDiffuse.value = e.rtBlur.texture, n.uniforms.v.value = s * 1 / 256, r.setRenderTarget(e.rt), r.render(e.blurPlane, e.camera), e.blurPlane.visible = !1;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(jt, "uuid", "f833a09a-a3ab-4c58-b03e-da5298c7a1b6");
let va = jt;
const vn = class vn extends ue {
  constructor(e) {
    super(e);
    w(this, "enabled", !0);
    w(this, "inputs", ["OBC", "BUI"]);
    w(this, "_requestEventID", "thatOpenCompanyComponentRequested");
    w(this, "_createEventID", "thatOpenCompanyComponentCreated");
    e.add(vn.uuid, this);
  }
  async import(e) {
    return new Promise((s) => {
      const i = document.createElement("script"), n = `
        function main() {
          const { ${this.inputs} } = window.ThatOpenCompany;
        
          ${e}
        
          const onComponentRequested = () => {
            window.removeEventListener("${this._requestEventID}", onComponentRequested);
            const event = new CustomEvent("${this._createEventID}", { detail: main });
            window.dispatchEvent(event);
          };
          
          window.addEventListener("${this._requestEventID}", onComponentRequested);
        }
        
        main();
      `, r = (o) => {
        window.removeEventListener(this._createEventID, r);
        const a = o.detail, c = this.components.get(a);
        i.remove(), s(c);
      };
      i.addEventListener("load", () => {
        window.addEventListener(this._createEventID, r), window.dispatchEvent(new Event(this._requestEventID));
      }), i.src = URL.createObjectURL(new File([n], "temp.js")), document.head.appendChild(i);
    });
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(vn, "uuid", "74c0c370-1af8-4ca9-900a-4a4196c0f2f5");
let Oa = vn;
const kp = [
  "Station",
  "Radius",
  "Length",
  "InitialKP",
  "FinalKP",
  "KP",
  "Slope",
  "Height",
  "InitialKPV",
  "FinalKPV"
], On = class On extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /**
     * A reference to the 3D world in which the markers will be displayed.
     * This property should be set before using any methods of this component.
     */
    w(this, "world", null);
    // TODO: Replace with UUID for the marker key
    w(this, "_markerKey", 0);
    w(this, "_list", /* @__PURE__ */ new Map());
    w(this, "type", "horizontal");
    w(this, "divisionLength", 100);
    e.add(On.uuid, this);
  }
  /**
   * Adds a KP station marker to the world.
   *
   * @param world - The world to add the marker to.
   * @param text - The text to display on the marker.
   * @param mesh - The line representing the KP station.
   *
   * @returns {void}
   */
  addKPStation(e, s, i) {
    const n = this.components.get(Mt), r = document.createElement("div"), o = document.createElement("div");
    r.appendChild(o), o.innerHTML = s, o.style.color = n.color, o.style.borderBottom = "1px dotted white", o.style.width = "160px", o.style.textAlign = "left";
    const a = new Ke(e, r), c = new A.Vector3();
    c.x = i.geometry.attributes.position.getX(
      i.geometry.attributes.position.count - 1
    ), c.y = i.geometry.attributes.position.getY(
      i.geometry.attributes.position.count - 1
    ), c.z = i.geometry.attributes.position.getZ(
      i.geometry.attributes.position.count - 1
    );
    const h = new A.Vector3();
    h.x = i.geometry.attributes.position.getX(
      i.geometry.attributes.position.count - 2
    ), h.y = i.geometry.attributes.position.getY(
      i.geometry.attributes.position.count - 2
    ), h.z = i.geometry.attributes.position.getZ(
      i.geometry.attributes.position.count - 2
    );
    const f = new A.Vector3();
    f.x = (c.x + h.x) / 2, f.y = (c.y + h.y) / 2, f.z = (c.z + h.z) / 2, a.three.position.copy(f);
    const u = new A.Vector3();
    u.subVectors(c, h).normalize();
    const d = new A.Quaternion();
    d.setFromUnitVectors(new A.Vector3(0, 1, 0), u);
    const p = new A.Euler().setFromQuaternion(d).z, m = A.MathUtils.radToDeg(p);
    o.style.transform = `rotate(${-m - 90}deg) translate(-35%, -50%)`;
    const E = this._markerKey.toString();
    n.setupEvents(e, !0), n.getWorldMarkerList(e).set(E, {
      label: a,
      key: E,
      merged: !1,
      static: !1
    }), this._markerKey++, this.save(E, "KP");
  }
  /**
   * Adds a vertical marker to the 3D world based on the given parameters.
   *
   * @param world - The 3D world where the marker will be added.
   * @param text - The text to be displayed on the marker.
   * @param mesh - The mesh data related to the marker.
   * @param type - The type of the marker.
   * @param root - The root object for the marker.
   *
   * @returns The created and added marker.
   */
  addVerticalMarker(e, s, i, n, r) {
    const o = this.components.get(Mt), a = document.createElement("span");
    a.innerHTML = s, a.style.color = o.color;
    const c = new Ke(e, a, r);
    if (n === "Height") {
      const u = document.createElement("span");
      u.innerHTML = s, u.style.color = o.color;
      const { position: d } = i.geometry.attributes, m = (d.array.length / 3 - 1) * 3, E = d.array.slice(m, m + 3);
      c.three.position.set(E[0], E[1] + 10, E[2]);
    } else if (n === "InitialKPV") {
      const { position: u } = i.geometry.attributes, d = u.getX(0), p = u.getY(0), m = u.getZ(0);
      c.three.position.set(d - 20, p, m);
    } else if (n === "FinalKPV") {
      const { position: u } = i.geometry.attributes, d = u.getX(i.geometry.attributes.position.count - 1), p = u.getY(i.geometry.attributes.position.count - 1), m = u.getZ(i.geometry.attributes.position.count - 1);
      c.three.position.set(d + 20, p, m);
    } else if (n === "Slope") {
      a.style.color = "grey";
      const { position: u } = i.geometry.attributes, d = new A.Vector3();
      d.x = u.getX(0), d.y = u.getY(0), d.z = u.getZ(0);
      const p = new A.Vector3();
      p.x = u.getX(u.count - 1), p.y = u.getY(u.count - 1), p.z = u.getZ(u.count - 1);
      const m = new A.Vector3();
      m.addVectors(d, p).multiplyScalar(0.5), c.three.position.set(m.x, m.y - 10, m.z);
    }
    const h = this._markerKey.toString();
    return o.setupEvents(e, !0), o.getWorldMarkerList(e).set(h, {
      label: c,
      key: h,
      type: n,
      merged: !1,
      static: !1
    }), this._markerKey++, this.save(h, n), c;
  }
  /**
   * Adds a civil engineering marker to the world based on the given type.
   *
   * @param world - The world to add the marker to.
   * @param text - The text to display on the marker.
   * @param mesh - The mesh related to the marker.
   * @param type - The type of the marker.
   *
   * @returns The created marker.
   */
  addCivilMarker(e, s, i, n) {
    const r = this.components.get(Mt), o = document.createElement("span");
    o.innerHTML = s, o.style.color = r.color;
    const a = new Ke(e, o);
    if (n === "InitialKP") {
      const f = i.geometry.attributes.position.getX(0), u = i.geometry.attributes.position.getY(0), d = i.geometry.attributes.position.getZ(0);
      a.three.position.set(f + 2, u + 2, d);
    } else if (n === "FinalKP") {
      const f = i.geometry.attributes.position.getX(
        i.geometry.attributes.position.count - 1
      ), u = i.geometry.attributes.position.getY(
        i.geometry.attributes.position.count - 1
      ), d = i.geometry.attributes.position.getZ(
        i.geometry.attributes.position.count - 1
      );
      a.three.position.set(f + 2, u - 2, d);
    } else if (n === "Length") {
      const f = new A.Vector3();
      f.x = i.geometry.attributes.position.getX(0), f.y = i.geometry.attributes.position.getY(0), f.z = i.geometry.attributes.position.getZ(0);
      const u = new A.Vector3();
      u.x = i.geometry.attributes.position.getX(
        i.geometry.attributes.position.count - 1
      ), u.y = i.geometry.attributes.position.getY(
        i.geometry.attributes.position.count - 1
      ), u.z = i.geometry.attributes.position.getZ(
        i.geometry.attributes.position.count - 1
      );
      const d = f.distanceTo(u);
      a.three.element.innerText = d.toFixed(2);
      const p = u.clone().add(f).divideScalar(2);
      a.three.position.copy(p);
    }
    const c = this._markerKey.toString();
    return r.setupEvents(e, !0), r.getWorldMarkerList(e).set(c, {
      label: a,
      key: c,
      type: n,
      merged: !1,
      static: !1
    }), this._markerKey++, this.save(c, n), a;
  }
  /**
   * Shows the KP stations on the given mesh.
   *
   * @param mesh - The mesh to show the KP stations on.
   * @throws Will throw an error if a world is not set for this component.
   * @throws Will throw an error if the type is not set to "horizontal".
   */
  showKPStations(e) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    if (this.type === "horizontal") {
      const s = this.generateStartAndEndKP(e);
      for (const [, n] of s)
        this.addKPStation(this.world, n.value, n.normal);
      const i = this.generateConstantKP(e);
      for (const [, n] of i)
        this.addKPStation(this.world, n.value, n.normal);
    }
  }
  /**
   * Shows the length of a curve on the world.
   *
   * @param points - The points that make up the curve.
   * @param length - The length of the curve.
   * @throws Will throw an error if a world is not set for this component.
   */
  showCurveLength(e, s) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const i = this.components.get(Mt), n = e.length, r = `${s.toFixed(2)} m`, o = Math.round(n / 2), a = e[o], c = i.create(this.world, r, a, !0);
    c !== void 0 && this.save(c, "Radius");
  }
  /**
   * Shows the length of a line on the world.
   *
   * @param line - The line to show the length on.
   * @param length - The length of the line.
   * @throws Will throw an error if a world is not set for this component.
   */
  showLineLength(e, s) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const i = this.components.get(Mt), n = new A.Vector3();
    n.x = e.geometry.getAttribute("position").getX(0), n.y = e.geometry.getAttribute("position").getY(0), n.z = e.geometry.getAttribute("position").getZ(0);
    const r = new A.Vector3();
    r.x = e.geometry.getAttribute("position").getX(1), r.y = e.geometry.getAttribute("position").getY(1), r.z = e.geometry.getAttribute("position").getZ(1);
    const o = `${s.toFixed(2)} m`, a = new A.Vector3();
    a.addVectors(n, r).multiplyScalar(0.5);
    const c = i.create(this.world, o, a, !0);
    c !== void 0 && this.save(c, "Radius");
  }
  /**
   * Shows the radius of a curve on the world.
   *
   * @param line - The line to show the radius on.
   * @param radius - The radius of the curve.
   * @throws Will throw an error if a world is not set for this component.
   */
  showCurveRadius(e, s) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const i = this.components.get(Mt), n = new A.Vector3();
    n.x = e.geometry.getAttribute("position").getX(0), n.y = e.geometry.getAttribute("position").getY(0), n.z = e.geometry.getAttribute("position").getZ(0);
    const r = new A.Vector3();
    r.x = e.geometry.getAttribute("position").getX(1), r.y = e.geometry.getAttribute("position").getY(1), r.z = e.geometry.getAttribute("position").getZ(1);
    const o = `R = ${s.toFixed(2)} m`, a = new A.Vector3();
    a.addVectors(n, r).multiplyScalar(0.5);
    const c = i.create(this.world, o, a, !0);
    c !== void 0 && this.save(c, "Radius");
  }
  /**
   * Deletes civil engineering markers of the specified types from the world.
   *
   * @param types - The types of markers to delete. If not provided, all types will be deleted.
   * @returns {void}
   */
  deleteByType(e = kp) {
    const s = this.components.get(Mt);
    for (const i of e) {
      const n = this._list.get(i);
      if (n) {
        for (const r of n)
          s.delete(r);
        this._list.delete(i);
      }
    }
  }
  generateStartAndEndKP(e) {
    const { alignment: s } = e.curve, i = /* @__PURE__ */ new Map();
    for (const n of s.horizontal) {
      const r = n.getLength();
      if (i.size > 0) {
        const o = n.index - 1, c = i.get(o).distance + r, h = n.mesh.geometry.getAttribute("position"), f = h.count - 1, u = new A.Vector3();
        u.x = h.getX(f), u.y = h.getY(f), u.z = h.getZ(f);
        const d = this.createNormalLine(n.mesh);
        i.set(n.index, {
          value: this.getShortendKPValue(c),
          distance: c,
          point: u,
          normal: d
        });
      } else {
        const o = n.mesh.geometry.getAttribute("position"), a = o.count - 1, c = new A.Vector3();
        c.x = o.getX(a), c.y = o.getY(a), c.z = o.getZ(a);
        const h = this.createNormalLine(n.mesh);
        i.set(n.index, {
          value: this.getShortendKPValue(r),
          distance: r,
          point: c,
          normal: h
        });
      }
    }
    return i;
  }
  createNormalLine(e) {
    const s = e.geometry.attributes.position.count - 1, i = s - 1, n = new A.Vector3();
    n.x = e.geometry.attributes.position.getX(s), n.y = e.geometry.attributes.position.getY(s), n.z = e.geometry.attributes.position.getZ(s);
    const r = new A.Vector3();
    r.x = e.geometry.attributes.position.getX(i), r.y = e.geometry.attributes.position.getY(i), r.z = e.geometry.attributes.position.getZ(i);
    const a = new A.Vector3().subVectors(
      n,
      r
    ).clone().applyAxisAngle(new A.Vector3(0, 0, 1), Math.PI * 0.5).normalize(), c = new A.BufferGeometry().setFromPoints([
      a.clone().setLength(10).add(n),
      a.clone().setLength(-10).add(n)
    ]);
    return new A.Line(c);
  }
  generateConstantKP(e) {
    const { alignment: s } = e.curve, i = /* @__PURE__ */ new Map(), n = s.getLength("horizontal"), r = Math.floor(n / this.divisionLength);
    for (let o = 0; o < r; o++) {
      const a = o / r, c = s.getPointAt(a, "horizontal"), h = n * a, f = this.getNormal(s, c);
      i.set(o, {
        value: this.getShortendKPValue(h),
        distance: h,
        point: c,
        normal: f
      });
    }
    return i;
  }
  // TODO: Move Generation of Points to Previous Method Call
  getNormal(e, s) {
    const i = [], n = {
      start: new A.Vector3(),
      end: new A.Vector3()
    };
    for (let h = 0; h < e.horizontal.length; h++) {
      const u = e.horizontal[h].mesh.geometry.attributes.position, d = u.count;
      for (let p = 0; p < d; p++) {
        const m = u.getX(p), E = u.getY(p), I = u.getZ(p);
        i.push(new A.Vector3(m, E, I));
      }
    }
    for (let h = 0; h < i.length - 1; h++) {
      const f = i[h], u = i[h + 1], d = f.distanceTo(s), p = u.distanceTo(s), m = f.distanceTo(u);
      Math.abs(d + p - m) < 1e-5 && (n.start = f, n.end = u);
    }
    const o = new A.Vector3().subVectors(
      n.end,
      n.start
    ).clone().applyAxisAngle(new A.Vector3(0, 0, 1), Math.PI * 0.5).normalize(), a = new A.BufferGeometry().setFromPoints([
      o.clone().setLength(10).add(s),
      o.clone().setLength(-10).add(s)
    ]);
    return new A.Line(
      a,
      new A.LineBasicMaterial({ color: 16711680 })
    );
  }
  getShortendKPValue(e) {
    const s = e.toFixed(2), [i, n] = s.toString().split("."), r = n || "00";
    if (parseInt(i, 10) > 1e3 && parseInt(i, 10) < 1e4) {
      const [o, ...a] = i;
      return `${o}+${a.join("")}.${r}`;
    }
    if (parseInt(i, 10) > 1e4) {
      const [o, a, ...c] = i;
      return `${o}${a}+${c.join("")}.${r}`;
    }
    return `0+${i.padStart(3, "0")}.${r}`;
  }
  save(e, s) {
    this._list.has(s) || this._list.set(s, /* @__PURE__ */ new Set()), this._list.get(s).add(e);
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(On, "uuid", "0af12c32-81ee-4100-a030-e9ae546f6170");
let fs = On;
class dc extends ue {
  constructor(e) {
    super(e);
    /**
     * Event triggered when a curve is highlighted.
     * Provides the point of intersection and the corresponding curve mesh.
     */
    w(this, "onHighlight", new Y());
    /**
     * Event triggered when a marker (hover or select) is placed on a curve.
     * Provides the alignment, percentage, type of marker, and the corresponding curve.
     */
    w(this, "onMarkerChange", new Y());
    /**
     * Event triggered when a marker (hover or select) is hidden.
     * Provides the type of marker.
     */
    w(this, "onMarkerHidden", new Y());
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /**
     * Mouse markers for hover and select actions.
     * They are of type Mark and are optional.
     */
    w(this, "mouseMarkers");
    w(this, "_curves", []);
    w(this, "_previousAlignment", null);
    w(this, "_highlighter");
    w(this, "_world", null);
    w(this, "updateLinesResolution", (e) => {
      var s;
      (s = this._highlighter) == null || s.setResolution(e);
    });
    w(this, "onMouseMove", (e) => {
      var o, a, c;
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!this._world.renderer)
        return;
      const i = this._world.renderer.three.domElement.parentElement, n = this._world.camera.three, r = (o = this._highlighter) == null ? void 0 : o.castRay(e, n, i, this._curves);
      if (r) {
        const { object: h } = r;
        (a = this._highlighter) == null || a.hover(h), this.updateMarker(r, "hover");
        return;
      }
      this.mouseMarkers && (this.mouseMarkers.hover.visible = !1), (c = this._highlighter) == null || c.unHover(), this.onMarkerHidden.trigger({ type: "hover" });
    });
    w(this, "onClick", (e) => {
      var o, a;
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!this._world.renderer)
        return;
      const i = this._world.renderer.three.domElement.parentElement, n = this._world.camera.three, r = (o = this._highlighter) == null ? void 0 : o.castRay(e, n, i, this._curves);
      if (r) {
        const c = r, h = c.object;
        if ((a = this._highlighter) == null || a.select(h), this.updateMarker(c, "select"), this._world.camera.hasCameraControls() && (h.geometry.boundingBox || h.geometry.computeBoundingBox(), h.geometry.boundingBox)) {
          const f = this.getScaledBox(h.geometry.boundingBox, 2);
          this._world.camera.controls.fitToBox(f, !0);
        }
        this.onHighlight.trigger({ mesh: h, point: c.point }), this._previousAlignment !== h.curve.alignment && (this.components.get(fs).showKPStations(h), this._previousAlignment = h.curve.alignment);
      }
    });
    w(this, "onControlsUpdated", () => {
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!(this._world.camera.three instanceof A.OrthographicCamera) || !this._highlighter)
        return;
      const { zoom: e, left: s, right: i, top: n, bottom: r } = this._world.camera.three, o = s - i, a = n - r, h = Math.max(o, a) / e, f = 40, { caster: u } = this._highlighter;
      u.params.Line.threshold = h / f;
    });
  }
  /**
   * Getter for the highlighter instance.
   * Throws an error if the highlighter is not initialized.
   *
   * @returns {CurveHighlighter} The initialized highlighter instance.
   */
  get highlighter() {
    if (!this._highlighter)
      throw new Error(
        "Highlighter not initialized. You must set a world first!"
      );
    return this._highlighter;
  }
  /**
   * Getter for the world instance.
   *
   * @returns {OBC.World | null} The current world instance or null if not set.
   */
  get world() {
    return this._world;
  }
  /**
   * Setter for the world instance.
   * If the new world is the same as the current one, it does nothing.
   * If the current world is set, it removes the event listeners.
   * If the new world is not set, it does nothing.
   *
   * @param {OBC.World | null} world - The new world instance or null to unset.
   */
  set world(e) {
    var i, n, r;
    if (e === this._world || (this._world && this.setupEvents(!1), this._world = e, (i = this._highlighter) == null || i.dispose(), (n = this.mouseMarkers) == null || n.hover.dispose(), (r = this.mouseMarkers) == null || r.select.dispose(), !e))
      return;
    const s = e.scene.three;
    this._highlighter = new Rn(s, this.view), this.mouseMarkers = {
      select: this.newMouseMarker("#ffffff", e),
      hover: this.newMouseMarker("#575757", e)
    }, this.setupEvents(!0);
  }
  /**
   * Draws the civil curves from the provided model onto the scene.
   *
   * @param model - The FragmentsGroup containing the civil data to be drawn.
   * @param filter - An optional Iterable of alignments to filter the curves to be drawn.
   *
   * @throws Will throw an error if the provided model doesn't have civil data or if no world was given for this navigator.
   *
   * @returns {Promise<void>} - A promise that resolves when the curves have been drawn onto the scene.
   */
  async draw(e, s) {
    if (!e.civilData)
      throw new Error("The provided model doesn't have civil data!");
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    const { alignments: i } = e.civilData, n = s || i.values(), r = this._world.scene.three, o = new A.Box3();
    o.makeEmpty(), o.min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), o.max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (const c of n) {
      if (!c)
        throw new Error("Alignment not found!");
      for (const h of c[this.view])
        if (r.add(h.mesh), this._curves.push(h.mesh), !o.isEmpty())
          o.expandByObject(h.mesh);
        else {
          h.mesh.geometry.computeBoundingBox();
          const f = h.mesh.geometry.boundingBox;
          f instanceof A.Box3 && o.copy(f).applyMatrix4(h.mesh.matrixWorld);
        }
    }
    const a = this.getScaledBox(o, 1.2);
    this._world.camera.hasCameraControls() && await this._world.camera.controls.fitToBox(a, !1);
  }
  /** {@link OBC.Disposable.dispose} */
  async dispose() {
    var e;
    (e = this._highlighter) == null || e.dispose(), this.clear(), this.onHighlight.reset(), this._curves = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Clears the civil curves from the scene.
   * Removes all the curve meshes from the scene and clears the internal array of curve meshes.
   * Also unselects and unhovers the highlighter.
   */
  clear() {
    var e, s;
    (e = this._highlighter) == null || e.unSelect(), (s = this._highlighter) == null || s.unHover();
    for (const i of this._curves)
      i.removeFromParent();
    this._curves = [];
  }
  /**
   * Sets a marker on a specific curve at a given percentage.
   *
   * @param alignment - The alignment where the marker should be placed.
   * @param percentage - The percentage along the alignment where the marker should be placed.
   * @param type - The type of marker to be placed (hover or select).
   *
   * @throws Will throw an error if there are no curves to place the marker on.
   */
  setMarker(e, s, i) {
    if (!this._curves.length)
      return;
    const n = e.getCurveAt(s, this.view), r = e.getPointAt(s, this.view), { index: o } = n.curve.getSegmentAt(n.percentage);
    this.setMouseMarker(r, n.curve.mesh, o, i);
  }
  /**
   * Sets the definition segments and slope from the provided segments array.
   *
   * @param segmentsArray - An array of segments, where each segment is an array of numbers representing points.
   *
   * @returns An object containing the definition segments and slope.
   *
   * @throws Will throw an error if the segments array is empty or if the points in the segments array are not in the expected format.
   */
  setDefSegments(e) {
    const s = [], i = [], n = (r, o) => {
      const a = o[1] - r[1], c = o[0] - r[0];
      return a / c;
    };
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      let a, c, h, f;
      for (let p = 0; p < Object.keys(o).length / 3; p++)
        if (o[p * 3] !== void 0 && o[p * 3 + 1] !== void 0) {
          a = o[p * 3], c = o[p * 3 + 1];
          break;
        }
      for (let p = Object.keys(o).length / 3 - 1; p >= 0; p--)
        if (o[p * 3] !== void 0 && o[p * 3 + 1] !== void 0) {
          h = o[p * 3], f = o[p * 3 + 1];
          break;
        }
      const d = (n(
        // @ts-ignore
        [a, c],
        // @ts-ignore
        [h, f]
      ) * 100).toFixed(2);
      i.push({ slope: d });
    }
    for (const r of e)
      for (let o = 0; o < r.length - 3; o += 3) {
        const a = r[o], c = r[o + 1], h = r[o + 2], f = r[o + 3], u = r[o + 4], d = r[o + 5];
        s.push({
          start: new A.Vector3(a, c, h),
          end: new A.Vector3(f, u, d)
        });
      }
    return { defSegments: s, slope: i };
  }
  /**
   * Hides the marker of the specified type.
   *
   * @param type - The type of marker to hide. It can be either "hover" or "select".
   *
   * @throws Will throw an error if the mouse markers are not initialized.
   */
  hideMarker(e) {
    this.mouseMarkers && (this.mouseMarkers[e].visible = !1);
  }
  setupEvents(e) {
    var n, r;
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    if (this._world.isDisposing || !this._world.renderer)
      return;
    const i = this._world.renderer.three.domElement.parentElement;
    (n = this._world.renderer) == null || n.onResize.remove(this.updateLinesResolution), i.removeEventListener("pointermove", this.onMouseMove), i.removeEventListener("click", this.onClick), this._world.camera.hasCameraControls() && this._world.camera.controls.removeEventListener("update", this.onControlsUpdated), e && (i.addEventListener("pointermove", this.onMouseMove), i.addEventListener("click", this.onClick), (r = this._world.renderer) == null || r.onResize.add(this.updateLinesResolution), this._world.camera.hasCameraControls() && this._world.camera.controls.addEventListener("update", this.onControlsUpdated));
  }
  newMouseMarker(e, s) {
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    const i = s.scene.three, n = document.createElement("div"), r = document.createElement("div");
    n.appendChild(r), r.style.backgroundColor = e, r.style.width = "3rem", r.style.height = "3px";
    const o = new Ke(this._world, n, i);
    return o.visible = !1, o;
  }
  setMouseMarker(e, s, i, n) {
    if (i === void 0 || !this.mouseMarkers)
      return;
    this.mouseMarkers[n].visible = !0;
    const r = this.mouseMarkers[n].three;
    r.position.copy(e);
    const o = s, { startPoint: a, endPoint: c } = o.curve.getSegment(i), h = Math.atan2(
      c.y - a.y,
      c.x - a.x
    ), f = r.element.children[0], u = 90 - h / Math.PI * 180;
    f.style.transform = `rotate(${u}deg)`;
  }
  updateMarker(e, s) {
    const { point: i, index: n, object: r } = e, o = r, a = o.curve, c = o.curve.alignment, h = c.getPercentageAt(i, this.view), f = i.clone();
    this.setMouseMarker(f, o, n, s), h !== null && this.onMarkerChange.trigger({ alignment: c, percentage: h, type: s, curve: a });
  }
  getScaledBox(e, s) {
    const i = new A.Box3(), n = new A.Vector3(), r = new A.Vector3();
    return e.getCenter(r), e.getSize(n), n.multiplyScalar(s), i.setFromCenterAndSize(r, n), i;
  }
}
class Gp {
  constructor(t, e, s) {
    w(this, "components");
    w(this, "_scene");
    w(this, "_world");
    w(this, "offset", 10);
    w(this, "markupLines", []);
    w(this, "currentCurveMesh");
    w(this, "markupMaterial", new A.LineBasicMaterial({
      color: 6842472
    }));
    this.components = t, this._scene = e, this._world = s;
  }
  showCurveInfo(t) {
    switch (this.disposeMarkups(), this.currentCurveMesh = t, t.curve.data.TYPE) {
      case "LINE":
        this.showLineInfo(t, this.offset);
        break;
      case "CIRCULARARC":
        this.showCircularArcInfo(t, this.offset);
        break;
      case "CLOTHOID":
        this.showClothoidInfo(t, this.offset);
        break;
      default:
        console.log("Unknown curve type:", t.curve.data.TYPE);
        break;
    }
  }
  updateOffset(t, e, s) {
    const n = Math.max(t.height, t.width) / (e * 150);
    n !== this.offset && (this.offset = n, s && this.currentCurveMesh && this.showCurveInfo(this.currentCurveMesh));
  }
  dispose() {
    for (const t of this.markupLines)
      t.removeFromParent();
    this.disposeMarkups(), this.markupMaterial.dispose();
  }
  disposeMarkups() {
    for (const t of this.markupLines)
      t.geometry.dispose(), t.removeFromParent();
    this.markupLines = [];
  }
  unSelect() {
    this.disposeMarkups();
  }
  calculateTangent(t, e) {
    const i = e * 3, n = Math.max(0, i - 3), r = Math.min(
      t.length - 3,
      i + 3
    ), o = new A.Vector3().fromArray(t, n);
    return new A.Vector3().fromArray(t, r).clone().sub(o).normalize();
  }
  calculateParallelCurve(t, e, s) {
    const i = [];
    for (let n = 0; n < e; n++) {
      const o = this.calculateTangent(t, n).clone().applyAxisAngle(new A.Vector3(0, 0, 1), Math.PI / 2);
      o.normalize();
      const a = o.clone().multiplyScalar(s), c = n * 3, h = new A.Vector3().fromArray(t, c).add(a);
      i.push(h);
    }
    return i;
  }
  calculateDimensionLines(t, e) {
    const s = [], i = t.geometry.attributes.position.array, n = e.geometry.attributes.position.array;
    if (i.length < 6 && n.length < 6)
      throw new Error("Line must have at least two vertices");
    const r = new A.Vector3(
      i[0],
      i[1],
      i[2]
    ), o = new A.Vector3(
      n[0],
      n[1],
      n[2]
    ), a = [], c = i.length - 3, h = new A.Vector3(
      i[c],
      i[c + 1],
      i[c + 2]
    ), f = n.length - 3, u = new A.Vector3(
      n[f],
      n[f + 1],
      n[f + 2]
    );
    return s.push(r, o), a.push(h, u), { startDimensionPoints: s, endDimensionPoints: a };
  }
  offsetDimensionLine(t, e) {
    const i = new A.Vector3().copy(t[t.length - 1]).sub(t[0]).normalize().clone().multiplyScalar(e);
    return t.map((r) => r.clone().add(i));
  }
  showLineInfo(t, e) {
    const s = this.components.get(fs);
    s.world = this._world, s.deleteByType(["Length", "Radius"]);
    const i = t.geometry.attributes.position.array, n = this.calculateParallelCurve(
      i,
      i.length / 3,
      e
    ), r = new A.BufferGeometry().setFromPoints(
      n
    ), o = new A.Line(
      r,
      this.markupMaterial
    );
    s.showLineLength(o, t.curve.getLength()), this._scene.add(o), this.markupLines.push(o);
    const { startDimensionPoints: a, endDimensionPoints: c } = this.calculateDimensionLines(t, o), h = this.offsetDimensionLine(
      a,
      e * 0.1
    ), f = this.offsetDimensionLine(
      c,
      e * 0.1
    ), u = new A.BufferGeometry().setFromPoints(
      h
    ), d = new A.BufferGeometry().setFromPoints(
      f
    ), p = new A.Line(
      u,
      this.markupMaterial
    );
    this._scene.add(p), this.markupLines.push(p);
    const m = new A.Line(
      d,
      this.markupMaterial
    );
    this._scene.add(m), this.markupLines.push(m);
  }
  showClothoidInfo(t, e) {
    const s = this.components.get(fs);
    s.world = this._world, s.deleteByType(["Length", "Radius"]);
    const i = t.geometry.attributes.position.array, n = this.calculateParallelCurve(
      i,
      i.length / 3,
      e
    ), r = new A.BufferGeometry().setFromPoints(
      n
    );
    s.showCurveLength(n, t.curve.getLength());
    const o = new A.Line(
      r,
      this.markupMaterial
    );
    this._scene.add(o), this.markupLines.push(o);
    const { startDimensionPoints: a, endDimensionPoints: c } = this.calculateDimensionLines(t, o), h = this.offsetDimensionLine(
      a,
      e * 0.1
    ), f = this.offsetDimensionLine(
      c,
      e * 0.1
    ), u = new A.BufferGeometry().setFromPoints(
      h
    ), d = new A.BufferGeometry().setFromPoints(
      f
    ), p = new A.Line(
      u,
      this.markupMaterial
    );
    this._scene.add(p), this.markupLines.push(p);
    const m = new A.Line(
      d,
      this.markupMaterial
    );
    this._scene.add(m), this.markupLines.push(m);
  }
  showCircularArcInfo(t, e) {
    const s = this.components.get(fs);
    s.world = this._world, s.deleteByType(["Length", "Radius"]);
    const i = t.curve.data.RADIUS, n = t.geometry.attributes.position.array, r = t.geometry.attributes.position.count, o = [], a = new A.Vector3(
      n[0],
      n[1],
      n[2]
    ), c = (r - 1) * 3, h = new A.Vector3(
      n[c],
      n[c + 1],
      n[c + 2]
    ), f = r / 2 * 3, u = new A.Vector3(
      n[f],
      n[f + 1],
      n[f + 2]
    ), d = h.clone().sub(a).normalize(), p = new A.Vector3(
      -d.y,
      d.x,
      0
    );
    p.multiplyScalar(i);
    const m = u.clone().add(p);
    o.push(u), o.push(m);
    const E = new A.BufferGeometry().setFromPoints(o), I = new A.Line(E, this.markupMaterial);
    s.showCurveRadius(I, Math.abs(i)), this._scene.add(I), this.markupLines.push(I);
    const g = [];
    for (let D = 0; D < r; D++) {
      const R = this.calculateTangent(n, D), _ = t.curve.data.RADIUS, K = new A.Vector3(
        R.y,
        -R.x,
        0
      );
      K.normalize(), _ < 0 && K.negate();
      const U = K.clone().multiplyScalar(e), Z = D * 3, H = new A.Vector3(
        n[Z] + U.x,
        n[Z + 1] + U.y,
        n[Z + 2] + U.z
      );
      g.push(H);
    }
    const T = new A.BufferGeometry().setFromPoints(
      g
    );
    s.showCurveLength(g, t.curve.getLength());
    const C = new A.Line(
      T,
      this.markupMaterial
    );
    this._scene.add(C), this.markupLines.push(C);
    const { startDimensionPoints: F, endDimensionPoints: O } = this.calculateDimensionLines(t, C), P = this.offsetDimensionLine(
      F,
      e * 0.1
    ), M = this.offsetDimensionLine(
      O,
      e * 0.1
    ), L = new A.BufferGeometry().setFromPoints(
      P
    ), b = new A.BufferGeometry().setFromPoints(
      M
    ), B = new A.Line(
      L,
      this.markupMaterial
    );
    this._scene.add(B), this.markupLines.push(B);
    const v = new A.Line(
      b,
      this.markupMaterial
    );
    this._scene.add(v), this.markupLines.push(v);
  }
}
const Pn = class Pn extends dc {
  constructor(e) {
    super(e);
    /**
     * The view mode of the component.
     * In this case, the view mode is set to "horizontal".
     */
    w(this, "view", "horizontal");
    w(this, "planHighlighter");
    this.components.add(Pn.uuid, this), this.onHighlight.add(({ mesh: s }) => {
      !this._highlighter || !this.planHighlighter || this.planHighlighter.showCurveInfo(s);
    });
  }
  /**
   * Getter for the world property.
   * Returns the world associated with the CivilPlanNavigator instance.
   */
  get world() {
    return super.world;
  }
  /**
   * Setter for the world property.
   * Sets the world associated with the CivilPlanNavigator instance.
   * If a new world is provided, the existing PlanHighlighter instance is disposed and a new one is created.
   * @param world - The new world to be associated with the CivilPlanNavigator instance.
   */
  set world(e) {
    var s;
    super.world = e, e && ((s = this.planHighlighter) == null || s.dispose(), this.planHighlighter = new Gp(
      this.components,
      e.scene.three,
      e
    ));
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Pn, "uuid", "3096dea0-5bc2-41c7-abce-9089b6c9431b");
let Pa = Pn;
const Nn = class Nn extends dc {
  constructor(e) {
    super(e);
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    w(this, "view", "vertical");
    this.components.add(Nn.uuid, this);
  }
  /**
   * Getter for the world property.
   * This property is used to retrieve the world context for the component.
   *
   * @returns {OBC.World | null} - The current world context for the component.
   * If null, it means the world has not been set yet.
   */
  get world() {
    return super.world;
  }
  /**
   * Sets the world for the CivilElevationNavigator.
   * This property is used to manage the world context for the component.
   * When the world is set, it triggers the addition of elevation markers to the scene.
   *
   * @param world - The world to set for the component. If null, it will not update the world.
   */
  set world(e) {
    this.world !== e && (super.world = e, this._highlighter && this._highlighter.onSelect.add((s) => {
      if (!this.world)
        throw new Error("A world is needed to work with this component!");
      const i = this.components.get(fs);
      i.deleteByType(["Slope", "Height", "InitialKPV", "FinalKPV"]);
      const { alignment: n } = s.curve, r = [];
      for (const h of n.vertical) {
        const f = h.mesh.geometry.attributes.position.array;
        r.push(f);
      }
      const { defSegments: o, slope: a } = this.setDefSegments(r), c = this.world.scene.three;
      for (let h = 0; h < n.vertical.length; h++) {
        const f = n.vertical[h];
        i.addVerticalMarker(
          this.world,
          `S: ${a[h].slope}%`,
          f.mesh,
          "Slope",
          c
        ), i.addVerticalMarker(
          this.world,
          `H: ${o[h].end.y.toFixed(2)}`,
          f.mesh,
          "Height",
          c
        );
      }
      i.addVerticalMarker(
        this.world,
        "KP: 0",
        n.vertical[0].mesh,
        "InitialKPV",
        c
      ), i.addVerticalMarker(
        this.world,
        `KP: ${n.vertical.length}`,
        n.vertical[n.vertical.length - 1].mesh,
        "FinalKPV",
        c
      );
    }));
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Nn, "uuid", "097eea29-2d5a-431a-a247-204d44670621");
let Na = Nn;
const xn = class xn extends ue {
  constructor(e) {
    super(e);
    /**
     * Event triggered when a curve is highlighted.
     * Provides information about the highlighted curve, point, and index.
     */
    w(this, "onHighlight", new Y());
    /**
     * Event triggered when a marker (point) on a curve changes.
     * Provides information about the alignment, percentage, type of marker, and the curve.
     */
    w(this, "onMarkerChange", new Y());
    /**
     * Event triggered when a marker (point) on a curve is hidden.
     * Provides information about the type of marker.
     */
    w(this, "onMarkerHidden", new Y());
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    w(this, "mouseMarkers");
    w(this, "_highlighter");
    w(this, "_curves", []);
    w(this, "_world", null);
    w(this, "updateLinesResolution", (e) => {
      var s;
      (s = this.highlighter) == null || s.setResolution(e);
    });
    w(this, "onClick", (e) => {
      if (!this.enabled || !this._highlighter)
        return;
      if (!this.world)
        throw new Error("No world found!");
      if (!this.world.renderer)
        return;
      const s = this.world.renderer.three.domElement, i = this.world.camera.three, n = this._highlighter.castRay(e, i, s, this._curves);
      if (n) {
        const r = n.object;
        this._highlighter.select(r), this.updateMarker(n, "select");
        const { point: o, index: a } = n;
        a !== void 0 && this.onHighlight.trigger({ curve: r, point: o, index: a });
        return;
      }
      this._highlighter.unSelect(), this.mouseMarkers && (this.mouseMarkers.hover.visible = !1), this.onMarkerHidden.trigger({ type: "hover" });
    });
    w(this, "onMouseMove", async (e) => {
      if (!this.enabled || !this._highlighter)
        return;
      if (!this.world)
        throw new Error("No world found!");
      if (!this.world.renderer)
        return;
      const s = this.world.renderer.three.domElement, i = this.world.camera.three, n = this._highlighter.castRay(e, i, s, this._curves);
      if (n) {
        this._highlighter.hover(n.object), this.updateMarker(n, "hover");
        return;
      }
      this._highlighter.unHover();
    });
    this.components.add(xn.uuid, this);
  }
  /**
   * Getter for the world property.
   * Returns the current world instance.
   * @returns {OBC.World | null} The current world instance or null if not set.
   */
  get world() {
    return this._world;
  }
  /**
   * Setter for the world property.
   * Sets the world instance and initializes the component.
   * @param {OBC.World | null} world - The new world instance or null to clear the current world.
   */
  set world(e) {
    var i, n, r;
    if (e === this._world || (this._world && this.setupEvents(!1), this._world = e, (i = this._highlighter) == null || i.dispose(), (n = this.mouseMarkers) == null || n.hover.dispose(), (r = this.mouseMarkers) == null || r.select.dispose(), !e))
      return;
    const s = e.scene.three;
    this._highlighter = new Rn(s, "absolute"), this.mouseMarkers = {
      select: this.newMouseMarker("#ffffff", e),
      hover: this.newMouseMarker("#575757", e)
    }, this.setupEvents(!0);
  }
  /**
   * Getter for the highlighter property.
   * Returns the curve highlighter instance.
   * @returns {CurveHighlighter} The curve highlighter instance.
   * @throws {Error} If the navigator is not initialized.
   */
  get highlighter() {
    if (!this._highlighter)
      throw new Error("Navigator not initialized!");
    return this._highlighter;
  }
  /**
   * Draws the civil engineering data onto the 3D scene.
   *
   * @param model - The FragmentsGroup containing the civil data to be drawn.
   * @throws Will throw an error if the model does not have civil data or if the world is not set.
   */
  draw(e) {
    if (!e.civilData)
      throw new Error("Model must have civil data!");
    if (!this.world)
      throw new Error("A world must be given before drawing an alignment!");
    const s = this.world.scene.three;
    for (const [i, n] of e.civilData.alignments)
      for (const { mesh: r } of n.absolute)
        s.add(r), this._curves.push(r);
  }
  /**
   * Sets a marker at a specific percentage along the given alignment.
   *
   * @param alignment - The alignment on which to place the marker.
   * @param percentage - The percentage along the alignment where the marker should be placed.
   * @param type - The type of marker to be set.
   *
   * @throws Will throw an error if the mouse markers have not been initialized.
   *         This can happen if the world has not been set before using this method.
   *
   * @remarks
   * This method calculates the 3D point at the given percentage along the alignment,
   * sets the marker at that point, and makes the marker visible.
   *
   * @example
   * ```typescript
   * const navigator = new Civil3DNavigator(components);
   * navigator.world = world; // Initialize the world
   * const alignment = model.civilData.alignments.get(alignmentId);
   * if (alignment) {
   *   navigator.setMarker(alignment, 0.5, "select");
   * }
   * ```
   */
  setMarker(e, s, i) {
    if (!this.mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    const n = e.getPointAt(s, "absolute");
    this.mouseMarkers[i].visible = !0, this.mouseMarkers[i].three.position.copy(n);
  }
  /**
   * Hides the marker of the specified type.
   *
   * @param type - The type of marker to hide.
   *
   * @throws Will throw an error if the mouse markers have not been initialized.
   *         This can happen if the world has not been set before using this method.
   *
   * @remarks
   * This method hides the marker of the specified type by setting its visibility to false.
   *
   * @example
   * ```typescript
   * const navigator = new Civil3DNavigator(components);
   * navigator.world = world; // Initialize the world
   * navigator.hideMarker("select");
   * ```
   */
  hideMarker(e) {
    if (!this.mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    const s = this.mouseMarkers[e].three;
    s.visible = !1;
  }
  newMouseMarker(e, s) {
    const i = s.scene.three, n = document.createElement("div");
    n.style.backgroundColor = e, n.style.width = "1rem", n.style.height = "1rem", n.style.borderRadius = "1rem";
    const r = new Ke(s, n, i);
    return r.visible = !1, r;
  }
  setupEvents(e) {
    var i, n;
    if (!this.world)
      throw new Error("No world found!");
    if (this.world.isDisposing || !this.world.renderer)
      return;
    const s = this.world.renderer.three.domElement;
    (i = this.world.renderer) == null || i.onResize.remove(this.updateLinesResolution), s.removeEventListener("click", this.onClick), s.removeEventListener("pointermove", this.onMouseMove), e && (s.addEventListener("click", this.onClick), s.addEventListener("pointermove", this.onMouseMove), (n = this.world.renderer) == null || n.onResize.add(this.updateLinesResolution));
  }
  updateMarker(e, s) {
    if (!this.mouseMarkers)
      return;
    const { point: i, object: n } = e, r = n, o = r.curve, a = r.curve.alignment, c = a.getPercentageAt(i, "absolute");
    this.mouseMarkers[s].visible = !0, this.mouseMarkers[s].three.position.copy(i), c !== null && this.onMarkerChange.trigger({ alignment: a, percentage: c, type: s, curve: o });
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(xn, "uuid", "0a59c09e-2b49-474a-9320-99f51f40f182");
let xa = xn;
const Ln = class Ln extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /**
     * A property representing the world in which the component operates.
     */
    w(this, "world", null);
    /**
     * A property representing the plane used for cross section visualization.
     */
    w(this, "plane");
    w(this, "_world3D", null);
    this.components.add(Ln.uuid, this);
  }
  /**
   * A getter for the 3D world.
   * @returns The 3D world.
   */
  get world3D() {
    return this._world3D;
  }
  /**
   * A setter for the 3D world.
   * @param world - The new 3D world.
   */
  set world3D(e) {
    var n;
    if (this._world3D = e, (n = this.plane) == null || n.dispose(), !e)
      return;
    const s = this.components.get(Bs), i = s.Type;
    s.Type = Sn, this.plane = s.createFromNormalAndCoplanarPoint(
      e,
      new A.Vector3(1, 0, 0),
      new A.Vector3()
    ), s.Type = i, this.plane.visible = !1, this.plane.enabled = !1;
  }
  /**
   * Sets the cross section plane based on the given curve mesh and point.
   *
   * @param curveMesh - The curve mesh to create the cross section from.
   * @param point - The point on the curve mesh where the cross section should be created.
   *
   * @throws Will throw an error if the world or plane is not set before calling this method.
   * @throws Will throw an error if the geometry is not indexed.
   *
   * @returns {Promise<void>}
   */
  async set(e, s) {
    if (!this.world || !this.plane)
      throw new Error("You must set a world before using this component");
    this.plane.enabled = !0;
    const i = e.curve.getPercentageAt(s);
    if (i === null)
      return;
    const { startPoint: n, endPoint: r } = e.curve.getSegmentAt(i);
    if (e.geometry.index === null)
      throw new Error("Geometry must be indexed!");
    const o = new A.Vector3();
    o.subVectors(r, n), o.normalize(), this.plane.setFromNormalAndCoplanarPoint(o, s), this.plane.edges.update();
    const a = this.plane.helper.matrix.clone();
    a.invert();
    const c = this.world.scene.three, h = this.plane.edges.get();
    for (const f in h) {
      const { mesh: u } = h[f];
      u.position.set(0, 0, 0), u.rotation.set(0, 0, 0), u.updateMatrix(), u.applyMatrix4(a), u.parent !== c && c.add(u);
    }
    this.plane.enabled = !1;
  }
};
/**
 * A unique identifier for the component. This UUID is used to register the component within the Components system.
 */
w(Ln, "uuid", "96b2c87e-d90b-4639-8257-8f01136fe324");
let La = Ln;
function $t() {
  const l = document.createElement("div");
  return l.style.backgroundColor = "black", l.style.color = "white", l.style.padding = "8px", l.style.borderRadius = "8px", l.style.fontFamily = "sans-serif", l;
}
const Qt = class Qt {
  constructor(t, e, s) {
    /**
     * The label for the dimension line.
     */
    w(this, "label");
    /**
     * The bounding box for the dimension line.
     */
    w(this, "boundingBox", new A.Mesh());
    /**
     * The world in which the dimension line exists.
     */
    w(this, "world");
    /**
     * The components used by the dimension line.
     */
    w(this, "components");
    w(this, "_length");
    w(this, "_visible", !0);
    w(this, "_start");
    w(this, "_end");
    w(this, "_root", new A.Group());
    w(this, "_endpoints", []);
    w(this, "_line");
    this.components = t, this.world = e, this._start = s.start, this._end = s.end, this._length = this.getLength(), this._line = this.createLine(s), this.newEndpointElement(s.endpointElement), this.newEndpointElement(s.endpointElement.cloneNode(!0)), this.label = this.newText(), this._root.renderOrder = 2, this.world.scene.three.add(this._root);
  }
  /**
   * Getter for the visibility of the dimension line.
   * @returns {boolean} The current visibility state.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Setter for the visibility of the dimension line.
   * @param {boolean} value - The new visibility state.
   */
  set visible(t) {
    this._visible = t, this.label.visible = t, this._endpoints[0].visible = t, this._endpoints[1].visible = t;
    const [e, s] = this._endpoints, i = e.three, n = s.three, r = this.label.three;
    t ? (this.world.scene.three.add(this._root), this._root.add(r, i, n)) : (r.removeFromParent(), i.removeFromParent(), n.removeFromParent(), this._root.removeFromParent());
  }
  /**
   * Getter for the end point of the dimension line.
   * @returns {THREE.Vector3} The current end point.
   */
  get endPoint() {
    return this._end;
  }
  /**
   * Setter for the end point of the dimension line.
   * Updates the line geometry and position of the end point marker.
   * @param {THREE.Vector3} point - The new end point.
   */
  set endPoint(t) {
    this._end = t;
    const e = this._line.geometry.attributes.position;
    e.setXYZ(1, t.x, t.y, t.z), e.needsUpdate = !0, this._endpoints[1].three.position.copy(t), this.updateLabel();
  }
  /**
   * Getter for the start point of the dimension line.
   * @returns {THREE.Vector3} The current start point.
   */
  get startPoint() {
    return this._start;
  }
  /**
   * Setter for the start point of the dimension line.
   * Updates the line geometry and position of the start point marker.
   * @param {THREE.Vector3} point - The new start point.
   */
  set startPoint(t) {
    this._start = t;
    const e = this._line.geometry.attributes.position;
    e.setXYZ(0, t.x, t.y, t.z), e.needsUpdate = !0, this._endpoints[0].three.position.copy(t), this.updateLabel();
  }
  get _center() {
    let t = this._end.clone().sub(this._start);
    const e = t.length() * 0.5;
    return t = t.normalize().multiplyScalar(e), this._start.clone().add(t);
  }
  /**
   * Disposes of the dimension line and its associated resources.
   * This method should be called when the dimension line is no longer needed.
   * It removes the dimension line from the world, destroys its components, and frees up memory.
   */
  dispose() {
    const t = this.components.get(Ot);
    this.visible = !1, t.destroy(this._root), t.destroy(this._line);
    for (const e of this._endpoints)
      e.dispose();
    this._endpoints.length = 0, this.label.dispose(), this.boundingBox && t.destroy(this.boundingBox), this.components = null;
  }
  /**
   * Creates a bounding box for the dimension line.
   * The bounding box is a 3D box that encloses the dimension line.
   * It is used for collision detection and visibility culling.
   * The bounding box is initially invisible and can be toggled using the `toggleBoundingBox` method.
   */
  createBoundingBox() {
    this.boundingBox.geometry = new A.BoxGeometry(1, 1, this._length), this.boundingBox.position.copy(this._center), this.boundingBox.lookAt(this._end), this.boundingBox.visible = !1, this._root.add(this.boundingBox);
  }
  /**
   * Toggles the visibility of the dimension line's label.
   * The label is a text element that displays the length of the dimension line.
   * This method is used to show or hide the label when needed.
   */
  toggleLabel() {
    this.label.toggleVisibility();
  }
  newEndpointElement(t) {
    const s = this._endpoints.length === 0 ? this._start : this._end, i = new Ke(this.world, t);
    i.three.position.copy(s), this._endpoints.push(i), this._root.add(i.three);
  }
  updateLabel() {
    this._length = this.getLength(), this.label.three.element.textContent = this.getTextContent(), this.label.three.position.copy(this._center), this._line.computeLineDistances();
  }
  createLine(t) {
    const e = new A.BufferGeometry();
    e.setFromPoints([t.start, t.end]);
    const s = new A.Line(e, t.lineMaterial);
    return this._root.add(s), s;
  }
  newText() {
    const t = $t();
    t.textContent = this.getTextContent();
    const e = new Ke(this.world, t);
    return e.three.position.copy(this._center), this._root.add(e.three), e;
  }
  getTextContent() {
    return `${(this._length / Qt.scale).toFixed(Qt.rounding)} ${Qt.units}`;
  }
  getLength() {
    return this._start.distanceTo(this._end);
  }
};
/**
 * The scale factor for the dimension line.
 */
w(Qt, "scale", 1), /**
 * The units used for the dimension line.
 */
w(Qt, "units", "m"), /**
 * The number of decimals to show in the label.
 */
w(Qt, "rounding", 2);
let Ai = Qt;
class Yp {
  constructor(t, e, s) {
    w(this, "enabled", !0);
    w(this, "points", []);
    w(this, "workingPlane", null);
    w(this, "labelMarker");
    w(this, "world");
    w(this, "components");
    w(this, "onDisposed", new Y());
    w(this, "onAreaComputed", new Y());
    w(this, "onWorkingPlaneComputed", new Y());
    w(this, "onPointAdded", new Y());
    w(this, "onPointRemoved", new Y());
    w(this, "_visible", !0);
    w(this, "_rotationMatrix", null);
    w(this, "_dimensionLines", []);
    w(this, "_defaultLineMaterial", new A.LineBasicMaterial({ color: "red" }));
    this.world = e, this.components = t;
    const i = $t();
    this.labelMarker = new Ke(e, i), this.labelMarker.visible = !1, this.onPointAdded.add((n) => {
      this.points.length === 3 && !this._dimensionLines[2] && (this.addDimensionLine(n, this.points[0]), this.labelMarker.visible = !0);
    }), s == null || s.forEach((n) => this.setPoint(n));
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this._visible;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(t) {
    this._visible = t;
    for (const e of this._dimensionLines)
      e.visible = t, e.label.visible = !1;
    this.labelMarker.visible = t;
  }
  setPoint(t, e) {
    let s;
    if (e ? s = e : s = this.points.length === 0 ? 0 : this.points.length, s === 0) {
      this.points[0] = t;
      return;
    }
    if (s < 0 || s > this.points.length)
      return;
    const i = this.points.length > s;
    this.points[s] = t, this.onPointAdded.trigger(t), i || this.addDimensionLine(this.points[s - 1], t);
    const { previousLine: n, nextLine: r } = this.getLinesBetweenIndex(s);
    n && (n.endPoint = t), r && (r.startPoint = t);
  }
  removePoint(t) {
    if (this.points.length === 3)
      return;
    this.points.splice(t, 1);
    const { previousLine: e, nextLine: s } = this.getLinesBetweenIndex(t);
    s && (e.endPoint = s.endPoint), s == null || s.dispose(), this._dimensionLines.splice(t, 1), this.onPointRemoved.trigger();
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  addDimensionLine(t, e) {
    const s = new Ai(this.components, this.world, {
      start: t,
      end: e,
      lineMaterial: this._defaultLineMaterial,
      endpointElement: $t()
    });
    return s.toggleLabel(), this._dimensionLines.length > 1 ? this._dimensionLines.splice(
      this._dimensionLines.length - 1,
      0,
      s
    ) : this._dimensionLines.push(s), s;
  }
  getLinesBetweenIndex(t) {
    const e = t === 0 ? this._dimensionLines.length - 1 : t - 1, s = this._dimensionLines[e], i = this._dimensionLines[t];
    return { previousLine: s, nextLine: i };
  }
  computeWorkingPlane() {
    this.workingPlane = new A.Plane().setFromCoplanarPoints(
      this.points[0],
      this.points[1],
      this.points[2]
    );
    const t = new A.Vector3(0, 1, 0), e = this.workingPlane.normal.angleTo(t), s = new A.Vector3().crossVectors(this.workingPlane.normal, t).normalize();
    this._rotationMatrix = new A.Matrix4().makeRotationAxis(
      s,
      e
    ), this.onWorkingPlaneComputed.trigger(this.workingPlane);
  }
  computeArea() {
    if (!(this._rotationMatrix && this.workingPlane))
      return this.onAreaComputed.trigger(0), 0;
    let t = 0, e = 0;
    const s = this._rotationMatrix, i = this.points.map((r) => {
      const o = r.clone().applyMatrix4(s), a = new A.Vector2(
        o.x,
        o.z
      );
      return t += a.x, e += a.y, a;
    }), n = Math.abs(A.ShapeUtils.area(i));
    return this.labelMarker.three.element.textContent = `${n.toFixed(2)} m²`, this.labelMarker.three.position.set(
      t / i.length,
      -this.workingPlane.constant,
      e / i.length
    ).applyMatrix4(s.clone().invert()), this.onAreaComputed.trigger(n), n;
  }
  dispose() {
    this.onAreaComputed.reset(), this.onWorkingPlaneComputed.reset(), this.onPointAdded.reset(), this.onPointRemoved.reset();
    for (const t of this._dimensionLines)
      t.dispose();
    this.labelMarker.dispose(), this._dimensionLines = [], this.points = [], this._rotationMatrix = null, this.workingPlane = null, this._defaultLineMaterial.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  get() {
    return {
      points: this.points,
      workingPlane: this.workingPlane,
      area: this.computeArea()
    };
  }
}
class po extends nu {
  constructor(e, s) {
    super(e, s);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** The marker used to indicate the picked vertex. */
    w(this, "marker", null);
    w(this, "_className", "default-vertex-picker");
    this.onEnabled.add((i) => {
      this.marker && (this.marker.visible = i);
    });
  }
  get className() {
    return this._className;
  }
  set className(e) {
    this._className = e, this.marker && (this.marker.three.element.className = e);
  }
  /** {@link OBC.Disposable.onDisposed} */
  dispose() {
    this.marker && this.marker.dispose(), super.dispose();
  }
  /**
   * Retrieves the picked vertex from the world and updates the marker's position.
   * If no vertex is picked, the marker is hidden.
   *
   * @param world - The world in which to pick the vertex.
   * @returns The picked vertex, or null if no vertex was picked.
   */
  get(e) {
    const s = super.get(e);
    return s ? (this.marker || (this.marker = new Ke(e), this.marker.three.element.className = this._className), this.marker.world !== e && (this.marker.world = e, this.marker.three.removeFromParent(), e.scene.three.add(this.marker.three)), this.marker.visible = !0, this.marker.three.position.copy(s)) : this.marker && (this.marker.visible = !1), s;
  }
}
const fi = class fi extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * A list of all the area measurement elements created by this component.
     */
    w(this, "list", []);
    /**
     * The world in which the area measurements are performed.
     * This property is optional and can be set to null if no world is available.
     */
    w(this, "world");
    w(this, "_enabled", !1);
    w(this, "_visible", !0);
    w(this, "_vertexPicker");
    w(this, "_currentAreaElement", null);
    w(this, "_clickCount", 0);
    /** {@link OBC.Createable.create} */
    w(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world)
        throw new Error("World not defined for the area measurement!");
      const e = this._vertexPicker.get(this.world);
      if (e) {
        if (!this._currentAreaElement) {
          const s = new Yp(this.components, this.world);
          s.onPointAdded.add(() => {
            this._clickCount === 2 && !s.workingPlane && (s.computeWorkingPlane(), this._vertexPicker.workingPlane = s.workingPlane);
          }), s.onPointRemoved.add(() => this._clickCount--), this._currentAreaElement = s;
        }
        this._currentAreaElement.setPoint(e, this._clickCount), this._currentAreaElement.computeArea(), this._clickCount++;
      }
    });
    w(this, "onMouseMove", () => {
      if (!this.world) {
        console.log("No world given for the area measurement!");
        return;
      }
      const e = this._vertexPicker.get(this.world);
      e && this._currentAreaElement && (this._currentAreaElement.setPoint(e, this._clickCount), this._currentAreaElement.computeArea());
    });
    w(this, "onKeydown", (e) => {
      this.enabled && (e.key === "z" && e.ctrlKey && this._currentAreaElement && this._currentAreaElement.removePoint(this._clickCount - 1), e.key === "Enter" && this._currentAreaElement && this.endCreation(), e.key === "Escape" && (this._clickCount === 0 && !this._currentAreaElement ? this.enabled = !1 : this.cancelCreation()));
    });
    this.components.add(fi.uuid, this), this._vertexPicker = new po(e);
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    this._enabled = e, this._vertexPicker.enabled = e, this.setupEvents(e), e || this.cancelCreation();
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the working plane for the area measurement.
   * Sets the working plane for the vertex picker.
   * @param plane - The new working plane or null if no plane is to be used.
   */
  set workingPlane(e) {
    this._vertexPicker.workingPlane = e;
  }
  /**
   * Getter for the working plane for the area measurement.
   * @returns The current working plane or null if no plane is being used.
   */
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this._visible;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(e) {
    this._visible = e;
    for (const s of this.list)
      s.visible = e;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this._vertexPicker.dispose(), this._currentAreaElement && this._currentAreaElement.dispose();
    for (const e of this.list)
      e.dispose();
    this.components = null, this.onDisposed.trigger(fi.uuid), this.onDisposed.reset();
  }
  // TODO: Implement this
  /** {@link OBC.Createable.delete} */
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
    this._currentAreaElement && (this._currentAreaElement.points.length < 3 || (this._currentAreaElement && (this.list.push(this._currentAreaElement), this._currentAreaElement.removePoint(this._clickCount), this._currentAreaElement.computeWorkingPlane(), this._currentAreaElement.computeArea(), this._currentAreaElement = null), this._vertexPicker.workingPlane = null, this._clickCount = 0));
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
    this._currentAreaElement && (this._currentAreaElement.dispose(), this._currentAreaElement = null), this._vertexPicker.workingPlane = null, this._clickCount = 0;
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The area measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the area measurement needs a renderer!");
    const i = this.world.renderer.three.domElement.parentElement;
    e ? (i.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (i.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(fi, "uuid", "c453a99e-f054-4781-9060-33df617db4a5");
let Ma = fi;
class Hp {
  constructor(t, e) {
    w(this, "enabled", !0);
    w(this, "visible", !0);
    w(this, "points", []);
    w(this, "world");
    w(this, "onDisposed", new Y());
    w(this, "_lineMaterial", new wi({
      color: 6629591,
      linewidth: 2
    }));
    w(this, "_lineGeometry", new yn());
    w(this, "_line", new rc(this._lineGeometry, this._lineMaterial));
    w(this, "_labelMarker");
    w(this, "onAngleComputed", new Y());
    w(this, "onPointAdded", new Y());
    this.world = t;
    const s = $t();
    this._labelMarker = new Ke(t, s), this.labelMarker.visible = !0, this.onPointAdded.add(() => {
      this.points.length === 1 && t.scene.three.add(this._line), this.points.length === 3 && (this.labelMarker.visible = !0);
    }), this.onAngleComputed.add((i) => {
      this.labelMarker.three.element.textContent = `${i.toFixed(2)}°`, this.labelMarker.three.position.copy(
        this.points[1] ?? new A.Vector3()
      );
    }), e == null || e.forEach((i) => this.setPoint(i));
  }
  set lineMaterial(t) {
    this._lineMaterial.dispose(), this._lineMaterial = t, this._line.material = t, this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  get lineMaterial() {
    return this._lineMaterial;
  }
  set labelMarker(t) {
    this._labelMarker.dispose(), this._labelMarker = t;
  }
  get labelMarker() {
    return this._labelMarker;
  }
  get angle() {
    return {
      points: this.points,
      angle: this.computeAngle()
    };
  }
  setPoint(t, e) {
    let s;
    if (e ? s = e : s = this.points.length === 0 ? 0 : this.points.length, ![0, 1, 2].includes(s))
      return;
    this.points[s] = t, this.onPointAdded.trigger(t);
    const i = this.points.map((n) => [n.x, n.y, n.z]);
    this._lineGeometry.setPositions(i.flat());
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  computeAngle() {
    const t = this.points[0], e = this.points[1], s = this.points[2];
    if (!(t && e && s))
      return 0;
    const i = new A.Vector3().subVectors(e, t), n = new A.Vector3().subVectors(e, s), r = A.MathUtils.radToDeg(i.angleTo(n));
    return this.onAngleComputed.trigger(r), r;
  }
  dispose() {
    this.points = [], this.labelMarker.dispose(), this.onAngleComputed.reset(), this.onPointAdded.reset(), this.labelMarker.dispose(), this._line.removeFromParent(), this._lineMaterial.dispose(), this._lineGeometry.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
}
const di = class di extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * The world in which the angle measurements are performed.
     * This property is optional and can be set to null if no world is available.
     */
    w(this, "world");
    /**
     * A list of all the angle measurement elements created by this component.
     */
    w(this, "list", []);
    w(this, "_lineMaterial");
    w(this, "_enabled", !1);
    w(this, "_vertexPicker");
    w(this, "_currentAngleElement", null);
    w(this, "_clickCount", 0);
    /** {@link OBC.Createable.create} */
    w(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world) {
        console.log("No world selected for angle measurement!");
        return;
      }
      const e = this._vertexPicker.get(this.world);
      if (e) {
        if (!this._currentAngleElement) {
          const s = new Hp(this.world);
          s.lineMaterial = this.lineMaterial, this._currentAngleElement = s;
        }
        this._currentAngleElement.setPoint(e, this._clickCount), this._currentAngleElement.setPoint(
          e,
          this._clickCount + 1
        ), this._currentAngleElement.setPoint(
          e,
          this._clickCount + 2
        ), this._currentAngleElement.computeAngle(), this._clickCount++, this._clickCount === 3 && this.endCreation();
      }
    });
    w(this, "onMouseMove", () => {
      if (!this.world) {
        console.log("No world selected for angle measurement!");
        return;
      }
      const e = this._vertexPicker.get(this.world);
      e && this._currentAngleElement && (this._currentAngleElement.setPoint(e, this._clickCount), this._currentAngleElement.computeAngle());
    });
    w(this, "onKeyDown", (e) => {
      this.enabled && e.key === "Escape" && this.cancelCreation();
    });
    this.components.add(di.uuid, this), this._vertexPicker = new po(e), this._lineMaterial = new wi({
      color: 6629591,
      linewidth: 2
    });
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    this._enabled = e, this.setupEvents(e), this._vertexPicker.enabled = e, e || this.cancelCreation();
  }
  /**
   * Getter for the line material used for the angle measurement lines.
   */
  get lineMaterial() {
    return this._lineMaterial;
  }
  /**
   * Setter for the line material used for the angle measurement lines.
   * Disposes the old material and sets the new one.
   * Also updates the resolution of the material to match the window size.
   * @param material - The new line material to use.
   */
  set lineMaterial(e) {
    this._lineMaterial.dispose(), this._lineMaterial = e, this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  /**
   * Getter for the working plane for the angle measurement.
   * @returns The current working plane or null if no plane is being used.
   */
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  /**
   * Setter for the working plane for the angle measurement.
   * Sets the working plane for the vertex picker.
   * @param plane - The new working plane or null if no plane is to be used.
   */
  set workingPlane(e) {
    this._vertexPicker.workingPlane = e;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this._lineMaterial.dispose(), this._vertexPicker.dispose();
    for (const e of this.list)
      e.dispose();
    this._currentAngleElement && this._currentAngleElement.dispose(), this.components = null, this.onDisposed.trigger(di.uuid), this.onDisposed.reset();
  }
  // TODO: Implement this
  /** {@link OBC.Createable.delete} */
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
    this._currentAngleElement && (this.list.push(this._currentAngleElement), this._currentAngleElement.computeAngle(), this._currentAngleElement = null), this._clickCount = 0;
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
    this._currentAngleElement && (this._currentAngleElement.dispose(), this._currentAngleElement = null), this._clickCount = 0;
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("No world selected for angle measurement!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const i = this.world.renderer.three.domElement.parentElement;
    e ? (i.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeyDown)) : (i.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeyDown));
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(di, "uuid", "622fb2c9-528c-4b0a-8a0e-6a1375f0a3aa");
let ba = di;
const pi = class pi extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** {@link OBC.Updateable.onBeforeUpdate} */
    w(this, "onBeforeUpdate", new Y());
    /** {@link OBC.Updateable.onAfterUpdate} */
    w(this, "onAfterUpdate", new Y());
    w(this, "onCleaned", new Y());
    /** The minimum distance to force the dimension cursor to a vertex. */
    w(this, "snapDistance", 0.25);
    /**
     * A list of all the measurement elements created by this component.
     */
    w(this, "list", []);
    /**
     * The world in which the angle measurements are performed.
     * This property is optional and can be set to null if no world is available.
     */
    w(this, "world");
    w(this, "_vertexPicker");
    w(this, "_lineMaterial", new A.LineBasicMaterial({
      color: "#DC2626",
      linewidth: 2,
      depthTest: !1
    }));
    w(this, "_visible", !0);
    w(this, "_enabled", !1);
    /** Temporary variables for internal operations */
    w(this, "_temp", {
      isDragging: !1,
      start: new A.Vector3(),
      end: new A.Vector3(),
      dimension: void 0
    });
    // TODO: The data arg needs to be better defined
    /**
     * Starts or finishes drawing a new dimension line.
     *
     * @param data - forces the dimension to be drawn on a plane. Use this if you are drawing
     * dimensions in floor plan navigation.
     */
    w(this, "create", (e) => {
      const s = e instanceof A.Object3D ? e : void 0;
      if (this._enabled) {
        if (!this._temp.isDragging) {
          this.drawStart(s);
          return;
        }
        this.endCreation();
      }
    });
    w(this, "onMouseMove", () => {
      this.world && this._vertexPicker.get(this.world);
    });
    w(this, "onKeydown", (e) => {
      this.enabled && e.key === "Escape" && this.cancelCreation();
    });
    this.components.add(pi.uuid, this), this._vertexPicker = new po(e, {
      previewElement: $t(),
      snapDistance: this.snapDistance
    });
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    e || this.cancelCreation(), this._enabled = e, this._vertexPicker.enabled = e, this.setupEvents(e);
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this._visible;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(e) {
    this._visible = e;
    for (const s of this.list)
      s.visible = e;
  }
  /**
   * Getter for the color of the dimension lines.
   * Returns the color of the line material used for the dimension lines.
   *
   */
  get color() {
    return this._lineMaterial.color;
  }
  /**
   * Setter for the color of the dimension lines.
   * Sets the color of the line material used for the dimension lines.
   *
   */
  set color(e) {
    this._lineMaterial.color = e;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.enabled = !1;
    for (const e of this.list)
      e.dispose();
    this._lineMaterial.dispose(), this.list = [], this._vertexPicker.dispose(), this.onDisposed.trigger(pi.uuid), this.onDisposed.reset();
  }
  /** {@link OBC.Updateable.update} */
  async update(e) {
    this._enabled && this._temp.isDragging && this.drawInProcess();
  }
  /**
   * Creates a new dimension line between two given points.
   *
   * @param p1 - The start point of the dimension line.
   * @param p2 - The end point of the dimension line.
   *
   */
  createOnPoints(e, s) {
    const i = this.drawDimension();
    return i.startPoint = e, i.endPoint = s, i.createBoundingBox(), this.list.push(i), i;
  }
  /** {@link OBC.Createable.delete} */
  delete() {
    if (!this.world)
      throw new Error("World is needed for Length Measurement!");
    if (!this._enabled || this.list.length === 0)
      return;
    const e = this.getBoundingBoxes(), n = this.components.get(ct).get(this.world).castRay(e);
    if (!n)
      return;
    const r = this.list.find(
      (o) => o.boundingBox === n.object
    );
    if (r) {
      const o = this.list.indexOf(r);
      this.list.splice(o, 1), r.dispose();
    }
  }
  /**
   * Deletes a specific measurement from the list.
   *
   * @param measurement - The measurement to be deleted.
   *
   * @remarks
   * If the measurement does not exist in the list, no action is taken.
   *
   */
  async deleteMeasurement(e) {
    if (e) {
      const s = this.list.indexOf(e);
      this.list.splice(s, 1), e.dispose();
    }
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [], this.onCleaned.trigger(null);
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
    var e;
    this._temp.dimension && (this._temp.isDragging = !1, (e = this._temp.dimension) == null || e.dispose(), this._temp.dimension = void 0);
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
    this._temp.dimension && (this._temp.dimension.createBoundingBox(), this.list.push(this._temp.dimension), this._temp.dimension = void 0, this._temp.isDragging = !1);
  }
  drawStart(e) {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    const s = e ? [e] : void 0, r = this.components.get(ct).get(this.world).castRay(s), o = this._vertexPicker.get(this.world);
    r && o && (this._temp.isDragging = !0, this._temp.start = e ? r.point : o);
  }
  drawInProcess() {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    if (!this.components.get(ct).get(this.world).castRay())
      return;
    const n = this._vertexPicker.get(this.world);
    n && (this._temp.end = n, this._temp.dimension || (this._temp.dimension = this.drawDimension()), this._temp.dimension.endPoint = this._temp.end);
  }
  drawDimension() {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    return new Ai(this.components, this.world, {
      start: this._temp.start,
      end: this._temp.end,
      lineMaterial: this._lineMaterial,
      endpointElement: $t()
    });
  }
  getBoundingBoxes() {
    return this.list.map((e) => e.boundingBox).filter((e) => e !== void 0);
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the length measurement needs a renderer!");
    const i = this.world.renderer.three.domElement.parentElement;
    i && (i.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown), e && (i.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)));
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(pi, "uuid", "2f9bcacf-18a9-4be6-a293-e898eae64ea1");
let as = pi;
const Mn = class Mn extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * Event triggered when a volume is found.
     * The event passes the calculated volume as a parameter.
     */
    w(this, "onVolumeFound", new Y());
    /**
     * Label used to display the calculated volume.
     * It is initially set to null and will be created when needed.
     */
    w(this, "label", null);
    /**
     * The world in which the measurements are performed.
     */
    w(this, "world");
    w(this, "_enabled", !1);
    /** {@link OBC.Createable.create} */
    w(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world)
        throw new Error("World is needed for Volume Measurement!");
      const i = this.components.get(ct).get(this.world).castRay(), n = this.components.get(hs);
      if (!i || !i.object)
        return;
      const { object: r } = i;
      if (r instanceof A.Mesh) {
        const o = n.getVolumeFromMeshes([r]);
        this.onVolumeFound.trigger(o);
      }
    });
    w(this, "onMouseMove", () => {
    });
    w(this, "onKeydown", (e) => {
    });
    this.components.add(Mn.uuid, this);
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    this._enabled = e, this.setupEvents(e), e || this.cancelCreation();
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Disposable.dispose} */
  async dispose() {
    var e;
    this.setupEvents(!1), (e = this.label) == null || e.dispose(), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  /** {@link OBC.Createable.delete} */
  delete() {
  }
  /**
   * Deletes all the measurements created by this component.
   */
  async deleteAll() {
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
  }
  /**
   * Calculates the volume of a set of fragments.
   *
   * @param frags - A map of fragment IDs to their corresponding item IDs.
   * @returns The total volume of the fragments.
   *
   * @remarks
   * This method creates a set of instanced meshes from the given fragments and item IDs.
   * It then calculates the volume of each mesh and returns the total volume.
   *
   * @throws Will throw an error if the world is not set.
   * @throws Will throw an error if the label is not created.
   * @throws Will throw an error if the world's renderer is not set.
   * @throws Will throw an error if the geometry of the meshes is not indexed.
   * @throws Will throw an error if the fragment manager is not available.
   */
  getVolumeFromFragments(e) {
    const i = this.components.get(hs).getVolumeFromFragments(e), n = this.components.get(Tn);
    n.reset(), n.addFragmentIdMap(e);
    const r = n.getSphere();
    return this.setLabel(r, i), i;
  }
  /**
   * Calculates the total volume of a set of meshes.
   *
   * @param meshes - An array of meshes or instanced meshes to calculate the volume from.
   * @returns The total volume of the meshes.
   *
   * @throws Will throw an error if the world is not set.
   * @throws Will throw an error if the label is not created.
   *
   * @remarks
   * This method calculates the volume of each mesh in the provided array and returns the total volume.
   * It also handles the creation of a label if it doesn't exist, adds the label to the world's scene,
   * and positions the label at the center of the bounding sphere of the meshes.
   *
   */
  getVolumeFromMeshes(e) {
    const s = this.components.get(hs), i = this.components.get(Tn);
    i.reset();
    for (const o of e)
      i.addMesh(o);
    const n = i.getSphere(), r = s.getVolumeFromMeshes(e);
    return this.setLabel(n, r), r;
  }
  /**
   * Clears the label associated with the volume measurement.
   *
   * @remarks
   * This method is used to hide the label when the volume measurement is no longer needed.
   * If the label exists, it sets its visibility to false.
   *
   */
  clear() {
    this.label && (this.label.visible = !1);
  }
  newLabel() {
    if (!this.world)
      throw new Error("World is needed for Volume Measurement!");
    const e = $t();
    return new Ke(this.world, e);
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The volume measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the volume measurement needs a renderer!");
    const i = this.world.renderer.three.domElement.parentElement;
    e ? (i.addEventListener("click", this.create), i.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (i.removeEventListener("click", this.create), i.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
  setLabel(e, s) {
    if (!this.world)
      throw new Error("World is needed for Volume Measurement!");
    this.label || (this.label = this.newLabel(), this.label.three.removeFromParent()), this.label.visible = !0, this.world.scene.three.add(this.label.three), this.label.three.position.copy(e.center);
    const i = Math.trunc(s * 100) / 100;
    this.label.three.element.textContent = i.toString();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Mn, "uuid", "811da532-7af3-4635-b592-1c06ae494af5");
let Da = Mn;
const bn = class bn extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * An array of AreaSelection objects representing the user's selections.
     * This array is used to store the selected areas, their meshes, and labels.
     */
    w(this, "selection", []);
    /**
     * A reference to the preview dimension face.
     * This line is used to visualize the measurement while creating it.
     */
    w(this, "preview", new A.Mesh(
      new A.BufferGeometry(),
      new A.MeshBasicMaterial({
        side: 2,
        depthTest: !1,
        transparent: !0,
        opacity: 0.25,
        color: "#BCF124"
      })
    ));
    /**
     * Represents the material used for the selected area in the FaceMeasurement component.
     * This material is applied to the 3D mesh representing the selected area.
     */
    w(this, "selectionMaterial", new A.MeshBasicMaterial({
      side: 2,
      depthTest: !1,
      transparent: !0,
      color: "#BCF124",
      opacity: 0.75
    }));
    /**
     * The world in which the measurements are performed.
     */
    w(this, "world");
    w(this, "_enabled", !1);
    w(this, "_currentSelelection", null);
    /** {@link OBC.Createable.create} */
    w(this, "create", () => {
      if (!this.world)
        throw new Error("No world given to the face measurement!");
      if (!this.enabled || !this._currentSelelection)
        return;
      const e = this.world.scene.three, s = new A.BufferGeometry(), i = new A.Mesh(s, this.selectionMaterial);
      s.setAttribute(
        "position",
        this.preview.geometry.attributes.position
      ), i.position.copy(this.preview.position), e.add(i), s.computeBoundingSphere();
      const { area: n, perimeter: r } = this._currentSelelection, o = this.newLabel(s, n);
      i.add(o.three), this.selection.push({ area: n, perimeter: r, mesh: i, label: o });
    });
    w(this, "onMouseMove", () => {
      if (!this.world)
        throw new Error("The face measurement needs a world to work!");
      if (!this.enabled) {
        this.unselect();
        return;
      }
      const i = this.components.get(ct).get(this.world).castRay();
      if (!i || !i.object || i.faceIndex === void 0) {
        this.unselect();
        return;
      }
      const { object: n, faceIndex: r } = i;
      n instanceof A.Mesh || n instanceof A.InstancedMesh ? this.updateSelection(n, r, i.instanceId) : this.unselect();
    });
    w(this, "onKeydown", (e) => {
    });
    this.components.add(bn.uuid, this), this.preview.frustumCulled = !1;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    if (!this.world)
      throw new Error("No world given for the Face measurement!");
    this._enabled = e, this.setupEvents(e), e ? this.world.scene.three.add(this.preview) : (this.preview.removeFromParent(), this.cancelCreation()), this.setVisibility(e);
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.deleteAll(), this.preview.removeFromParent(), this.preview.material.dispose(), this.preview.geometry.dispose(), this.selectionMaterial.dispose(), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  /** {@link OBC.Createable.delete} */
  delete() {
    if (!this.world)
      throw new Error("No world given to the face measurement!");
    const e = this.selection.map((a) => a.mesh), n = this.components.get(ct).get(this.world).castRay(e);
    if (!n || !n.object)
      return;
    const r = this.selection.find((a) => a.mesh === n.object);
    if (!r)
      return;
    r.mesh.removeFromParent(), r.mesh.geometry.dispose(), r.label.dispose();
    const o = this.selection.indexOf(r);
    this.selection.splice(o, 1);
  }
  /**
   * Deletes all the selections made by the user.
   * It iterates over the `selection` array, removes each mesh and label from the scene,
   * disposes the geometry and material of the mesh, and finally clears the `selection` array.
   */
  deleteAll() {
    for (const e of this.selection)
      e.mesh.removeFromParent(), e.mesh.geometry.dispose(), e.label.dispose();
    this.selection = [];
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
  }
  /**
   * Retrieves the current state of the AreaMeasurement component in a serialized format.
   * This method is used for saving measurements.
   *
   * @returns {SerializedAreaMeasure[]} An array of SerializedAreaMeasure objects,
   * each representing a single selection made by the user.
   */
  get() {
    const e = [];
    for (const s of this.selection) {
      const i = s.mesh.geometry, { area: n, perimeter: r } = s, o = i.attributes.position.array;
      e.push({ position: o, area: n, perimeter: r });
    }
    return e;
  }
  /**
   * Sets the state of the AreaMeasurement component from a serialized format.
   * This method is used for loading measurements.
   *
   * @param serialized - An array of SerializedAreaMeasure objects,
   * each representing a single selection made by the user.
   *
   * @throws Will throw an error if no world is given to the face measurement.
   */
  set(e) {
    if (!this.world)
      throw new Error("No world given to the face measurement!");
    const s = this.world.scene.three;
    for (const i of e) {
      const n = new A.BufferGeometry(), r = new A.Mesh(n, this.selectionMaterial);
      s.add(r);
      const o = new A.BufferAttribute(i.position, 3);
      n.setAttribute("position", o), n.computeBoundingSphere();
      const { area: a, perimeter: c } = i, h = this.newLabel(n, a);
      r.add(h.three), this.selection.push({ area: a, perimeter: c, mesh: r, label: h });
    }
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the face measurement needs a renderer!");
    const i = this.world.renderer.three.domElement.parentElement;
    i.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown), e && (i.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown));
  }
  setVisibility(e) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    const s = this.world.scene.three;
    for (const i of this.selection) {
      const n = i.label.three;
      e ? (s.add(i.mesh), i.mesh.add(n)) : (i.mesh.removeFromParent(), n.removeFromParent());
    }
  }
  unselect() {
    this.preview.removeFromParent(), this._currentSelelection = null;
  }
  updateSelection(e, s, i) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    this.world.scene.three.add(this.preview);
    const o = this.components.get(hs).getFace(e, s, i);
    if (o === null)
      return;
    const a = this.regenerateHighlight(e, o.indices, i);
    let c = 0;
    for (const { distance: h } of o.edges)
      c += h;
    this._currentSelelection = { perimeter: c, area: a };
  }
  newLabel(e, s) {
    if (!e.boundingSphere)
      throw new Error("Error computing area geometry");
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    const { center: i } = e.boundingSphere, n = $t(), r = Math.trunc(s * 100) / 100;
    n.textContent = r.toString();
    const o = new Ke(this.world, n);
    return o.three.position.copy(i), o;
  }
  regenerateHighlight(e, s, i) {
    const n = [], r = [];
    let o = 0, a = 0;
    const c = new A.Triangle(), h = this.components.get(hs);
    for (const d of s) {
      const { p1: p, p2: m, p3: E } = h.getVerticesAndNormal(
        e,
        d,
        i
      );
      n.push(p.x, p.y, p.z), n.push(m.x, m.y, m.z), n.push(E.x, E.y, E.z), c.set(p, m, E), a += c.getArea(), r.push(o, o + 1, o + 2), o += 3;
    }
    this.preview.position.set(0, 0, 0), this.preview.rotation.set(0, 0, 0), this.preview.scale.set(1, 1, 1), this.preview.updateMatrix(), this.preview.applyMatrix4(e.matrixWorld);
    const f = new Float32Array(n), u = new A.BufferAttribute(f, 3);
    return this.preview.geometry.setAttribute("position", u), this.preview.geometry.setIndex(r), a;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(bn, "uuid", "30279548-1309-44f6-aa97-ce26eed73522");
let _a = bn;
const Dn = class Dn extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * A reference to the preview dimension line.
     * This line is used to visualize the measurement while creating it.
     */
    w(this, "preview");
    /**
     * The tolerance value for edge selection.
     * This value determines the maximum distance from the mouse cursor to an edge for it to be selected.
     */
    w(this, "tolerance", 0.3);
    /**
     * The world in which the measurements are performed.
     */
    w(this, "world");
    w(this, "_enabled", !1);
    w(this, "_lineMaterial", new A.LineBasicMaterial({
      color: "#DC2626",
      linewidth: 2,
      depthTest: !1,
      transparent: !0
    }));
    /** {@link OBC.Createable.create} */
    w(this, "create", async () => {
      if (!this.preview || !this.enabled || !this.preview.visible)
        return;
      const e = this.components.get(as);
      e.world = this.world;
      const s = this.preview.startPoint.clone(), i = this.preview.endPoint.clone();
      e.createOnPoints(s, i);
    });
    w(this, "onMouseMove", () => {
      if (!this.preview)
        return;
      if (!this.world)
        throw new Error("The edge measurement needs a world to work!");
      if (!this.enabled) {
        this.preview.visible = !1;
        return;
      }
      const i = this.components.get(ct).get(this.world).castRay();
      if (!i || !i.object) {
        this.preview.visible = !1;
        return;
      }
      const { object: n, faceIndex: r, point: o } = i;
      if (r === void 0) {
        this.preview.visible = !1;
        return;
      }
      n instanceof A.Mesh || n instanceof A.InstancedMesh ? this.updateSelection(n, o, r, i.instanceId) : this.preview.visible = !1;
    });
    w(this, "onKeydown", (e) => {
    });
    this.components.add(Dn.uuid, this);
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    if (this._enabled = e, this.setupEvents(e), e) {
      if (!this.world)
        throw new Error("The edge measurement needs a world to work!");
      if (!this.preview) {
        const s = document.createElement("div");
        s.className = "w-2 h-2 bg-red-600 rounded-full", this.preview = new Ai(this.components, this.world, {
          start: new A.Vector3(),
          end: new A.Vector3(),
          lineMaterial: this._lineMaterial,
          endpointElement: s
        }), this.preview.visible = !1;
      }
    } else
      this.cancelCreation();
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.preview && this.preview.dispose(), this._lineMaterial.dispose(), this.setupEvents(!1), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  // TODO: this could be better. Fusion this class with lengthmeasurement?
  /** {@link OBC.Createable.delete} */
  delete() {
    if (!this.enabled)
      return;
    const e = this.components.get(as), s = e.enabled;
    e.enabled = !0, e.delete(), e.enabled = s;
  }
  /**
   * Deletes all the measurements created by the EdgeMeasurement component.
   */
  deleteAll() {
    this.components.get(as).deleteAll();
  }
  /** {@link OBC.Createable.endCreation} */
  endCreation() {
  }
  /** {@link OBC.Createable.cancelCreation} */
  cancelCreation() {
  }
  /**
   * Retrieves the current state of the measurements created by the EdgeMeasurement component.
   * The state is serialized as an array of arrays, where each inner array represents a line measurement.
   * Each line measurement is represented by six numbers: the x, y, and z coordinates of the start and end points.
   */
  get() {
    const s = this.components.get(as).list, i = [];
    for (const n of s) {
      const r = n.startPoint, o = n.endPoint, a = [r.x, r.y, r.z, o.x, o.y, o.z];
      i.push(a);
    }
    return i;
  }
  /**
   * Sets the state of the measurements created by the EdgeMeasurement component.
   * The state is serialized as an array of arrays, where each inner array represents a line measurement.
   * Each line measurement is represented by six numbers: the x, y, and z coordinates of the start and end points.
   *
   * @param dimensions - The serialized state of the measurements.
   * Each inner array should contain six numbers representing the x, y, and z coordinates of the start and end points of a line measurement.
   *
   */
  set(e) {
    const s = this.components.get(as);
    s.world = this.world;
    for (const i of e) {
      const [n, r, o, a, c, h] = i, f = new A.Vector3(n, r, o), u = new A.Vector3(a, c, h);
      s.createOnPoints(f, u);
    }
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The edge measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the edge measurement needs a renderer!");
    const i = this.world.renderer.three.domElement.parentElement;
    e ? (i.addEventListener("pointermove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (i.removeEventListener("pointermove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
  updateSelection(e, s, i, n) {
    if (!this.preview || !e.geometry.index)
      return;
    const o = this.components.get(hs).getFace(e, i, n);
    if (!o)
      return;
    const { edges: a } = o;
    let c = Number.MAX_VALUE, h = [];
    for (const d of a) {
      const [p, m] = d.points, E = hs.distanceFromPointToLine(
        s,
        p,
        m,
        !0
      );
      E < this.tolerance && E < c && (c = E, h = d.points);
    }
    if (!h.length) {
      this.preview.visible = !1;
      return;
    }
    const [f, u] = h;
    this.preview.startPoint = f, this.preview.endPoint = u, this.preview.visible = !0;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Dn, "uuid", "e7be5749-89df-4514-8d25-83aa38ce12d8");
let Ua = Dn;
class Wp extends ul {
  constructor(e, s) {
    super(e, s);
    /* Pixels in screen a geometry must occupy to be considered "seen". */
    w(this, "threshold", 50);
    w(this, "bboxThreshold", 200);
    w(this, "maxLostTime", 3e4);
    w(this, "maxHiddenTime", 5e3);
    w(this, "boxes", /* @__PURE__ */ new Map());
    w(this, "_staticGeometries", { culled: {}, unculled: {} });
    w(this, "_geometry");
    w(this, "_material", new A.MeshBasicMaterial({
      transparent: !0,
      side: 2,
      opacity: 1
    }));
    w(this, "onViewUpdated", new bt());
    w(this, "_modelIDIndex", /* @__PURE__ */ new Map());
    w(this, "_indexModelID", /* @__PURE__ */ new Map());
    w(this, "_nextModelID", 0);
    w(this, "_geometries", /* @__PURE__ */ new Map());
    w(this, "_geometriesGroups", /* @__PURE__ */ new Map());
    w(this, "_geometriesInMemory", /* @__PURE__ */ new Set());
    w(this, "_intervalID", null);
    w(this, "codes", /* @__PURE__ */ new Map());
    w(this, "handleWorkerMessage", async (e) => {
      const s = e.data.colors, i = {}, n = {}, r = {}, o = {}, a = performance.now();
      let c = !1;
      const h = new Set(this._geometriesInMemory);
      for (const [f, u] of s) {
        const d = this._geometries.get(f);
        if (!d || !(u > this.threshold))
          continue;
        h.delete(f);
        const { exists: m } = d, E = this._indexModelID.get(d.modelIndex);
        m ? (d.time = a, o[E] || (o[E] = /* @__PURE__ */ new Set()), o[E].add(d.geometryID), this._geometriesInMemory.add(f), c = !0) : (i[E] || (i[E] = /* @__PURE__ */ new Map()), d.time = a, d.exists = !0, i[E].has(u) || i[E].set(u, /* @__PURE__ */ new Set()), i[E].get(u).add(d.geometryID), this._geometriesInMemory.add(f), c = !0);
      }
      for (const f of h) {
        const u = this._geometries.get(f);
        u && (this.handleLostGeometries(a, f, u, n, r), c = !0);
      }
      c && await this.onViewUpdated.trigger({ toLoad: i, toRemove: n, toHide: r, toShow: o }), this._isWorkerBusy = !1;
    });
    this.config.updateInterval = 500, this._geometry = new A.BoxGeometry(1, 1, 1), this._geometry.groups = [], this._geometry.deleteAttribute("uv");
    const i = this._geometry.attributes.position.array;
    for (let n = 0; n < i.length; n++)
      i[n] += 0.5;
    this._geometry.attributes.position.needsUpdate = !0, this.worker.addEventListener("message", this.handleWorkerMessage);
  }
  dispose() {
    super.dispose(), this.onViewUpdated.reset(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null);
    for (const [e, s] of this._geometriesGroups) {
      s.removeFromParent();
      const i = [...s.children];
      for (const n of i)
        n.removeFromParent();
    }
    this._geometriesGroups.clear();
    for (const [e, s] of this.boxes)
      s.dispose(!0);
    this.boxes.clear();
    for (const [e, s] of this._geometries)
      s.fragment && (s.fragment.dispose(!0), s.fragment = void 0);
    this._geometries.clear(), this._staticGeometries = { culled: {}, unculled: {} }, this._geometry.dispose(), this._material.dispose(), this._modelIDIndex.clear(), this._indexModelID.clear(), this.codes.clear();
  }
  add(e, s, i) {
    const n = this.createModelIndex(e), r = A.ColorManagement.enabled;
    A.ColorManagement.enabled = !1;
    const o = /* @__PURE__ */ new Map(), a = new A.Matrix4(), c = new Pe.Fragment(this._geometry, this._material, 10);
    this.boxes.set(n, c), this.scene.add(c.mesh);
    const h = new A.Group();
    this.scene.add(h), this._geometriesGroups.set(n, h);
    const f = /* @__PURE__ */ new Map();
    for (const d of s)
      for (const p of d.geometries) {
        const { geometryID: m, transformation: E, color: I } = p, g = new A.Color();
        g.setRGB(I[0], I[1], I[2], "srgb");
        const T = this.getInstanceID(d.id, m), C = i[m];
        if (!C) {
          console.log(`Geometry not found: ${m}`);
          continue;
        }
        const { boundingBox: F } = C;
        let O;
        o.has(m) ? O = o.get(m) : (O = this.getAvailableColor(), this.increaseColor(), o.set(m, O));
        const { r: P, g: M, b: L, code: b } = O, B = new A.Color();
        B.setRGB(P / 255, M / 255, L / 255, "srgb"), this.codes.has(n) || this.codes.set(n, /* @__PURE__ */ new Map()), this.codes.get(n).set(m, b);
        const D = new A.Matrix4(), R = Object.values(F);
        if (D.fromArray(E), a.fromArray(R), D.multiply(a), f.has(T)) {
          const _ = f.get(T);
          if (_ === void 0 || !_.colors)
            throw new Error("Malformed item!");
          _.colors.push(B), _.geometryColors.push(g), _.transforms.push(D);
        } else
          f.set(T, {
            id: T,
            colors: [B],
            geometryColors: [g],
            transforms: [D]
          });
        if (this._geometries.has(b))
          this._geometries.get(b).assetIDs.add(d.id);
        else {
          const _ = /* @__PURE__ */ new Set([d.id]);
          this._geometries.set(b, {
            modelIndex: n,
            geometryID: m,
            assetIDs: _,
            exists: !1,
            hidden: !1,
            time: 0
          });
        }
      }
    const u = Array.from(f.values());
    c.add(u), A.ColorManagement.enabled = r;
  }
  remove(e) {
    const s = this._modelIDIndex.get(e);
    if (s === void 0)
      throw new Error("Model doesn't exist!");
    const i = this._geometriesGroups.get(s);
    i.removeFromParent();
    const n = [...i.children];
    for (const a of n)
      a.removeFromParent();
    this._geometriesGroups.delete(s), this.boxes.get(s).dispose(!1), this.boxes.delete(s);
    const o = this.codes.get(s);
    this.codes.delete(s);
    for (const [a, c] of o) {
      const h = this._geometries.get(c);
      h && h.fragment && (h.fragment.dispose(!1), h.fragment = void 0), this._geometries.delete(c);
    }
    this._modelIDIndex.delete(e), this._indexModelID.delete(s), this._geometriesInMemory.clear();
  }
  addFragment(e, s, i) {
    const n = A.ColorManagement.enabled;
    A.ColorManagement.enabled = !1;
    const r = this._modelIDIndex.get(e), a = this.codes.get(r).get(s), c = this._geometries.get(a);
    if (this.setGeometryVisibility(c, !1, !1), !c.fragment) {
      c.fragment = new Pe.Fragment(
        i.mesh.geometry,
        this._material,
        i.capacity
      );
      const p = this._geometriesGroups.get(r);
      if (!p)
        throw new Error("Group not found!");
      p.add(c.fragment.mesh);
    }
    const [h, f, u] = a.split("-").map((p) => parseInt(p, 10)), d = [];
    for (const p of i.ids) {
      const m = i.get(p);
      if (!m.colors)
        throw new Error("Malformed fragments!");
      for (const E of m.colors)
        E.setRGB(h / 255, f / 255, u / 255, "srgb");
      d.push(m);
    }
    c.fragment.add(d), A.ColorManagement.enabled = n, this.needsUpdate = !0;
  }
  removeFragment(e, s) {
    const i = this._modelIDIndex.get(e), r = this.codes.get(i).get(s), o = this._geometries.get(r);
    if (o.hidden || this.setGeometryVisibility(o, !0, !1), o.fragment) {
      const { fragment: a } = o;
      a.dispose(!1), o.fragment = void 0;
    }
  }
  // TODO: Is this neccesary anymore?
  setModelTransformation(e, s) {
    const i = this._modelIDIndex.get(e);
    if (i === void 0)
      throw new Error("Model not found!");
    const n = this.boxes.get(i);
    n && (n.mesh.position.set(0, 0, 0), n.mesh.rotation.set(0, 0, 0), n.mesh.scale.set(1, 1, 1), n.mesh.applyMatrix4(s));
    const r = this._geometriesGroups.get(i);
    r && (r.position.set(0, 0, 0), r.rotation.set(0, 0, 0), r.scale.set(1, 1, 1), r.applyMatrix4(s));
  }
  setVisibility(e, s, i) {
    const n = this._modelIDIndex.get(s);
    if (n !== void 0)
      for (const [r, o] of i) {
        const a = this.codes.get(n);
        if (a === void 0)
          throw new Error("Map not found!");
        const c = a.get(r), h = this._geometries.get(c);
        if (h === void 0)
          throw new Error("Geometry not found!");
        h.hidden = !e, this.setGeometryVisibility(h, e, !0, o);
      }
  }
  updateTransformations(e) {
    const s = this._modelIDIndex.get(e);
    if (s === void 0)
      return;
    const n = this.components.get(fe).groups.get(e);
    if (n) {
      n.updateWorldMatrix(!0, !1), n.updateMatrix();
      const r = this.boxes.get(s);
      r && (r.mesh.position.set(0, 0, 0), r.mesh.rotation.set(0, 0, 0), r.mesh.scale.set(1, 1, 1), r.mesh.updateMatrix(), r.mesh.applyMatrix4(n.matrixWorld), r.mesh.updateMatrix());
      const o = this._geometriesGroups.get(s);
      o && (o.position.set(0, 0, 0), o.rotation.set(0, 0, 0), o.scale.set(1, 1, 1), o.updateMatrix(), o.applyMatrix4(n.matrixWorld), o.updateMatrix());
    }
  }
  async addStaticGeometries(e, s = !0) {
    const i = {
      data: {
        colors: /* @__PURE__ */ new Map()
      }
    }, n = this.threshold + 1e3;
    for (const r in e) {
      const o = this._modelIDIndex.get(r);
      if (o === void 0)
        continue;
      const a = this.codes.get(o);
      if (!a)
        continue;
      const c = e[r];
      for (const h of c) {
        const f = a.get(h);
        if (!f)
          continue;
        const u = this._geometries.get(f);
        if (!u)
          continue;
        u.exists = !0, s || (u.hidden = !1, u.time = performance.now(), i.data.colors.set(f, n)), this._geometriesInMemory.add(f);
        const d = s ? this._staticGeometries.culled : this._staticGeometries.unculled;
        d[r] || (d[r] = /* @__PURE__ */ new Set()), d[r].add(h);
      }
    }
    s || await this.handleWorkerMessage(i);
  }
  removeStaticGeometries(e, s) {
    const i = [];
    s === void 0 ? i.push("culled", "unculled") : s === !0 ? i.push("culled") : i.push("unculled");
    for (const n in e) {
      const r = e[n];
      for (const o of i) {
        const a = this._staticGeometries[o][n];
        if (a)
          for (const c of r)
            a.delete(c);
      }
    }
  }
  cancel(e) {
    for (const s in e) {
      const i = this._modelIDIndex.get(s);
      if (i === void 0)
        throw new Error("Model not found.");
      const n = this.codes.get(i);
      if (n === void 0)
        throw new Error("Codes not found.");
      for (const r of e[s]) {
        const o = n.get(r);
        if (o === void 0)
          throw new Error("Color code not found.");
        this._geometriesInMemory.delete(o);
        const a = this._geometries.get(o);
        if (!a)
          throw new Error("Geometry not found.");
        a.exists = !1;
      }
    }
  }
  getBoundingBoxes(e) {
    const s = new Pe.FragmentsGroup();
    for (const i in e) {
      const n = e[i], r = this._modelIDIndex.get(i);
      if (r === void 0)
        continue;
      const o = this.boxes.get(r);
      if (!o)
        continue;
      const a = o.clone(n);
      s.add(a.mesh), s.items.push(a);
    }
    return s;
  }
  getInstanceID(e, s) {
    const n = 10 ** (Math.log(s) * Math.LOG10E + 1 | 0);
    return e + s / n;
  }
  setGeometryVisibility(e, s, i, n) {
    const { modelIndex: r, geometryID: o, assetIDs: a } = e, c = this.boxes.get(r);
    if (c === void 0)
      throw new Error("Model not found!");
    const h = n || a;
    if (i && e.fragment)
      e.fragment.setVisibility(s, h);
    else {
      const f = /* @__PURE__ */ new Set();
      for (const u of h) {
        const d = this.getInstanceID(u, o);
        f.add(d);
      }
      c.setVisibility(s, f);
    }
  }
  handleLostGeometries(e, s, i, n, r) {
    var f, u, d;
    const o = this._indexModelID.get(i.modelIndex), a = e - i.time, { culled: c, unculled: h } = this._staticGeometries;
    if (a > this.maxLostTime) {
      if ((f = c[o]) != null && f.has(i.geometryID) || (u = h[o]) != null && u.has(i.geometryID))
        return;
      n[o] || (n[o] = /* @__PURE__ */ new Set()), i.exists = !1, n[o].add(i.geometryID), this._geometriesInMemory.delete(s);
    } else if (a > this.maxHiddenTime) {
      if ((d = h[o]) != null && d.has(i.geometryID))
        return;
      r[o] || (r[o] = /* @__PURE__ */ new Set()), r[o].add(i.geometryID);
    }
  }
  createModelIndex(e) {
    if (this._modelIDIndex.has(e))
      throw new Error("Can't load the same model twice!");
    const s = this._nextModelID;
    return this._nextModelID++, this._modelIDIndex.set(e, s), this._indexModelID.set(s, e), s;
  }
}
const mi = class mi extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /**
     * Event triggered when fragments are deleted.
     */
    w(this, "onFragmentsDeleted", new Y());
    /**
     * Event triggered when fragments are loaded.
     */
    w(this, "onFragmentsLoaded", new Y());
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * The data of the streamed models. It defines the geometries, their instances, its bounding box (OBB) and the assets to which they belong.
     */
    w(this, "models", {});
    /**
     * Importer of binary IFC data previously converted to fragment tiles.
     */
    w(this, "serializer", new Pe.StreamSerializer());
    /**
     * Maximum time in milliseconds for a geometry to stay in the RAM cache.
     */
    w(this, "maxRamTime", 5e3);
    /**
     * Flag indicating whether to use the local cache for storing geometry files.
     */
    w(this, "useCache", !0);
    /**
     * Flag to cancel the files that are being currently loaded.
     */
    w(this, "cancel", !1);
    /**
     * The URL of the data source for the streaming service.
     * It should be set before using the streaming service. Alternatively, you can use a custom fetch function.
     */
    w(this, "url", "");
    /**
     * Function used to retrieve tiles. Can be overriden to work with specific backends.
     */
    w(this, "fetch", async (e) => fetch(this.url + e));
    /**
     * Cache system that uses the File System API.
     */
    w(this, "fileDB", new Pe.StreamerFileDb("that-open-company-streaming"));
    w(this, "_culler", null);
    w(this, "_world", null);
    w(this, "_ramCache", /* @__PURE__ */ new Map());
    w(this, "_isDisposing", !1);
    w(this, "_geometryInstances", {});
    w(this, "_loadedFragments", {});
    w(this, "fragIDData", /* @__PURE__ */ new Map());
    w(this, "_baseMaterial", new A.MeshLambertMaterial());
    w(this, "_baseMaterialT", new A.MeshLambertMaterial({
      transparent: !0,
      opacity: 0.5
    }));
    w(this, "disposeStreamedGroup", (e) => {
      this._isDisposing = !0;
      const { groupID: s, fragmentIDs: i } = e;
      if (this.models[s]) {
        delete this.models[s], delete this._geometryInstances[s], delete this._loadedFragments[s];
        for (const n of i)
          this.fragIDData.delete(n);
        this.culler.remove(s), this._isDisposing = !1;
      }
    });
    this.components.add(mi.uuid, this), this.components.get(fe).onFragmentsDisposed.add(this.disposeStreamedGroup), Pe.FragmentsGroup.setPropertiesDB(!0);
  }
  /**
   * The world in which the fragments will be displayed.
   * It must be set before using the streaming service.
   * If not set, an error will be thrown when trying to access the world.
   */
  get world() {
    if (!this._world)
      throw new Error("You must set a world before using the streamer!");
    return this._world;
  }
  /**
   * Sets the world in which the fragments will be displayed.
   * @param world - The new world to be set.
   */
  set world(e) {
    var s;
    this._world = e, (s = this._culler) == null || s.dispose(), this._culler = new Wp(this.components, e), this._culler.onViewUpdated.add(
      async ({ toLoad: i, toRemove: n, toShow: r, toHide: o }) => {
        await this.loadFoundGeometries(i), await this.unloadLostGeometries(n), this.setMeshVisibility(r, !0), this.setMeshVisibility(o, !1);
      }
    );
  }
  /**
   * The culler used for managing and rendering the fragments.
   * It is automatically created when the world is set.
   */
  get culler() {
    if (!this._culler)
      throw new Error("You must set a world before using the streamer!");
    return this._culler;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    var s;
    this._isDisposing = !0, this.onFragmentsLoaded.reset(), this.onFragmentsDeleted.reset(), this._ramCache.clear(), this.components.get(fe).onFragmentsDisposed.remove(this.disposeStreamedGroup), this.models = {}, this._geometryInstances = {}, this._loadedFragments = {}, this.fragIDData.clear(), this._baseMaterial.dispose(), this._baseMaterialT.dispose(), (s = this._culler) == null || s.dispose(), this.onDisposed.trigger(mi.uuid), this.onDisposed.reset(), this._isDisposing = !1, Pe.FragmentsGroup.setPropertiesDB(!1);
  }
  /**
   * Loads a new fragment group into the scene using streaming.
   *
   * @param settings - The settings for the new fragment group.
   * @param coordinate - Whether to federate this model with the rest.
   * @param properties - Optional properties for the new fragment group.
   * @returns The newly loaded fragment group.
   */
  async load(e, s, i) {
    const { assets: n, geometries: r, globalDataFileId: o } = e, c = await (await this.fetch(o)).arrayBuffer(), h = new Uint8Array(c), u = this.components.get(fe).load(h, { coordinate: s, isStreamed: !0 });
    u.name = o.replace("-processed-global", ""), this.world.scene.three.add(u);
    const { opaque: d, transparent: p } = u.geometryIDs;
    for (const [g, T] of d) {
      const C = u.keyFragments.get(T);
      if (C === void 0)
        throw new Error("Malformed fragments group!");
      this.fragIDData.set(C, [u, g, /* @__PURE__ */ new Set()]);
    }
    for (const [g, T] of p) {
      const C = u.keyFragments.get(T);
      if (C === void 0)
        throw new Error("Malformed fragments group!");
      this.fragIDData.set(C, [u, Math.abs(g), /* @__PURE__ */ new Set()]);
    }
    this.culler.add(u.uuid, n, r);
    const m = /* @__PURE__ */ new Map();
    for (const g of n)
      m.set(g.id, g);
    const E = { assetsMap: m, geometries: r };
    Object.defineProperty(E, "assets", {
      get: () => Array.from(E.assetsMap.values())
    }), this.models[u.uuid] = E;
    const I = /* @__PURE__ */ new Map();
    for (const g of n) {
      const T = g.id;
      for (const { transformation: C, geometryID: F, color: O } of g.geometries) {
        I.has(F) || I.set(F, []);
        const P = I.get(F);
        if (!P)
          throw new Error("Malformed instances");
        P.push({ id: T, transformation: C, color: O });
      }
    }
    if (this._geometryInstances[u.uuid] = I, i) {
      const g = /* @__PURE__ */ new Map(), T = /* @__PURE__ */ new Map();
      for (const L in i.ids) {
        const b = i.ids[L], B = parseInt(L, 10);
        g.set(B, b);
      }
      for (const L in i.types) {
        const b = i.types[L], B = parseInt(L, 10);
        T.set(B, b);
      }
      const C = o.replace(
        "-global",
        "-properties"
      );
      Pe.FragmentsGroup.url = this.url, u.streamSettings = {
        baseFileName: C,
        ids: g,
        types: T
      };
      const { indexesFile: F } = i, P = await (await this.fetch(F)).text(), M = this.components.get(et);
      M.setRelationMap(u, M.getRelationsMapFromJSON(P));
    }
    return this.culler.updateTransformations(u.uuid), this.culler.needsUpdate = !0, u;
  }
  /**
   * Removes a fragment group from the scene.
   *
   * @param modelID - The unique identifier of the fragment group to remove.
   *
   * @deprecated use OBC.FragmentsManager.disposeGroup instead.
   */
  remove(e) {
    const s = this.components.get(fe), i = s.groups.get(e);
    i && s.disposeGroup(i);
  }
  /**
   * Sets the visibility of items in fragments based on the provided filter.
   *
   * @param visible - The visibility state to set.
   * @param filter - A map of fragment IDs to arrays of item IDs.
   *                  Only items with IDs present in the arrays will be visible.
   *                  If not provided, it will take all loaded models as filter.
   */
  setVisibility(e, s) {
    const i = /* @__PURE__ */ new Map();
    if (!s) {
      const n = this.components.get(fe), r = {};
      for (const [, o] of n.groups) {
        const a = o.getFragmentMap();
        for (const c in a)
          r[c] = a[c];
      }
      s = r;
    }
    for (const n in s) {
      const r = this.fragIDData.get(n);
      if (r === void 0)
        throw new Error("Geometry not found!");
      const [o, a, c] = r, h = o.uuid;
      i.has(h) || i.set(h, /* @__PURE__ */ new Map());
      const f = i.get(h), u = s[n];
      for (const p of u)
        e ? c.delete(p) : c.add(p);
      f.get(a) || f.set(a, /* @__PURE__ */ new Set());
      const d = f.get(a);
      for (const p of u)
        d.add(p);
    }
    for (const [n, r] of i) {
      this.culler.setVisibility(e, n, r);
      for (const [o] of r) {
        const a = this._loadedFragments[n];
        if (!a)
          continue;
        const c = a[o];
        if (c)
          for (const h of c) {
            const f = s[h.id];
            f && h.setVisibility(e, f);
          }
      }
    }
    this.culler.needsUpdate = !0;
  }
  /**
   * Clears the local cache used for storing downloaded fragment files.
   *
   * @returns A Promise that resolves when the cache is cleared.
   */
  async clearCache() {
    await this.fileDB.clear();
  }
  /**
   * Sets or unsets the specified fragments as static. Static fragments are streamed once and then kept in memory.
   *
   * @param ids - The list of fragment IDs to make static.
   * @param active - Whether these items should be static or not.
   * @param culled - Whether these items should be culled or not. If undefined: active=true will set items as culled, while active=false will remove items from both the culled and unculled list.
   */
  async setStatic(e, s, i) {
    const n = {};
    for (const r of e) {
      const o = this.fragIDData.get(r);
      if (!o) {
        console.log(`Item not found: ${r}.`);
        continue;
      }
      const [a, c] = o, h = a.uuid;
      n[h] || (n[h] = /* @__PURE__ */ new Set()), n[h].add(c);
    }
    if (s) {
      const r = {};
      for (const o in n) {
        const a = /* @__PURE__ */ new Map();
        a.set(1, n[o]), r[o] = a;
      }
      await this.loadFoundGeometries(r, !1), await this.culler.addStaticGeometries(n, i);
    } else
      this.culler.removeStaticGeometries(n, i);
  }
  /**
   * Gets a FragmentsGroup with the OBB of the specified items. Keep in mind that you will need to dispose this group yourself using the dispose(false) method (geometry is shared with bounding boxes used for visibility check).
   *
   * @param items - The items whose bounding boxes to get.
   */
  getBoundingBoxes(e) {
    const s = {}, i = this.components.get(fe), n = /* @__PURE__ */ new Map();
    for (const [o, a] of i.groups)
      for (const [, c] of a.keyFragments)
        n.set(c, o);
    const r = /* @__PURE__ */ new Set();
    for (const o in e) {
      const a = n.get(o);
      if (a === void 0) {
        console.log("Fragment group not found!");
        continue;
      }
      const c = e[o];
      r.has(a) || (s[a] = /* @__PURE__ */ new Set(), r.add(a));
      for (const h of c) {
        const f = this.models[a].assetsMap.get(h);
        if (f)
          for (const u of f.geometries) {
            const d = u.geometryID, p = this.culler.getInstanceID(h, d);
            s[a].add(p);
          }
      }
    }
    return this.culler.getBoundingBoxes(s);
  }
  async loadFoundGeometries(e, s = !0) {
    this.cancel = !1;
    const i = {};
    for (const n in e) {
      const r = /* @__PURE__ */ new Set();
      for (const [, o] of e[n])
        for (const a of o)
          r.add(a);
      i[n] = r;
    }
    for (const n in e) {
      if (this._isDisposing)
        return;
      if (this.cancel) {
        this.cancelLoading(i);
        return;
      }
      const o = this.components.get(fe).groups.get(n);
      if (!o)
        return;
      const { geometries: a } = this.models[n], c = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Set();
      for (const [m, E] of e[n])
        for (const I of E) {
          if (this.cancel) {
            this.cancelLoading(i);
            return;
          }
          h.add(I);
          const g = a[I];
          if (!g)
            throw new Error("Geometry not found");
          if (g.geometryFile) {
            const T = g.geometryFile, C = c.get(T) || 0;
            c.set(T, C + m);
          }
        }
      if (this.useCache) {
        const E = c.entries();
        for (const [I, g] of E)
          this.fileDB.isCached(I) && c.set(I, g + 99999);
      }
      const f = Array.from(c).sort((m, E) => E[1] - m[1]), u = [];
      for (const [m] of f) {
        const E = this.loadFragmentFile(
          n,
          o,
          s,
          m,
          h,
          i
        );
        u.push(E);
      }
      await Promise.all(u);
      const d = /* @__PURE__ */ new Set(), p = performance.now();
      for (const [m, { time: E }] of this._ramCache)
        p - E > this.maxRamTime && d.add(m);
      for (const m of d)
        this._ramCache.delete(m);
    }
  }
  async unloadLostGeometries(e) {
    if (this._isDisposing)
      return;
    const s = [], i = this.components.get(fe);
    for (const n in e) {
      const r = i.groups.get(n);
      if (!r)
        throw new Error("Fragment group not found!");
      if (!this._loadedFragments[n])
        continue;
      const o = this._loadedFragments[n], a = e[n];
      for (const c of a) {
        if (this.culler.removeFragment(r.uuid, c), !o[c])
          continue;
        const h = o[c];
        for (const f of h)
          r.items.splice(r.items.indexOf(f), 1), s.push(f);
        delete o[c];
      }
    }
    s.length && this.onFragmentsDeleted.trigger(s);
    for (const n of s)
      i.list.delete(n.id), this.world.meshes.delete(n.mesh), n.mesh.material = [], n.dispose(!0);
  }
  setMeshVisibility(e, s) {
    for (const i in e)
      for (const n of e[i]) {
        const r = this._loadedFragments[i];
        if (!r)
          continue;
        const o = r[n];
        if (o)
          for (const a of o)
            a.mesh.visible = s;
      }
  }
  newFragment(e, s, i, n, r, o, a) {
    if (n.length === 0 || this._isDisposing)
      return;
    const c = e.geometryIDs, h = r ? c.transparent : c.opaque, u = s * (r ? -1 : 1), d = h.get(u);
    if (d === void 0)
      return;
    const p = e.keyFragments.get(d);
    if (p === void 0)
      return;
    const m = this.components.get(fe);
    if (m.list.has(p))
      return;
    const I = r ? this._baseMaterialT : this._baseMaterial, g = new Pe.Fragment(i, I, n.length);
    g.mesh.visible = a, g.id = p, g.mesh.uuid = p, g.group = e, e.add(g.mesh), e.items.push(g), m.list.set(g.id, g), this.world.meshes.add(g.mesh), this._loadedFragments[e.uuid] || (this._loadedFragments[e.uuid] = {});
    const T = this._loadedFragments[e.uuid];
    T[s] || (T[s] = []), T[s].push(g);
    const C = /* @__PURE__ */ new Map();
    for (let M = 0; M < n.length; M++) {
      const L = new A.Matrix4(), b = new A.Color(), { id: B, transformation: v, color: D } = n[M];
      L.fromArray(v);
      const [R, _, K] = D;
      if (b.setRGB(R, _, K, "srgb"), C.has(B)) {
        const U = C.get(B);
        if (!U)
          continue;
        U.transforms.push(L), U.colors && U.colors.push(b);
      } else
        C.set(B, { id: B, colors: [b], transforms: [L] });
    }
    const F = Array.from(C.values());
    g.add(F);
    const O = this.fragIDData.get(g.id);
    if (!O)
      throw new Error("Fragment data not found!");
    const P = O[2];
    P.size && g.setVisibility(!1, P), this.culler.addFragment(e.uuid, s, g), o.push(g);
  }
  cancelLoading(e) {
    this.cancel = !1, this.culler.cancel(e);
  }
  async loadFragmentFile(e, s, i, n, r, o) {
    if (!this._ramCache.has(n)) {
      let h = new Uint8Array();
      if (this.useCache) {
        const u = await this.fileDB.get(n);
        if (u) {
          const d = await u.arrayBuffer();
          h = new Uint8Array(d);
        } else {
          const p = await (await this.fetch(n)).arrayBuffer();
          h = new Uint8Array(p), await this.fileDB.add(n, h);
        }
      } else {
        const d = await (await this.fetch(n)).arrayBuffer();
        h = new Uint8Array(d);
      }
      const f = this.serializer.import(h);
      this._ramCache.set(n, { data: f, time: performance.now() });
    }
    const a = this._ramCache.get(n);
    if (!a)
      return;
    a.time = performance.now();
    const c = [];
    if (a)
      for (const [h, { position: f, index: u, normal: d }] of a.data) {
        if (this._isDisposing)
          return;
        if (this.cancel) {
          this.cancelLoading(o);
          return;
        }
        if (o[e].delete(h), !r.has(h) || !this._geometryInstances[e] || !this._geometryInstances[e].has(h))
          continue;
        const m = this._geometryInstances[e].get(h);
        if (!m)
          throw new Error("Instances not found!");
        const E = new A.BufferGeometry(), I = new A.BufferAttribute(f, 3), g = new A.BufferAttribute(d, 3);
        E.setAttribute("position", I), E.setAttribute("normal", g), E.setIndex(Array.from(u));
        const T = [], C = [];
        for (const F of m)
          F.color[3] === 1 ? C.push(F) : T.push(F);
        this.newFragment(
          s,
          h,
          E,
          T,
          !0,
          c,
          i
        ), this.newFragment(
          s,
          h,
          E,
          C,
          !1,
          c,
          i
        );
      }
    c.length && !this._isDisposing && this.onFragmentsLoaded.trigger(c);
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(mi, "uuid", "22437e8d-9dbc-4b99-a04f-d2da280d50c8");
let Ba = mi;
class Xp {
  constructor() {
    w(this, "_meshes", /* @__PURE__ */ new Map());
  }
  /**
   * Highlights edges fill meshes based on selected fragments.
   */
  highlight(t, e, s, i) {
    if (!e.userData.indexFragmentMap || !e.geometry.index)
      return;
    const { userData: n } = e, r = n.indexFragmentMap, o = [], a = e.geometry.index.array;
    for (const [f, u] of r)
      for (const d in u)
        if (i[d]) {
          for (const p of u[d])
            if (i[d].has(p)) {
              const m = a[f * 3], E = a[f * 3 + 1], I = a[f * 3 + 2];
              o.push(m, E, I);
            }
        }
    this._meshes.has(t) || this._meshes.set(t, /* @__PURE__ */ new Map());
    const c = this._meshes.get(t);
    if (!c.has(e.uuid)) {
      const f = new A.MeshBasicMaterial({
        depthTest: !1,
        side: 2,
        color: s
      }), u = new A.BufferGeometry();
      u.attributes = e.geometry.attributes;
      const d = new A.Mesh(u, f);
      d.frustumCulled = !1, c.set(e.uuid, d);
    }
    const h = c.get(e.uuid);
    h.position.copy(e.position), e.parent && e.parent !== h.parent && e.parent.add(h), h.geometry.setIndex(o), h.material.color.copy(s);
  }
  /**
   * Clears the highlighted meshes for a specific style or all styles.
   *
   * @param name - The name of the style to clear. If not provided, clears all styles.
   *
   */
  clear(t) {
    for (const [e, s] of this._meshes)
      if (!(t && t !== e))
        for (const [i, n] of s)
          n.removeFromParent();
  }
  dispose() {
    for (const [t, e] of this._meshes)
      for (const [s, i] of e)
        i.removeFromParent(), i.geometry.attributes = {}, i.geometry.dispose(), i.material.dispose();
    this._meshes.clear();
  }
}
const Ii = class Ii extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** {@link OBC.Updateable.onBeforeUpdate} */
    w(this, "onBeforeUpdate", new Y());
    /** {@link OBC.Updateable.onAfterUpdate} */
    w(this, "onAfterUpdate", new Y());
    /** Event triggered when the Highlighter is setup. */
    w(this, "onSetup", new Y());
    /** Indicates whether the Highlighter is setup. */
    w(this, "isSetup", !1);
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !0);
    /** Stores the events triggered by the Highlighter. */
    w(this, "events", {});
    /** Determines the multiple selection behavior. */
    w(this, "multiple", "ctrlKey");
    /** Zoom factor applied when zooming to selection. */
    w(this, "zoomFactor", 1.5);
    /** Indicates whether to zoom to the selection when highlighting. */
    w(this, "zoomToSelection", !1);
    /** Stores the backup color before selection. */
    w(this, "backupColor", null);
    /** Stores the current selection. */
    w(this, "selection", {});
    /** Stores the configuration options for the Highlighter. */
    w(this, "config", {
      selectName: "select",
      hoverName: "hover",
      selectionColor: new A.Color("#BCF124"),
      hoverColor: new A.Color("#6528D7"),
      autoHighlightOnClick: !0,
      world: null,
      selectEnabled: !0,
      hoverEnabled: !0
    });
    /** Stores the colors used for highlighting selections. If null, the highlighter won't color geometries (useful for selection without coloring). */
    w(this, "colors", /* @__PURE__ */ new Map());
    /** Styles with auto toggle will be unselected when selected twice. */
    w(this, "autoToggle", /* @__PURE__ */ new Set());
    /** Position of the mouse on mouseDown. */
    w(this, "mouseDownPosition", { x: 0, y: 0 });
    /** Threshhold on how much the mouse have to move until its considered movement */
    w(this, "mouseMoveThreshold", 5);
    /** If defined, only the specified elements will be selected by the specified style. */
    w(this, "selectable", {});
    /** Manager to easily toggle and reset all events. */
    w(this, "eventManager", new jh());
    // Highlights the clipping fills of the fragments, if any
    w(this, "_fills", new Xp());
    w(this, "_mouseState", {
      down: !1,
      moved: !1
    });
    w(this, "_colorsBeforeSelect", {});
    w(this, "saveHighlightersBeforeSelect", (e) => {
      var i;
      const s = this.components.get(fe);
      for (const n in e) {
        const r = s.list.get(n);
        if (!r)
          continue;
        const o = (i = r.group) == null ? void 0 : i.uuid;
        if (o)
          for (const a in this.selection) {
            if (a === this.config.selectName || a === this.config.hoverName)
              continue;
            const c = this.selection[a][n];
            if (c) {
              a in this._colorsBeforeSelect || (this._colorsBeforeSelect[a] = {}), o in this._colorsBeforeSelect[a] || (this._colorsBeforeSelect[a] = { [o]: /* @__PURE__ */ new Set() });
              for (const h of c)
                this._colorsBeforeSelect[a][o].add(h);
            }
          }
      }
    });
    w(this, "restoreHighlightersAfterDeselect", () => {
      const e = this.components.get(fe);
      for (const s in this._colorsBeforeSelect) {
        let i = {};
        const n = this._colorsBeforeSelect[s];
        for (const r in n) {
          const o = e.groups.get(r);
          if (!o)
            continue;
          const a = o.getFragmentMap(n[r]);
          i = { ...i, ...a };
        }
        this.highlightByID(s, i, !1, !1);
      }
      this._colorsBeforeSelect = {};
    });
    w(this, "clearHover", () => {
      this.selection[this.config.hoverName] = {};
    });
    w(this, "onMouseDown", (e) => {
      this.enabled && (this.mouseDownPosition = { x: e.clientX, y: e.clientY }, this._mouseState.down = !0);
    });
    w(this, "onMouseUp", async (e) => {
      if (!this.enabled)
        return;
      const { world: s, autoHighlightOnClick: i, selectEnabled: n } = this.config;
      if (!s)
        throw new Error("No world found!");
      if (!s.renderer)
        throw new Error("This world doesn't have a renderer!");
      if (e.target === s.renderer.three.domElement) {
        if (this._mouseState.down = !1, this._mouseState.moved || e.button !== 0) {
          this._mouseState.moved = !1;
          return;
        }
        if (this._mouseState.moved = !1, i && n) {
          const r = this.multiple === "none" ? !0 : !e[this.multiple];
          await this.highlight(this.config.selectName, r, this.zoomToSelection);
        }
      }
    });
    w(this, "onMouseMove", async (e) => {
      if (!this.enabled)
        return;
      const s = e.clientX - this.mouseDownPosition.x, i = e.clientY - this.mouseDownPosition.y, n = Math.sqrt(s * s + i * i), { hoverName: r, hoverEnabled: o } = this.config;
      if (this._mouseState.moved) {
        this.clear(r);
        return;
      }
      if (n > this.mouseMoveThreshold) {
        this._mouseState.moved = this._mouseState.down;
        const a = {};
        for (const c in this.selection) {
          if (c === r)
            continue;
          const h = this.selection[c];
          for (const f in h) {
            f in a || (a[f] = /* @__PURE__ */ new Set());
            const u = h[f];
            for (const d of u)
              a[f].add(d);
          }
        }
        o && await this.highlight(this.config.hoverName, !0, !1, a);
      }
    });
    this.components.add(Ii.uuid, this), this.eventManager.list.add(this.onSetup), this.eventManager.list.add(this.onDisposed);
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(!1), this._fills.dispose(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.isSetup = !1, this.selection = {};
    for (const e in this.events) {
      const { onClear: s, onHighlight: i } = this.events[e];
      this.eventManager.list.delete(s), this.eventManager.list.delete(i);
    }
    this.onDisposed.trigger(Ii.uuid), this.eventManager.reset();
  }
  /**
   * Adds a new selection with the given name and color.
   * Throws an error if a selection with the same name already exists.
   *
   * @param name - The name of the new selection.
   * @param color - The color to be used for highlighting the selection.
   *
   * @throws Will throw an error if a selection with the same name already exists.
   */
  add(e, s) {
    if (this.selection[e] || this.colors.has(e))
      throw new Error("A selection with that name already exists!");
    this.colors.set(e, s), this.selection[e] = {};
    const i = new Y(), n = new Y(), r = new Y();
    this.events[e] = {
      onHighlight: i,
      onClear: r,
      onBeforeHighlight: n
    }, this.eventManager.add([r, i, n]);
  }
  /**
   * Removes the specified selection.
   *
   * @param name - The name of the new selection.
   */
  remove(e) {
    if (this.clear(e), delete this.selection[e], this.colors.delete(e), this.selection[e] || this.colors.has(e))
      throw new Error("A selection with that name already exists!");
    if (this.events[e]) {
      const { onHighlight: s, onClear: i, onBeforeHighlight: n } = this.events[e];
      this.eventManager.remove([i, s, n]), delete this.events[e];
    }
  }
  /**
   * Highlights a fragment based on a raycast from the mouse position.
   *
   * @param name - The name of the selection.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   *
   * @returns The highlighted fragment and its ID, or null if no fragment was highlighted.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlight(e, s = !0, i = this.zoomToSelection, n = {}) {
    if (!this.enabled)
      return null;
    if (!this.config.world)
      throw new Error("No world found in config!");
    const r = this.config.world;
    if (!this.selection[e])
      throw new Error(`Selection ${e} does not exist.`);
    const o = [], c = this.components.get(fe).meshes;
    for (const C of c)
      o.push(C);
    const h = this.components.get(Bs);
    for (const C of h.list) {
      const F = C;
      if (F.edges) {
        const O = F.edges.fillMeshes;
        for (const P of O)
          o.push(P);
      }
    }
    const d = this.components.get(ct).get(r).castRay(o);
    if (!d || !d.face)
      return this.clear(e), null;
    const p = d.object;
    if (!p.fragment && p.userData.indexFragmentMap) {
      if (d.faceIndex === void 0 || !p.geometry.index)
        return null;
      const { userData: C } = p, O = C.indexFragmentMap.get(d.faceIndex);
      if (O) {
        await this.highlightByID(
          e,
          O,
          s,
          i,
          n,
          p,
          !0
        );
        const P = Object.keys(O)[0];
        return { id: Array.from(O[P])[0], fragments: O };
      }
      return null;
    }
    const m = p.geometry, E = d.instanceId;
    if (!m || E === void 0)
      return null;
    const I = p.fragment.getItemID(E);
    if (I === null)
      throw new Error("Item ID not found!");
    const g = p.fragment.group;
    if (!g)
      throw new Error("Fragment must belong to a FragmentsGroup!");
    const T = g.getFragmentMap([I]);
    return await this.highlightByID(
      e,
      T,
      s,
      i,
      n,
      void 0,
      !0
    ), { id: I, fragments: T };
  }
  // TODO: Make parameters an object?
  /**
   * Highlights a fragment based on a given fragment ID map.
   *
   * @param name - The name of the selection.
   * @param fragmentIdMap - The fragment ID map to highlight.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   * @param fillMesh - The fill mesh to also highlight, if any.
   * @param isPicking - Whether this function is called when picking with the mouse.
   *
   * @returns Promise that resolves when the highlighting is complete.
   *
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlightByID(e, s, i = !0, n = this.zoomToSelection, r = {}, o = void 0, a = !1) {
    if (!this.enabled)
      return;
    this.events[e].onBeforeHighlight.trigger(this.selection[e]), i && this.clear(e);
    const c = this.components.get(fe), h = this.colors.get(e);
    if (h === void 0)
      throw new Error("Color for selection not found!");
    const f = {};
    for (const u in s) {
      const d = s[u], p = r[u];
      for (const m of d)
        if (!(p && p.has(m))) {
          if (this.selectable[e]) {
            const E = this.selectable[e];
            if (!E[u] || !E[u].has(m))
              continue;
          }
          f[u] || (f[u] = /* @__PURE__ */ new Set()), f[u].add(m);
        }
    }
    for (const u in f) {
      this.selection[e][u] || (this.selection[e][u] = /* @__PURE__ */ new Set());
      const d = f[u], p = /* @__PURE__ */ new Set(), m = /* @__PURE__ */ new Set();
      for (const I of d) {
        const g = this.selection[e][u];
        a && this.autoToggle.has(e) && g.has(I) ? (p.add(I), g.delete(I)) : (g.add(I), m.add(I));
      }
      const E = c.list.get(u);
      if (E && (p.size && (this.backupColor ? E.setColor(this.backupColor, p) : E.resetColor(p)), m.size && h !== null && E.setColor(h, m), E.mesh.userData.fills && h !== null))
        for (const I of E.mesh.userData.fills)
          this._fills.highlight(e, I, h, s);
    }
    this.events[e].onHighlight.trigger(this.selection[e]), o && h !== null && this._fills.highlight(e, o, h, s), n && await this.zoomSelection(e);
  }
  /**
   * Clears the selection for the given name or all selections if no name is provided.
   *
   * @param name - The name of the selection to clear. If not provided, clears all selections.
   * @param filter - The only items to unselect. If not provided, all items will be unselected.
   *
   */
  clear(e, s) {
    const i = e ? [e] : Object.keys(this.selection);
    for (const n of i) {
      this._fills.clear(n);
      const r = this.components.get(fe), o = this.selection[n];
      for (const a in o) {
        const c = r.list.get(a);
        if (!c)
          continue;
        let h = o[a];
        if (h) {
          if (s) {
            const f = s[a];
            if (!f)
              continue;
            const u = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
            for (const p of h)
              f.has(p) ? u.add(p) : d.add(p);
            h = u, d.size ? o[a] = d : delete o[a];
          }
          this.backupColor ? c.setColor(this.backupColor, h) : c.resetColor(h);
        }
      }
      s || (this.selection[n] = {}), this.events[n].onClear.trigger(null);
    }
  }
  /**
   * Sets up the Highlighter with the provided configuration.
   *
   * @param config - Optional configuration for the Highlighter.
   * If not provided, the Highlighter will use the default configuration.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection already exists.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  setup(e) {
    this.config = { ...this.config, ...e }, this.add(this.config.selectName, this.config.selectionColor), this.autoToggle.add(this.config.selectName), this.add(this.config.hoverName, this.config.hoverColor), this.setupEvents(!0), this.enabled = !0, this.isSetup = !0, this.onSetup.trigger(this);
  }
  /**
   * Applies all the existing styles to the given fragments. Useful when combining the highlighter with streaming.
   *
   * @param fragments - The list of fragment to update.
   */
  updateFragments(e) {
    for (const s of e)
      for (const i in this.selection) {
        const r = this.selection[i][s.id], o = this.colors.get(i);
        r && o && s.setColor(o, r);
      }
  }
  async zoomSelection(e) {
    if (!this.config.world)
      throw new Error("No world found in config!");
    const s = this.config.world;
    if (!s.camera.hasCameraControls())
      return;
    const i = this.components.get(Tn), n = this.components.get(fe);
    i.reset();
    const r = this.selection[e];
    if (!Object.keys(r).length)
      return;
    for (const I in r) {
      const g = n.list.get(I);
      if (!g)
        continue;
      const T = r[I];
      i.addMesh(g.mesh, T);
    }
    const o = i.getSphere(), a = 1 / 0, c = -1 / 0, { x: h, y: f, z: u } = o.center, d = o.radius === a || h === a || f === a || u === a, p = o.radius === c || h === c || f === c || u === c, m = o.radius === 0;
    if (d || p || m)
      return;
    o.radius *= this.zoomFactor, await s.camera.controls.fitToSphere(o, !0);
  }
  setupEvents(e) {
    if (!this.config.world) {
      console.log("No world found while setting up events!");
      return;
    }
    if (this.config.world.isDisposing)
      return;
    if (!this.config.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const s = this.config.world.renderer.three.domElement, i = this.events[this.config.selectName].onHighlight;
    i.remove(this.clearHover), i.remove(this.saveHighlightersBeforeSelect);
    const n = this.events[this.config.selectName].onClear;
    n.remove(this.restoreHighlightersAfterDeselect), s.removeEventListener("mousedown", this.onMouseDown), s.removeEventListener("mouseup", this.onMouseUp), s.removeEventListener("pointermove", this.onMouseMove), e && (i.add(this.clearHover), i.add(this.saveHighlightersBeforeSelect), n.add(this.restoreHighlightersAfterDeselect), s.addEventListener("mousedown", this.onMouseDown), s.addEventListener("mouseup", this.onMouseUp), s.addEventListener("pointermove", this.onMouseMove));
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Ii, "uuid", "cb8a76f2-654a-4b50-80c6-66fd83cafd77");
let Va = Ii;
class Zp extends ue {
  constructor() {
    super(...arguments);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /**
     * The world where the outliner operates.
     */
    w(this, "world");
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return !this.world || this.world.isDisposing ? !1 : this.getRenderer().postproduction.customEffects.outlineEnabled;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    if (!this.world || this.world.isDisposing)
      return;
    const s = this.getRenderer();
    s.postproduction.customEffects.outlineEnabled = e;
  }
  /**
   * Creates a new outlining style.
   *
   * @param name - The name of the style.
   * @param material - The material to use for the style. The color controls the line color and the opacity controls the line thickness.
   *
   */
  create(e, s) {
    const i = this.getRenderer();
    if (i.postproduction.customEffects.outlinedMeshes[e] !== void 0)
      throw new Error(`There's already a style with the name ${e}.`);
    i.postproduction.customEffects.outlinedMeshes[e] = {
      material: s,
      meshes: /* @__PURE__ */ new Set()
    };
  }
  /**
   * Adds fragments to the specified outlining style.
   *
   * @param name - The name of the style.
   * @param items - The fragments to add to the style.
   *
   */
  add(e, s) {
    const i = this.getRenderer(), r = this.getStyles()[e];
    if (!r)
      throw new Error(`The style ${e} does not exist`);
    const o = i.postproduction.customEffects.outlineScene, a = this.components.get(fe);
    for (const c in s) {
      const h = a.list.get(c);
      if (!h)
        continue;
      const f = s[c], u = h.clone(f);
      u.mesh.position.set(0, 0, 0), u.mesh.rotation.set(0, 0, 0), u.mesh.applyMatrix4(h.mesh.matrixWorld), u.mesh.instanceColor = null, u.mesh.material = [r.material], r.meshes.add(u.mesh), o.add(u.mesh);
    }
  }
  /**
   * Clears the specified style. If no style is specified, clear all styles.
   *
   * @param name - Optional: the style to clear.
   *
   */
  clear(e) {
    if (e) {
      this.clearStyle(e, !1);
      return;
    }
    const s = this.getStyles(), i = Object.keys(s);
    for (const n of i)
      this.clearStyle(n, !1);
    this.world = void 0;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    if (this.world && !this.world.isDisposing) {
      const e = this.getStyles(), s = Object.keys(e);
      for (const i of s)
        this.clearStyle(i, !0);
    }
    this.onDisposed.trigger(), this.onDisposed.reset();
  }
  clearStyle(e, s) {
    const i = this.getStyles(), n = i[e];
    if (!n)
      return;
    const r = this.components.get(Ot);
    for (const o of n.meshes) {
      const a = o;
      a.fragment && a.fragment.dispose(!1), r.destroy(o);
    }
    n.meshes.clear(), s && (n.material.dispose(), delete i[e]);
  }
  getStyles() {
    return this.getRenderer().postproduction.customEffects.outlinedMeshes;
  }
  getRenderer() {
    if (!this.world)
      throw new Error("You must set a world to use the outliner!");
    const e = this.world.renderer;
    if (!e.postproduction)
      throw new Error(
        "The world given to the outliner must use the postproduction renderer."
      );
    return e;
  }
}
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Zp, "uuid", "2fd3bcc5-b3b6-4ded-9f64-f47a02854a10");
class Lt extends ue {
  constructor() {
    super(...arguments);
    w(this, "enabled", !1);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** Event that fires after navigating to ta section. */
    w(this, "onNavigated", new Y());
    /** Event that fires after exiting the section navigation mode. */
    w(this, "onExited", new Y());
    /** The plane type for the clipping planes created by this component. */
    w(this, "planeType", "section");
    /** The default offset of the camera to the clipping plane. */
    w(this, "offset", 100);
    /** All the created sections. */
    w(this, "list", /* @__PURE__ */ new Map());
    /** The current world where the sections are being created. */
    w(this, "world");
    /** The current section that is being navigated. */
    w(this, "current", null);
    w(this, "cached3DCamera", {
      position: new A.Vector3(),
      target: new A.Vector3(),
      projection: "Perspective",
      zoom: 1,
      top: 10,
      bottom: -10,
      right: 10,
      left: -10
    });
  }
  /**
   * Generates a section with the given data.
   * @param data - The required data to create a section.
   * @param data.id - The unique identifier of the section.
   * @param data.name - The human-readable name of the section.
   * @param data.point - The 3D point where the section plane lies.
   * @param data.normal - The unit vector that describes the orientation of the clipping plane.
   * @param data.type - The type to apply to the created clipping plane.
   * @param data.offset - The offset of the camera to the section.
   */
  create(e) {
    const s = this.getWorld(), { id: i, point: n, normal: r, type: o } = e;
    let { name: a, offset: c } = e;
    const h = this.components.get(Bs), f = h.Type;
    h.Type = Sn;
    const u = h.createFromNormalAndCoplanarPoint(
      s,
      r,
      n
    );
    u.visible = !1, u.edges.visible = !1, u.enabled = !1, a = a || i, c = c || this.offset, u.type = o || this.planeType, u.updateFill();
    const d = r.clone().multiplyScalar(-c).add(n), p = n.clone(), g = { id: i, name: a, plane: u, offset: c, cached: { position: d, target: p, zoom: 1, size: 10 } };
    return this.list.set(i, g), h.Type = f, g;
  }
  /**
   * Deletes the section with the given ID.
   * @param id - The identifier whose section to delete.
   */
  delete(e) {
    const s = this.list.get(e);
    s && (s.plane.dispose(), this.list.delete(e));
  }
  /**
   * Goes to the section with the given ID.
   * @param id - The identifier whose section to delete.
   * @param animate - Whether to animate the transition.
   */
  async goTo(e, s = !1) {
    var d;
    const i = this.getCamera();
    if (((d = this.current) == null ? void 0 : d.id) === e)
      return;
    const n = this.list.get(e);
    if (!n)
      throw new Error(`There's no section with the ID: ${e}.`);
    this.cacheCameraPosition(), await this.hidePreviousClippingPlane(), await i.projection.set("Orthographic"), this.current = n;
    const r = new A.Vector3(), o = new A.Vector3(), { cached: a } = n, { position: c, target: h } = a;
    r.copy(h), o.copy(c), await i.controls.setLookAt(o.x, o.y, o.z, r.x, r.y, r.z, s);
    const f = n.cached.size, u = i.threePersp.aspect;
    i.threeOrtho.top = f, i.threeOrtho.bottom = -f, i.threeOrtho.left = -f * u, i.threeOrtho.right = f * u, i.threeOrtho.updateProjectionMatrix(), await i.controls.zoomTo(a.zoom, !1), i.set("Plan"), this.current.plane && (this.current.plane.enabled = !0, this.current.plane.edges.fillNeedsUpdate = !0, this.current.plane.edges.visible = !0), this.enabled = !0, this.onNavigated.trigger({ id: e });
  }
  /**
   * Exits the section view mode.
   * @param animate - Whether to animate the transition.
   */
  async exit(e = !1) {
    if (!this.enabled || !this.world)
      return;
    this.cacheCameraPosition();
    const s = this.getCamera();
    s.set("Orbit");
    const { position: i, target: n, projection: r } = this.cached3DCamera;
    await s.projection.set(r), this.current && (this.current.plane.enabled = !1, this.current.plane.edges.enabled = !1, this.current.plane.edges.visible = !1), this.current = null;
    const { x: o, y: a, z: c } = i, { x: h, y: f, z: u } = n;
    await s.controls.setLookAt(o, a, c, h, f, u, e), s.projection.current === "Orthographic" && (await s.controls.zoomTo(this.cached3DCamera.zoom, !1), s.threeOrtho.left = this.cached3DCamera.left, s.threeOrtho.right = this.cached3DCamera.right, s.threeOrtho.top = this.cached3DCamera.top, s.threeOrtho.bottom = this.cached3DCamera.bottom), this.enabled = !1, this.onExited.trigger();
  }
  /** {@link OBC.Disposable.onDisposed} */
  dispose() {
    for (const [, { plane: e }] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getWorld() {
    if (!this.world)
      throw new Error("World is needed to create sections!");
    return this.world;
  }
  getCamera() {
    const s = this.getWorld().camera;
    if (!s.hasCameraControls() || !s.projection)
      throw new Error(
        "The world given to sections must have an OrthoPerspective camera."
      );
    return s;
  }
  cacheCameraPosition() {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    const e = this.getCamera();
    if (this.enabled) {
      if (!this.current)
        throw new Error("Current section not found!");
      const { cached: s } = this.current, { position: i, target: n } = s;
      e.controls.getPosition(i), e.controls.getTarget(n), s.zoom = e.threeOrtho.zoom, s.size = e.threeOrtho.top;
    } else {
      e.three.getWorldPosition(this.cached3DCamera.position), e.controls.getTarget(this.cached3DCamera.target), this.cached3DCamera.projection = e.projection.current, this.cached3DCamera.zoom = e.threeOrtho.zoom;
      const { top: s, bottom: i, left: n, right: r } = e.threeOrtho;
      this.cached3DCamera.top = s, this.cached3DCamera.bottom = i, this.cached3DCamera.left = n, this.cached3DCamera.right = r;
    }
  }
  async hidePreviousClippingPlane() {
    if (this.current) {
      const e = this.current.plane;
      e && (e.enabled = !1), this.current.plane.edges.visible = !1;
    }
  }
}
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(Lt, "uuid", "45b41ba3-7bb8-4e08-909f-e0fa87973965");
const _n = class _n extends ue {
  constructor(e) {
    super(e);
    /** {@link OBC.Disposable.onDisposed} */
    w(this, "onDisposed", new Y());
    /** The plane type for the clipping planes created by this component. */
    w(this, "planeType", "floorplan");
    /**
     * Event triggered when the user navigates to a different floor plan.
     * The event provides the id of the floor plan the user navigated to.
     */
    w(this, "onNavigated", new Y());
    /**
     * Event triggered when the user exits the floor plan view.
     */
    w(this, "onExited", new Y());
    /** {@link OBC.Component.enabled} */
    w(this, "enabled", !1);
    /** The floorplan that is currently selected. */
    w(this, "currentPlan", null);
    /** The offset from the clipping planes to their respective floor plan elevation. */
    w(this, "offset", 1.5);
    /**
     * A list of all the floor plans created.
     * Each floor plan is represented by a {@link PlanView} object.
     */
    w(this, "list", []);
    w(this, "_cachedPlanCamera", null);
    this.components.add(_n.uuid, this);
  }
  /**
   * A reference to the world in which the floor plans are displayed.
   * This is used to access the camera and other relevant components.
   */
  get world() {
    return this.components.get(Lt).world;
  }
  /**
   * A reference to the world in which the floor plans are displayed.
   * This is used to access the camera and other relevant components.
   */
  set world(e) {
    const s = this.components.get(Lt);
    s.world = e;
  }
  /** The offset of the 2D camera to the floor plan elevation. */
  get defaultCameraOffset() {
    return this.components.get(Lt).offset;
  }
  /** The offset of the 2D camera to the floor plan elevation. */
  set defaultCameraOffset(e) {
    const s = this.components.get(Lt);
    s.offset = e;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.onExited.reset(), this.onNavigated.reset();
    const e = this.components.get(Lt);
    for (const s of this.list)
      e.delete(s.id);
    this.list = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Generates floor plans from the provided IFC model.
   * @param model - The IFC model from which to generate floor plans.
   * @throws Will throw an error if the model does not have properties or if floor plans are not found.
   */
  async generate(e) {
    if (!e.hasProperties)
      throw new Error("Properties are needed to compute plan views!");
    const s = await e.getAllPropertiesOfType(
      W.IFCBUILDINGSTOREY
    );
    if (!s)
      throw new Error("Floorplans not found!");
    const i = e.coordinationMatrix.elements[13], n = await cs.getUnits(e);
    for (const r of Object.values(s)) {
      const o = { value: 0 };
      this.getAbsoluteFloorHeight(r.ObjectPlacement, o);
      const a = o.value * n + i + this.offset;
      this.create({
        name: r.Name.value,
        id: r.GlobalId.value,
        normal: new A.Vector3(0, -1, 0),
        point: new A.Vector3(0, a, 0)
      });
    }
  }
  /**
   * Creates a new floor plan based on the provided configuration.
   *
   * @param config - The configuration object for the new floor plan.
   */
  create(e) {
    const s = this.components.get(Lt);
    e.type = e.type || this.planeType;
    const n = { ...s.create(e), planOffset: this.offset };
    this.list.push(n);
  }
  /**
   * Navigates to the floor plan with the specified id.
   *
   * @param id - The id of the floor plan to navigate to.
   * @param animate - Whether to animate the camera movement. Default is false.
   */
  async goTo(e, s = !1) {
    this.enabled && this.cachePlanCamera(), await this.components.get(Lt).goTo(e, s), await this.applyCachedPlanCamera();
    const n = this.list.find((r) => r.id === e);
    n && (this.currentPlan = n), this.enabled = !0;
  }
  /**
   * Exits the floor plan view and returns to the 3D view.
   *
   * @param animate - Whether to animate the camera movement. Default is false.
   */
  async exitPlanView(e = !1) {
    if (!this.enabled)
      return;
    this.cachePlanCamera(), await this.components.get(Lt).exit(e), this.currentPlan = null, this.enabled = !1, this.onExited.trigger();
  }
  cachePlanCamera() {
    var n;
    const e = (n = this.world) == null ? void 0 : n.camera, s = new A.Vector3(), i = new A.Vector3();
    e.controls.getTarget(s), e.controls.getPosition(i), this._cachedPlanCamera = {
      target: s,
      position: i,
      zoom: e.threeOrtho.zoom,
      top: e.threeOrtho.top,
      right: e.threeOrtho.right,
      bottom: e.threeOrtho.bottom,
      left: e.threeOrtho.left
    };
  }
  async applyCachedPlanCamera() {
    var c;
    if (!this._cachedPlanCamera)
      return;
    const e = (c = this.world) == null ? void 0 : c.camera, { position: s, target: i } = this._cachedPlanCamera, n = new A.Vector3(), r = new A.Vector3();
    e.controls.getPosition(n), e.controls.getTarget(r);
    const o = n.y, a = r.y;
    await e.controls.setLookAt(s.x, o, s.z, i.x, a, i.z), await e.controls.zoomTo(this._cachedPlanCamera.zoom), e.threeOrtho.top = this._cachedPlanCamera.top, e.threeOrtho.bottom = this._cachedPlanCamera.bottom, e.threeOrtho.left = this._cachedPlanCamera.left, e.threeOrtho.right = this._cachedPlanCamera.right, e.threeOrtho.updateProjectionMatrix();
  }
  getAbsoluteFloorHeight(e, s) {
    const i = e.RelativePlacement.Location.Coordinates;
    s.value += i[2].value, e.PlacementRelTo && this.getAbsoluteFloorHeight(e.PlacementRelTo, s);
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
w(_n, "uuid", "a80874aa-1c93-43a4-80f2-df346da086b1");
let za = _n;
export {
  ba as AngleMeasurement,
  Ma as AreaMeasurement,
  xa as Civil3DNavigator,
  La as CivilCrossSectionNavigator,
  Na as CivilElevationNavigator,
  dc as CivilNavigator,
  Pa as CivilPlanNavigator,
  _s as ClipEdges,
  Up as ClippingEdges,
  _p as ClippingFills,
  Ua as EdgeMeasurement,
  Sn as EdgesPlane,
  Bp as EdgesStyles,
  _a as FaceMeasurement,
  Wp as GeometryCullerRenderer,
  po as GraphicVertexPicker,
  Va as Highlighter,
  Ba as IfcStreamer,
  as as LengthMeasurement,
  Ke as Mark,
  Mt as Marker,
  Zp as Outliner,
  za as Plans,
  Oa as PlatformComponents,
  Dp as Postproduction,
  qr as PostproductionRenderer,
  Kd as RendererWith2D,
  Lt as Sections,
  va as ShadowDropper,
  Ai as SimpleDimensionLine,
  Da as VolumeMeasurement
};
